[
  {
    "objectID": "disciplinas/aed2/gaming/unidade2/2-callback.html",
    "href": "disciplinas/aed2/gaming/unidade2/2-callback.html",
    "title": "üèúÔ∏è Deserto dos Callbacks",
    "section": "",
    "text": "Voc√™ chegou ao Deserto dos Callbacks, uma terra √°rida onde apenas os programadores mais habilidosos conseguem sobreviver. Dizem que quem domina os ponteiros de fun√ß√£o e os callbacks pode invocar comportamentos gen√©ricos e controlar o fluxo da execu√ß√£o com maestria.\nPrepare-se, nossa miss√£o come√ßa agora."
  },
  {
    "objectID": "disciplinas/aed2/gaming/unidade2/2-callback.html#sec-fun",
    "href": "disciplinas/aed2/gaming/unidade2/2-callback.html#sec-fun",
    "title": "üèúÔ∏è Deserto dos Callbacks",
    "section": "O Mapa dos Endere√ßos",
    "text": "O Mapa dos Endere√ßos\nUm ponteiro tamb√©m pode armazenar o endere√ßo de uma fun√ß√£o. O racioc√≠nio √© o mesmo, mas a sintaxe para a declara√ß√£o √© mais espec√≠fica, pois ela precisa descrever a assinatura completa da fun√ß√£o: seu tipo de retorno e seus par√¢metros.\nA sintaxe de declara√ß√£o pode parecer confusa no in√≠cio, mas pode ser lida assim:\ntipo_de_retorno (*nome_do_ponteiro)(tipos_de_parametros);\nVamos tomar a fun√ß√£o meta como exemplo:\ndouble meta (double n1, double n2){\n  return (n1 + n2)/2;\n}\n\n// Declara√ß√£o de um ponteiro de fun√ß√£o:\ndouble (*meta_ptr)(double, double) = meta;\nA sintaxe de declara√ß√£o deve ser lida da seguinte forma:\n\ndouble: √© o tipo de retorno;\n(*meta_ptr): indica que meta_ptr √© um ponteiro para fun√ß√£o. Os par√™nteses s√£o obrigat√≥rios para diferenci√°-lo de uma fun√ß√£o que retorna um ponteiro;\n(double, double): s√£o os tipos dos par√¢metros da fun√ß√£o apontada.\n\n\n\n\n\n\n\nNota\n\n\n\nDiferentemente das vari√°veis, ao atribuir o endere√ßo de uma fun√ß√£o a um ponteiro de fun√ß√£o, n√£o √© necess√°rio usar o operador & (o nome da fun√ß√£o sozinho j√° representa seu endere√ßo).\n\n\nNote que a fun√ß√£o meta obedece a assinatura (ou contrato) estabelecido pelo ponteiro de fun√ß√£o meta_ptr, ou seja, possui o mesmo tipo de retorno e os mesmos tipos de par√¢metros de entrada (double, double) Portanto, devemos manter a compatibilidade de tipos."
  },
  {
    "objectID": "disciplinas/aed2/gaming/unidade2/2-callback.html#sec-cal",
    "href": "disciplinas/aed2/gaming/unidade2/2-callback.html#sec-cal",
    "title": "üèúÔ∏è Deserto dos Callbacks",
    "section": "Introdu√ß√£o aos Callbacks",
    "text": "Introdu√ß√£o aos Callbacks\nO verdadeiro poder dos ponteiros de fun√ß√£o aparece quando uma fun√ß√£o √© passada como argumento para outra. Nesse caso, a fun√ß√£o que recebe outra fun√ß√£o √© chamada de fun√ß√£o de ordem superior, enquanto a fun√ß√£o fornecida como argumento √© chamada de callback.\nEssa t√©cnica permite que um trecho de c√≥digo delegue parte de seu comportamento a outro, tornando o programa mais flex√≠vel, modular e param√©trico.\nAbaixo, um exemplo de uma calculadora de inteiros, onde calcular √© uma fun√ß√£o de ordem superior, pois recebe outra fun√ß√£o como par√¢metro. As fun√ß√µes soma, subtracao, produto e divisao s√£o callbacks, pois s√£o passadas para calcular para que ela decida qual comportamento executar.\n\n\ncalculadora_param.c\n\n#include &lt;stdio.h&gt;\n\n// Fun√ß√µes concretas (implementam comportamentos espec√≠ficos)\nint soma (int a, int b)     { return a + b; }\nint subtracao (int a, int b){ return a - b; }\nint produto (int a, int b)  { return a * b; }\nint divisao (int a, int b)  { return a / b; }\n\n// Fun√ß√£o coordenadora (de ordem superior)\n// Recebe duas vari√°veis e uma fun√ß√£o como par√¢metro\nint calcular(int a, int b, int (*operacao)(int, int)) {\n  return operacao(a, b);\n}\n\nint main(){\n\n  int n1 = 10;\n  int n2 = 2;\n  \n  printf(\"Soma:      %d\\n\", calcular(n1, n2, soma));\n  printf(\"Subtra√ß√£o: %d\\n\", calcular(n1, n2, subtracao));\n  printf(\"Produto:   %d\\n\", calcular(n1, n2, produto));\n  printf(\"Divis√£o:   %d\\n\", calcular(n1, n2, divisao));  \n  \n  return 0;\n}\n\nA fun√ß√£o calcular n√£o sabe qual opera√ß√£o ser√° executada, ela apenas invoca o comportamento recebido como par√¢metro. Isso √© o que chamamos de abstra√ß√£o de comportamento.\nA sa√≠da desse programa ser√°\n  Soma:      12\n  Subtra√ß√£o: 8\n  Produto:   20\n  Divis√£o:   5 \nAo passar a fun√ß√£o como par√¢metro, tornamos o c√≥digo de C extremamente poderoso e reutiliz√°vel. A fun√ß√£o calcular n√£o se importa como o c√°lculo √© feito, apenas que a fun√ß√£o fornecida (o callback) respeite o contrato de tipos (int para retorno, e int, int para par√¢metros).\nPodemos ir al√©m nessa reutiliza√ß√£o? Sim, mas atingimos o limite do polimorfismo simples em C. Imagine que voc√™ queira adicionar uma opera√ß√£o com n√∫meros de ponto flutuante:\ndouble somad (double a, double b) { return a + b; }\nO problema √© que n√£o podemos passar somad para a fun√ß√£o calcular e nem a usar para operar com double, pois o callback int (*operacao)(int, int) e os par√¢metros fixos em calcular(int a, int b, ...) tornam essa fun√ß√£o totalmente incompat√≠vel com o tipo double.\nPara resolver esse problema e criar uma √∫nica fun√ß√£o verdadeiramente gen√©rica que aceite qualquer tipo de dado, precisamos abandonar os tipos concretos (int, double) e generalizar usando o ponteiro sem tipo (void*).\nAntes de darmos o salto para o c√≥digo verdadeiramente gen√©rico usando void*, vamos usar o typedef para melhorar a legibilidade de nosso c√≥digo.\nA sintaxe de um ponteiro de fun√ß√£o (int (*operacao)(int, int)) √© complexa e pode dificultar a leitura do c√≥digo. O typedef permite que voc√™ crie um apelido para essa assinatura complexa, tratando-a como um novo tipo de dado simples.\nAo definir o tipo do callback, tornamos a fun√ß√£o calcular muito mais limpa:\n// Definimos 'Operacao' como o tipo para qualquer fun√ß√£o\n// que retorna int e aceita dois int como par√¢metros.\ntypedef int (*Operacao)(int, int);\n\n// A fun√ß√£o 'calcular' agora usa o tipo 'Operacao', \n// simplificando sua assinatura.\nint calcular(int a, int b, Operacao operacao); \nO c√≥digo final ficaria assim:\n\n\ncalculadora_typedef.c\n\n#include &lt;stdio.h&gt;\n\n// Defini√ß√£o do TIPO de ponteiro de fun√ß√£o\ntypedef int (*Operacao)(int, int);\n\n// Fun√ß√µes concretas (omitidas para brevidade)\nint soma (int a, int b) { return a + b; }\n// ...\n\n// A Fun√ß√£o Coordenadora agora √© mais leg√≠vel\nint calcular(int a, int b, Operacao operacao) {\n  return operacao(a, b);\n}\n\nint main(){\n\n  int n1 = 10;\n  int n2 = 2;\n  \n  printf(\"Soma: %d\\n\", calcular(n1, n2, soma));\n  \n  return 0;\n}"
  },
  {
    "objectID": "disciplinas/aed2/gaming/unidade2/2-callback.html#sec-gen",
    "href": "disciplinas/aed2/gaming/unidade2/2-callback.html#sec-gen",
    "title": "üèúÔ∏è Deserto dos Callbacks",
    "section": "Ponteiro gen√©rico",
    "text": "Ponteiro gen√©rico\nAgora que compreendemos o funcionamento dos ponteiros e a passagem por refer√™ncia, podemos dar um passo al√©m, como representar qualquer tipo de dado usando ponteiros gen√©ricos.\nEm C, o tipo void* √© conhecido como ponteiro gen√©rico (generic pointer). Ele √© um tipo especial de ponteiro que pode armazenar o endere√ßo de qualquer tipo de dado, por exemplo int, double, char, struct etc.\nint idade = 20;\ndouble meta = 8.5;\nchar letra = 'A';\n\nvoid *ptr;\n\nptr = &idade;\nprintf(\"idade: %d\\n\", *(int*)ptr);\n\nptr = &meta;\nprintf(\"meta: %.2f\\n\", *(double*)ptr);\n\nptr = &letra;\nprintf(\"letra: %c\\n\", *(char*)ptr);\nRepare que, embora ptr sempre seja do tipo void*, precisamos fazer um cast (convers√£o expl√≠cita) para o tipo correto antes de acessar o valor. Isso ocorre porque o compilador n√£o sabe qual √© o tipo real do dado armazenado e, portanto, n√£o pode fazer aritm√©tica de ponteiros nem desreferencia√ß√£o direta.\nEssa caracter√≠stica √© o que permite criar estruturas de dados gen√©ricas em C, como listas, pilhas ou filas capazes de armazenar qualquer tipo. Essas estruturas ir√£o guardar apenas endere√ßos gen√©ricos (void*) e n√£o se importar com o tipo concreto do dado. A responsabilidade de interpretar corretamente o tipo ser√° de quem usar a estrutura."
  },
  {
    "objectID": "disciplinas/aed2/gaming/unidade2/2-callback.html#sec-siz",
    "href": "disciplinas/aed2/gaming/unidade2/2-callback.html#sec-siz",
    "title": "üèúÔ∏è Deserto dos Callbacks",
    "section": "O papel de size_t",
    "text": "O papel de size_t\nAo manipular dados de tipos diferentes, precisamos tamb√©m saber quanto de mem√≥ria reservar ou copiar. √â a√≠ que entra o tipo size_t, definido no cabe√ßalho &lt;stddef.h&gt; (ou implicitamente inclu√≠do via &lt;stdlib.h&gt; ou &lt;stdio.h&gt;).\nComo um tipo num√©rico sem sinal (unsigned), size_t √© usado para representar tamanhos e quantidades de bytes. Ele √© o tipo de retorno de fun√ß√µes como sizeof, malloc, calloc e strlen.\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main() {\n    int x = 10;\n    double y = 3.14;\n\n    printf(\"sizeof(int): %zu bytes\\n\", sizeof(int));\n    printf(\"sizeof(double): %zu bytes\\n\", sizeof(double));\n\n    void *ptr = malloc(sizeof(double));\n    printf(\"Alocado %zu bytes em %p\\n\", sizeof(double), ptr);\n\n    free(ptr);\n    return 0;\n}\nSa√≠da t√≠pica:\nsizeof(int): 4 bytes\nsizeof(double): 8 bytes\nAlocado 8 bytes em 0x7ffee1\nA combina√ß√£o de void* e size_t √© fundamental para criar estruturas gen√©ricas, pois usaremos void* para representar o dado, independentemente de tipo e size_t para indicar o tamanho desse dado, permitindo c√≥pia, aloca√ß√£o e manipula√ß√£o seguras.\nFalta pouco para criarmos nossas estruturas gen√©ricas com comportamentos tamb√©m gen√©ricos. Antes, precisamos entender como generalizar a√ß√µes, ou seja, como permitir que uma estrutura chame fun√ß√µes que mudam conforme o tipo de dado.\nE √© aqui que entra o pr√≥ximo conceito fundamental, a abstra√ß√£o de comportamento. Para isso, devemos estudar os ponteiros para fun√ß√£o e callbacks."
  },
  {
    "objectID": "disciplinas/aed2/gaming/unidade2/3-memoria.html",
    "href": "disciplinas/aed2/gaming/unidade2/3-memoria.html",
    "title": "‚õ∞Ô∏è Vale da Mem√≥ria",
    "section": "",
    "text": "Trocar Tema\nAt√© aqui, vimos como generalizar dados e comportamentos em C usando ponteiros e callbacks. No entanto, toda essa flexibilidade traz a responsabilidade de gerenciar manualmente a mem√≥ria.\nNesta se√ß√£o, vamos entender como a linguagem C lida com a aloca√ß√£o din√¢mica, isto √©, a capacidade de reservar e liberar mem√≥ria em tempo de execu√ß√£o. Mais importante, veremos como evitar os erros de mem√≥ria mais comuns que podem comprometer a estabilidade e a seguran√ßa de um programa."
  },
  {
    "objectID": "disciplinas/aed2/gaming/unidade2/3-memoria.html#sec-alo",
    "href": "disciplinas/aed2/gaming/unidade2/3-memoria.html#sec-alo",
    "title": "‚õ∞Ô∏è Vale da Mem√≥ria",
    "section": "Aloca√ß√£o e libera√ß√£o din√¢mica",
    "text": "Aloca√ß√£o e libera√ß√£o din√¢mica\nQuando trabalhamos com arrays ou estruturas em C, geralmente definimos seus tamanhos em tempo de compila√ß√£o. Eles ficam armazenados em uma √°rea de mem√≥ria chamada stack.\nNo entanto, h√° muitos casos em que o tamanho dos dados n√£o √© conhecido antecipadamente. Para esses casos, o C fornece fun√ß√µes de aloca√ß√£o din√¢mica de mem√≥ria, que permitem reservar e liberar espa√ßo em tempo de execu√ß√£o. Esses blocos de mem√≥ria s√£o criados em uma regi√£o especial chamada heap.\nDizemos que a mem√≥ria stack √© est√°tica, enquanto que a heap √© din√¢mica. Na stack, quando a fun√ß√£o termina, a vari√°vel √© destru√≠da. J√° na heap, o programador decide quando alocar e liberar.\nA aloca√ß√£o din√¢mica oferece flexibilidade, mas tamb√©m exige disciplina. O princ√≠pio fundamental √©: quem aloca, deve liberar.\n\nAloca√ß√£o simples\nA fun√ß√£o malloc (de memory allocation) reserva um bloco cont√≠nuo de mem√≥ria de tamanho especificado em bytes.\nint *v = malloc(5 * sizeof(int));\nO argumento √© o n√∫mero total de bytes a serem alocados. No trecho acima, estamos alocando o espa√ßo suficiente para cinco inteiros. O retorno √© um ponteiro gen√©rico (void*) para o in√≠cio do bloco. Caso a aloca√ß√£o falhe, malloc retorna NULL.\n\n\n\n\n\n\nNota\n\n\n\nEm C, ao contr√°rio de C++, n√£o h√° necessidade de fazer o cast do ponteiro gen√©rico.\n\n\nComo n√£o temos garantia que a mem√≥ria foi alocada, precisamos tratar quando malloc falha. Isso √© geramente feito com um bloco if.\nint *v = malloc(5 * sizeof(int));\n    \nif (v == NULL) {\n    fprintf(stderr, \"Erro: sem mem√≥ria suficiente!\\n\");\n    return 1;\n}       \nNo trecho acima, poder√≠amos ter usado printf ao inv√©s de fprintf. A escolha, por fprintf se d√° por ser o padr√£o para erros. Ele permite especificar exatamente para onde a sa√≠da deve ir. Ao usarmos stderr (de standard error), estamos dizendo ao sistema que esta mensagem √© um erro e deve ser tratada como tal.\nQuando usamos printf a sa√≠da √© armazenada em buffer, portanto a mensagem de erro poderia ficar presa e nunca ser exibida antes do programa abortar. J√° quando optamos por fprintf, a sa√≠da √© unbuffered, ou seja, √© exibida imediatamente no terminal.\nResumindo, use fprinf mensagens de erro, diagn√≥stico e logs cr√≠ticos e use printf para mensagens de sucesso, resultado da aplica√ß√£o e sa√≠da esperada.\nO return 1 informa ao sistema operacional que algo deu errado .\n\n\nAloca√ß√£o e inicializa√ß√£o\nA fun√ß√£o calloc (de contiguous allocation) funciona como malloc, mas com duas diferen√ßas:\n\nRecebe dois par√¢metros, n√∫mero de elementos e tamanho de cada um;\nInicializa o bloco com zeros.\n\nint *v = calloc(5, sizeof(int));\nAssim, todo o vetor come√ßa zerado, o que evita leituras de lixo de mem√≥ria.\n\n\nRedimensionamento de bloco\nA fun√ß√£o realloc permite ajustar o tamanho de um bloco de mem√≥ria j√° alocado.\nint *novo = realloc(v, 10 * sizeof(int));\nSe houver espa√ßo cont√≠guo suficiente, o bloco √© expandido no mesmo local. Caso contr√°rio, um novo bloco √© alocado e o conte√∫do antigo √© copiado automaticamente. Em caso de falha, retorna NULL e n√£o desaloca o bloco de mem√≥ria original. Por isso, √© recomendado sempre usar um ponteiro tempor√°rio:\nint *temp = realloc(v, 10 * sizeof(int));\nif (temp == NULL) {\n    fprintf(stderr, \"Erro ao realocar mem√≥ria!\\n\");\n    return 1;\n}\nv = temp; // Atualiza o ponteiro com seguran√ßa\n\n\nLibera√ß√£o de mem√≥ria\nA fun√ß√£o free libera um bloco previamente alocado com malloc, calloc ou realloc. Ela devolve o espa√ßo ao sistema operacional, mas n√£o zera o ponteiro.\nfree(v);\nv = NULL; // Boa pr√°tica\n\n\n\n\n\n\nImportante\n\n\n\nAp√≥s liberar, o ponteiro ainda guarda o endere√ßo antigo, agora inv√°lido. Atribuir NULL ajuda a evitar o uso acidental, um erro cl√°ssico conhecido como dangling pointer.\n\n\nEste ciclo √© a base de toda manipula√ß√£o segura de mem√≥ria din√¢mica em C:\n\n\n\n\n\nflowchart LR\n    A(\"Alocar\") --&gt; B(\"Usar\")\n    B --&gt; C(\"Liberar\")  \n    C --&gt; D(\"Invalidar\")\n    D --&gt; A\n\n\n\n\n\n\n\nAlocar (malloc, calloc ou realloc)\nUsar (ler e escrever por meio do ponteiro)\nLiberar (free)\nInvalidar o ponteiro (ptr = NULL)\n\nCom essas fun√ß√µes, temos total controle sobre a vida √∫til de cada dado em mem√≥ria. No entanto, esse poder vem acompanhado de riscos: acessos indevidos, vazamentos e corrup√ß√£o de mem√≥ria s√£o erros comuns quando o ciclo de aloca√ß√£o n√£o √© seguido corretamente.\nNa pr√≥xima se√ß√£o, vamos explorar as fun√ß√µes de manipula√ß√£o de blocos de mem√≥ria e entender como oper√°-las com seguran√ßa antes de mergulhar nos erros cl√°ssicos de mem√≥ria."
  },
  {
    "objectID": "disciplinas/aed2/gaming/unidade2/3-memoria.html#sec-man",
    "href": "disciplinas/aed2/gaming/unidade2/3-memoria.html#sec-man",
    "title": "‚õ∞Ô∏è Vale da Mem√≥ria",
    "section": "Manipula√ß√£o de blocos de mem√≥ria",
    "text": "Manipula√ß√£o de blocos de mem√≥ria\nQuando trabalhamos com aloca√ß√£o din√¢mica, frequentemente precisamos copiar dados de uma regi√£o de mem√≥ria para outra. O C oferece um conjunto de fun√ß√µes na biblioteca &lt;string.h&gt; para manipular blocos de mem√≥ria de forma gen√©rica, usando ponteiros do tipo void*.\nEssas fun√ß√µes operam diretamente em bytes, e n√£o conhecem o tipo de dado armazenado. Por isso, exigem aten√ß√£o com o tamanho dos blocos manipulados (geralmente expresso com size_t).\nAs tr√™s fun√ß√µes principais para manipula√ß√£o de blocos de mem√≥ria s√£o:\n\nmemcpy: copia bytes de uma origem para um destino\nmemmove: copia bytes com seguran√ßa mesmo se houver sobreposi√ß√£o\nmemset: preenche uma √°rea de mem√≥ria com um valor constante\n\n\nCopiando blocos de mem√≥ria\nA fun√ß√£o memcpy copia \\(n\\) bytes do bloco apontado por src (origem) para o bloco apontado por dest (destino).\nvoid *memcpy(void *dest, const void *src, size_t n);\nExemplo pr√°tico:\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main() {\n    int origem[5] = {1, 2, 3, 4, 5};\n    int destino[5];\n\n    memcpy(destino, origem, 5 * sizeof(int));\n\n    for (int i = 0; i &lt; 5; i++)\n        printf(\"%d \", destino[i]);\n    \n    return 0;\n}\nSa√≠da:\n1 2 3 4 5\n\n\n\n\n\n\nImportante\n\n\n\nA fun√ß√£o memcpy n√£o deve ser usada quando as regi√µes de origem e destino se sobrep√µem. O comportamento √© indefinido, podendo corromper os dados.\n\n\n\n\nC√≥pia segura com sobreposi√ß√£o\nA fun√ß√£o memmove √© semelhante a memcpy, mas trata corretamente casos de sobreposi√ß√£o. Se o bloco de destino estiver dentro da √°rea de origem (ou vice-versa), ela ajusta a dire√ß√£o da c√≥pia automaticamente.\nvoid *memmove(void *dest, const void *src, size_t n);\nExemplo:\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main() {\n    char texto[20] = \"ABCDEF\";\n\n    // Copiando parte sobreposta\n    memmove(texto + 2, texto, 4);\n    texto[6] = '\\0';\n\n    printf(\"%s\\n\", texto); // Resultado: \"ABABCD\"\n    return 0;\n}\nSe tiv√©ssemos usado memcpy nesse exemplo, o conte√∫do de texto poderia ser corrompido, pois as regi√µes texto e texto + 2 se sobrep√µem.\n\n\nInicializando mem√≥ria\nA fun√ß√£o memset preenche um bloco de mem√≥ria com um valor constante em bytes. Ela √© muito usada para inicializar buffers ou zerar estruturas.\nvoid *memset(void *ptr, int valor, size_t n);\nExemplo:\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main() {\n    int v[5];\n    memset(v, 0, 5 * sizeof(int));\n\n    for (int i = 0; i &lt; 5; i++)\n        printf(\"%d \", v[i]);\n    \n    return 0;\n}\nSa√≠da:\n0 0 0 0 0\n\n\n\n\n\n\nImportante\n\n\n\nO valor passado a memset √© interpretado como um byte, e n√£o como um inteiro completo. Por exemplo, memset(v, 1, sizeof(int)*5) preencher√° todos os bytes com 0x01, n√£o com o inteiro 1."
  },
  {
    "objectID": "disciplinas/aed2/gaming/unidade2/3-memoria.html#sec-cui",
    "href": "disciplinas/aed2/gaming/unidade2/3-memoria.html#sec-cui",
    "title": "‚õ∞Ô∏è Vale da Mem√≥ria",
    "section": "Cuidados e boas pr√°ticas",
    "text": "Cuidados e boas pr√°ticas\n\nSempre use sizeof para calcular o n√∫mero correto de bytes.\n\nEvite express√µes m√°gicas como memcpy(dest, src, 20).\nUse memcpy(dest, src, n * sizeof(T)).\n\nPrefira memmove quando houver d√∫vida sobre sobreposi√ß√£o.\nZere estruturas antes de us√°-las (por exemplo, buffers de strings).\nEvite manipular mem√≥ria de tipos complexos (estruturas com ponteiros internos) com memcpy\n\nIsso pode quebrar o encapsulamento e gerar c√≥pias superficiais perigosas.\n\n\nCom essas fun√ß√µes, temos ferramentas poderosas para manipular diretamente a mem√≥ria. Isso √© um recurso essencial para implementar estruturas gen√©ricas e opera√ß√µes de baixo n√≠vel. Entretanto, o uso incorreto dessas fun√ß√µes √© uma das principais causas de erros sutis e dif√≠ceis de depurar em C.\nNa pr√≥xima se√ß√£o, estudaremos exatamente esses erros, os erros cl√°ssicos de mem√≥ria, como dangling pointers, buffer overflow e double free, e como evit√°-los com boas pr√°ticas.\n\nErros cl√°ssicos de mem√≥ria\nGerenciar mem√≥ria manualmente √© uma das maiores responsabilidades (e riscos) ao programar em C. Ao lidar com ponteiros e aloca√ß√£o din√¢mica, pequenos descuidos podem causar comportamentos indefinidos, travamentos ou at√© falhas de seguran√ßa.\nNesta se√ß√£o, veremos os erros mais comuns, seus sintomas e como evit√°-los.\n\nPonteiros n√£o inicializados (wild pointers)\nUm wild pointer √© um ponteiro que n√£o foi inicializado antes do uso. Ele cont√©m um valor de endere√ßo aleat√≥rio, podendo apontar para qualquer lugar da mem√≥ria.\n#include &lt;stdio.h&gt;\n\nint main() {\n    int *p;       // n√£o inicializado!\n    *p = 42;      // comportamento indefinido!\n    printf(\"%d\\n\", *p);\n    return 0;\n}\n\n\n\n\n\n\nCuidado\n\n\n\nEsse c√≥digo pode travar o programa (segmentation fault), corromper dados ou at√© ‚Äúfuncionar‚Äù, mascarando o erro (o pior cen√°rio).\n\n\nComo boa pr√°tica, sempre inicialize ponteiros:\nint *p = NULL;\n\n\nPonteiros pendentes (dangling pointers)\nUm dangling pointer ocorre quando o ponteiro ainda referencia uma regi√£o de mem√≥ria j√° liberada.\n#include &lt;stdlib.h&gt;\n\nint main() {\n    int *p = malloc(sizeof(int));\n    *p = 10;\n    free(p);\n    printf(\"%d\\n\", *p); // uso ap√≥s libera√ß√£o ‚Äî ERRO\n    return 0;\n}\n\n\n\n\n\n\nCuidado\n\n\n\nO bloco de mem√≥ria foi liberado, mas o ponteiro ainda ‚Äúacha‚Äù que √© v√°lido. Acessar ou modificar essa regi√£o causa comportamento indefinido.\n\n\nComo boa pr√°tica, ap√≥s free(p), defina p = NULL; para evitar acessos acidentais.\n\n\nVazamentos de mem√≥ria (memory leaks)\nUm memory leak acontece quando um programa perde a refer√™ncia para uma regi√£o de mem√≥ria alocada, sem cham√°-la com free().\n#include &lt;stdlib.h&gt;\n\nint main() {\n    int *p = malloc(100 * sizeof(int));\n    p = NULL;  // perdemos a refer√™ncia ‚Äî vazamento!\n    return 0;\n}\n\n\n\n\n\n\nCuidado\n\n\n\nA mem√≥ria continua alocada, mas inacess√≠vel. Em programas longos, isso pode acumular e exaurir a mem√≥ria do sistema.\n\n\nComo boas pr√°tica, sempre emparelhe malloc e free. Em fun√ß√µes complexas, adote o princ√≠pio ‚Äúquem aloca, libera‚Äù.\n\n\nLibera√ß√£o duplicada (double free)\nUm double free ocorre quando tentamos liberar o mesmo bloco de mem√≥ria mais de uma vez.\n#include &lt;stdlib.h&gt;\n\nint main() {\n    int *p = malloc(sizeof(int));\n    free(p);\n    free(p); // ERRO: double free\n    return 0;\n}\n\n\n\n\n\n\nCuidado\n\n\n\nIsso causa corrup√ß√£o da estrutura interna do heap e frequentemente resulta em segmentation fault.\n\n\nComo boa pr√°tica, ap√≥s liberar, defina p = NULL.\n\n\nAcesso fora dos limites (buffer overflow e underrun)\nUm buffer overflow ocorre quando se escreve al√©m do final (ou antes do in√≠cio) de um bloco de mem√≥ria.\n#include &lt;stdio.h&gt;\n\nint main() {\n    int v[3] = {1, 2, 3};\n    v[3] = 99; // √≠ndice inv√°lido ‚Äî overflow\n    printf(\"%d\\n\", v[3]); // comportamento indefinido\n    return 0;\n}\n\n\n\n\n\n\nCuidado\n\n\n\nEsse tipo de erro √© grave: pode corromper vari√°veis adjacentes, causar travamentos ou vulnerabilidades de seguran√ßa (explora√ß√£o de stack overflow).\n\n\nComo boas pr√°tica, sempre verifique limites de vetores. Al√©m disso, prefira fun√ß√µes seguras (ex: strncpy no lugar de strcpy). Ao usar malloc, garanta que o tamanho esteja correto com sizeof.\nPodemos resumir os tipos de erros abordados por meio da seguinte tabela.\n\n\n\n\n\n\n\n\n\nTipo de Erro\nCausa\nSintoma\nPreven√ß√£o\n\n\n\n\nWild Pointer\nPonteiro n√£o inicializado\nCrash aleat√≥rio\nInicializar com NULL\n\n\nDangling Pointer\nUso ap√≥s free\nSegmentation fault\np = NULL ap√≥s free\n\n\nMemory Leak\nPerda de refer√™ncia\nAumento de uso de mem√≥ria\nSempre liberar\n\n\nDouble Free\nLibera√ß√£o repetida\nCorrup√ß√£o do heap\nControle de ownership\n\n\nBuffer Overflow\nEscrita fora dos limites\nCorrup√ß√£o de mem√≥ria\nVerificar limites\n\n\n\nErros de mem√≥ria est√£o entre os mais sutis e perigosos em C. Eles n√£o apenas causam falhas, mas podem introduzir vulnerabilidades de seguran√ßa s√©rias. Com boas pr√°ticas e ferramentas adequadas, √© poss√≠vel evit√°-los e desenvolver sistemas robustos e confi√°veis."
  },
  {
    "objectID": "disciplinas/aed2/gaming/unidade2/3-memoria.html#sec-boa",
    "href": "disciplinas/aed2/gaming/unidade2/3-memoria.html#sec-boa",
    "title": "‚õ∞Ô∏è Vale da Mem√≥ria",
    "section": "Boas pr√°ticas e padr√µes",
    "text": "Boas pr√°ticas e padr√µes\nGerenciar mem√≥ria em C exige disciplina. A responsabilidade √© totalmente do programador, pois o compilador n√£o faz verifica√ß√µes autom√°ticas. A seguir, apresentamos um conjunto de princ√≠pios e padr√µes que ajudam a escrever c√≥digo seguro, previs√≠vel e f√°cil de manter.\n\nInicializa√ß√£o defensiva\nSempre inicialize ponteiros, mesmo quando voc√™ ainda n√£o sabe qual endere√ßo eles ter√£o.\nint *p = NULL;\nEssa pr√°tica evita comportamentos indefinidos quando o ponteiro √© usado antes de ser atribu√≠do. Ela tamb√©m facilita verifica√ß√µes de seguran√ßa:\nif (p != NULL) {\n    *p = 42;\n}\n\n\n\n\n\n\nDica\n\n\n\nUm ponteiro deve sempre apontar para algo v√°lido, ou para NULL.\n\n\n\n\nO princ√≠pio da propriedade (ownership)\nEm programas maiores, √© comum que uma fun√ß√£o aloca mem√≥ria e outra a utilize. Para evitar vazamentos ou libera√ß√µes incorretas, defina quem √© o dono (owner) de cada bloco alocado.\nüî∏ Quem aloca √© respons√°vel por liberar.\nExemplo:\nchar* criar_mensagem() {\n    char *msg = malloc(50);\n    sprintf(msg, \"Ol√°, mundo!\");\n    return msg;  // a fun√ß√£o devolve a posse\n}\n\nint main() {\n    char *m = criar_mensagem();\n    puts(m);\n    free(m);     // responsabilidade de quem recebeu\n}\n\n\nPar malloc e free\nCada chamada de aloca√ß√£o din√¢mica deve ter uma contrapartida de libera√ß√£o. Evite fluxos de execu√ß√£o que impe√ßam o free de ser chamado.\nchar *p = malloc(100);\nif (!p) return;   // erro de aloca√ß√£o\n// ...\nfree(p);\n\n\n\n\n\n\nDica\n\n\n\nCentralize libera√ß√µes num √∫nico ponto de sa√≠da, especialmente em fun√ß√µes longas.\n\n\n\n\nEvite opera√ß√µes parciais\nNunca tente liberar apenas parte de uma estrutura alocada. Sempre opere sobre a mesma refer√™ncia retornada por malloc.\nint *v = malloc(10 * sizeof(int));\nint *p = v + 5;\nfree(p); // ‚ùå comportamento indefinido\nfree(v); // ‚úÖ correto\n\n\nZerar mem√≥ria ap√≥s libera√ß√£o (quando necess√°rio)\nEm sistemas que lidam com dados sens√≠veis (como senhas), vale a pena limpar o conte√∫do antes de liberar.\nmemset(senha, 0, tamanho);\nfree(senha);\nIsso impede que dados fiquem acess√≠veis em regi√µes de mem√≥ria reaproveitadas.\n\n\nMacros e wrappers de seguran√ßa\nEm projetos grandes, √© comum encapsular chamadas de aloca√ß√£o/libera√ß√£o em fun√ß√µes auxiliares. Isso facilita rastrear erros e aplicar verifica√ß√µes centralizadas.\nvoid* safe_malloc(size_t n) {\n    void *p = malloc(n);\n    if (p == NULL) {\n        fprintf(stderr, \"Erro: malloc falhou\\n\");\n        exit(EXIT_FAILURE);\n    }\n    return p;\n}\nüîπ Com esse padr√£o, voc√™ garante que toda aloca√ß√£o seja verificada.\nGerenciar mem√≥ria em C √© uma arte de equil√≠brio entre controle total e responsabilidade absoluta. Com disciplina e padr√µes bem definidos, √© poss√≠vel construir sistemas robustos, perform√°ticos e seguros."
  },
  {
    "objectID": "disciplinas/aed2/gaming/index.html",
    "href": "disciplinas/aed2/gaming/index.html",
    "title": "Algoritmos e Estruturas de Dados 2",
    "section": "",
    "text": "Bem-vindo ao portal de REA sobre Algoritmos e Estruturas de Dados 2. Aqui voc√™ encontrar√° informa√ß√µes sobre a bibliografia, aulas ministradas e muito mais. Nesta empreitada, n√£o estaremos sozinhos, vamos conhecer quem trilhar√° conosco e nos ajudar√° a compreender melhor alguns conceitos importantes desta mat√©ria."
  },
  {
    "objectID": "disciplinas/aed2/gaming/index.html#companheiros-de-jornada",
    "href": "disciplinas/aed2/gaming/index.html#companheiros-de-jornada",
    "title": "Algoritmos e Estruturas de Dados 2",
    "section": "Companheiros de Jornada",
    "text": "Companheiros de Jornada\n\n\n\nShellSort e Hashy\n\n\n\n\n\n\nOl√°, pessoal! Eu sou o ShellSort, mas podem me chamar de Shell!\n\n\n\n\n\nE eu sou a Hashy!\n\n\n\n\n\nVamos te auxiliar na jornada pelos Algoritmos e Estruturas de Dados. Como podem ver, levo minha ‚Äòestrutura de dados‚Äô (meu casco) por onde ando. Mas n√£o se enganem: por dentro, sou cheio de n√≥s e refer√™ncias, pronto para guiar voc√™s pelo universo da programa√ß√£o!\n\n\n\n\n\nShellzinho, voc√™ √© realmente √≥timo em colocar as coisas em ordem com paci√™ncia, mas eu sou a especialista em organiza√ß√£o r√°pida e busca eficiente.\n\n\n\n\n\n√â verdade Hashy, a gente se completa. Nossa miss√£o √© simples: mostrar que, com paci√™ncia e m√©todo, at√© os conceitos mais complexos se tornam f√°ceis de dominar.‚ÄúDevagar e sempre avante, esse √© o meu algoritmo!‚Äù\n\n\n\n\n\nMeu casco pode parecer um s√≥, mas por dentro √© uma rede superorganizada, pronta para armazenar conhecimento e refer√™ncias. Podem contar comigo para entender como otimizar seus c√≥digos em C e resolver problemas com velocidade!‚ÄúSeja r√°pida, seja precisa. Ache a chave!‚Äù\n\n\n\n\n\nVamos juntos nessa jornada de aprendizado!\n\n\n\n\nJuntos com Shell e Hashy, vamos explorar o mundo das estruturas de dados e seus algoritmos. Prepare-se para um jornada desafiadora e divertida enfrentando os diversos desafios que nos tornar√£o melhores programadores."
  },
  {
    "objectID": "disciplinas/aed2/gaming/index.html#portal-dos-mundos",
    "href": "disciplinas/aed2/gaming/index.html#portal-dos-mundos",
    "title": "Algoritmos e Estruturas de Dados 2",
    "section": "Portal dos Mundos",
    "text": "Portal dos Mundos\n\n\n\n\nExplore o mundo das estruturas de dados e desbloqueie novos desafios de aprendizado!\n\n\n\n\n \n    üå≥ Arquip√©lago das √Årvores\n   \n      üå± √Årvores\n      üå≤ √Årvores Bin√°rias\n      üîç √Årvore Bin√°ria de Busca\n      ‚öñÔ∏è √Årvore AVL\n    \n  \n\n  \n    üß© Plan√≠cie Gen√©rica\n    \n      üèùÔ∏è Fundamentos e Ferramentas Gen√©ricas\n      ‚öôÔ∏è Aplica√ß√£o: A Calculadora Gen√©rica\n      üå≥ Listas e √Årvores Gen√©ricas\n    \n  \n\n  \n    üí† Deserto da Dispers√£o\n    \n      üî¢ Tabela de Dispers√£o\n      üí• Tratamento de Colis√£o\n      üåÄ Tabela de Dispers√£o Din√¢mica\n    \n  \n\n  \n    üèîÔ∏è Montanha de Prioridades\n    \n      üì¶ Representa√ß√£o por Vetor\n      üèóÔ∏è Constru√ß√£o\n      üß± Estrutura Heap e Algoritmo HeapSort\n    \n   \n\n  \n    üï∏Ô∏è Labirinto dos Grafos\n    \n      üîó Introdu√ß√£o a Grafos\n      üö∂ Busca em Largura e Profundidade\n      üó∫Ô∏è Caminho M√≠nimo"
  },
  {
    "objectID": "disciplinas/aed2/academic/unidade2/2-callback.html",
    "href": "disciplinas/aed2/academic/unidade2/2-callback.html",
    "title": "Callbacks",
    "section": "",
    "text": "Nossa jornada pelos ponteiros ainda n√£o acabou. Nesta unidade vamos estudar o uso de ponteiros com fun√ß√µes. Isso mesmo, uma fun√ß√£o tamb√©m possui um endere√ßo de mem√≥ria. Poderemos chamar fun√ß√µes indiretamente e passar fun√ß√µes como param√™tros para outras fun√ß√µes.",
    "crumbs": [
      "Callbacks"
    ]
  },
  {
    "objectID": "disciplinas/aed2/academic/unidade2/2-callback.html#sec-fun",
    "href": "disciplinas/aed2/academic/unidade2/2-callback.html#sec-fun",
    "title": "Callbacks",
    "section": "Ponteiros de Fun√ß√µes",
    "text": "Ponteiros de Fun√ß√µes\nUm ponteiro tamb√©m pode armazenar o endere√ßo de uma fun√ß√£o. O racioc√≠nio √© o mesmo de antes, mas a sintaxe para a declara√ß√£o √© mais espec√≠fica, pois ela precisa descrever a assinatura completa da fun√ß√£o: seu tipo de retorno e seus par√¢metros.\nA sintaxe de declara√ß√£o pode parecer confusa no in√≠cio, mas pode ser lida assim:\ntipo_de_retorno (*nome_do_ponteiro)(tipos_de_parametros);\nVamos tomar a fun√ß√£o media como exemplo. Ela recebe dois valores e retorna a m√©dia aritm√©tica deles.\ndouble media (double n1, double n2){\n  return (n1 + n2)/2;\n}\n\n// Declara√ß√£o de um ponteiro de fun√ß√£o:\ndouble (*media_ptr)(double, double) = media;\nA sintaxe de declara√ß√£o do ponteiro media_prt deve ser lida da seguinte forma:\n\ndouble: √© o tipo de retorno;\n(*media_ptr): indica que media_ptr √© um ponteiro para fun√ß√£o. Os par√™nteses s√£o obrigat√≥rios para diferenci√°-lo de uma fun√ß√£o que retorna um ponteiro;\n(double, double): s√£o os tipos dos par√¢metros da fun√ß√£o apontada.\n\n\n\n\n\n\n\nNota\n\n\n\nDiferentemente das vari√°veis, ao atribuir o endere√ßo de uma fun√ß√£o a um ponteiro de fun√ß√£o, n√£o √© necess√°rio usar o operador & (o nome da fun√ß√£o sozinho j√° representa seu endere√ßo).\n\n\nNote que a fun√ß√£o media obedece a assinatura (ou contrato) estabelecido pelo ponteiro de fun√ß√£o media_ptr, ou seja, possui o mesmo tipo de retorno e os mesmos tipos de par√¢metros de entrada (double, double). Portanto, devemos manter a compatibilidade de tipos, como fizemos com as vari√°veis na se√ß√£o anterior.",
    "crumbs": [
      "Callbacks"
    ]
  },
  {
    "objectID": "disciplinas/aed2/academic/unidade2/2-callback.html#sec-cal",
    "href": "disciplinas/aed2/academic/unidade2/2-callback.html#sec-cal",
    "title": "Callbacks",
    "section": "Introdu√ß√£o aos Callbacks",
    "text": "Introdu√ß√£o aos Callbacks\nO verdadeiro poder dos ponteiros de fun√ß√£o aparece quando uma fun√ß√£o √© passada como argumento para outra. Nesse caso, a fun√ß√£o que recebe outra fun√ß√£o √© chamada de fun√ß√£o de ordem superior, enquanto a fun√ß√£o fornecida como argumento √© chamada de callback.\nEssa t√©cnica permite que um trecho de c√≥digo delegue parte de seu comportamento a outro, tornando o programa mais flex√≠vel, modular e param√©trico.\nAbaixo, um exemplo de uma calculadora de inteiros, onde calcular √© uma fun√ß√£o de ordem superior, pois recebe outra fun√ß√£o como par√¢metro. As fun√ß√µes soma, subtracao, produto e divisao s√£o callbacks, pois s√£o passadas para calcular.\n\n\ncalculadora_param.c\n\n#include &lt;stdio.h&gt;\n\n// Fun√ß√µes concretas (implementam comportamentos espec√≠ficos)\nint soma (int a, int b)     { return a + b; }\nint subtracao (int a, int b){ return a - b; }\nint produto (int a, int b)  { return a * b; }\nint divisao (int a, int b)  { return a / b; }\n\n// Fun√ß√£o coordenadora (de ordem superior)\n// Recebe duas vari√°veis e um ponteior de fun√ß√£o como par√¢metros\nint calcular(int a, int b, int (*operacao)(int, int)) {\n  return operacao(a, b);\n}\n\nint main(){\n\n  int n1 = 10;\n  int n2 = 2;\n  \n  printf(\"Soma:      %d\\n\", calcular(n1, n2, soma));\n  printf(\"Subtra√ß√£o: %d\\n\", calcular(n1, n2, subtracao));\n  printf(\"Produto:   %d\\n\", calcular(n1, n2, produto));\n  printf(\"Divis√£o:   %d\\n\", calcular(n1, n2, divisao));  \n  \n  return 0;\n}\n\n\n\nSe liga! A fun√ß√£o calcular n√£o sabe qual opera√ß√£o ser√° executada, ela apenas invoca o comportamento recebido como par√¢metro. Isso √© o que chamamos de abstra√ß√£o de comportamento.\nA sa√≠da desse programa ser√°\n  Soma:      12\n  Subtra√ß√£o: 8\n  Produto:   20\n  Divis√£o:   5 \nAo passar a fun√ß√£o como par√¢metro, tornamos o c√≥digo de C extremamente poderoso e reutiliz√°vel. A fun√ß√£o calcular n√£o se importa como o c√°lculo √© feito, apenas que a fun√ß√£o fornecida (o callback) respeite o contrato de tipos (int para retorno, e int, int para par√¢metros).\nPodemos ir al√©m nessa reutiliza√ß√£o? Sim, mas atingimos o limite do polimorfismo simples em C. Imagine que voc√™ queira adicionar uma opera√ß√£o com n√∫meros de ponto flutuante:\ndouble somad (double a, double b) { return a + b; }\nO problema √© que n√£o podemos passar somad para a fun√ß√£o calcular e nem a usar para operar com double, pois o callback int (*operacao)(int, int) e os par√¢metros fixos em calcular(int a, int b, ...) tornam essa fun√ß√£o totalmente incompat√≠vel com o tipo double.\nPara resolver esse problema e criar uma √∫nica fun√ß√£o verdadeiramente gen√©rica que aceite qualquer tipo de dado, precisamos abandonar os tipos concretos (int, double) e generalizar usando o ponteiro sem tipo (void*).\nAntes de darmos o salto para o c√≥digo verdadeiramente gen√©rico usando void*, vamos usar o typedef para melhorar a legibilidade de nosso c√≥digo.\nA sintaxe de um ponteiro de fun√ß√£o (por exemplo, int (*operacao)(int, int)) pode dificultar a leitura do c√≥digo, principalmente como argumentos de fun√ß√£o. O typedef permite que voc√™ crie um apelido para essa assinatura complexa, tratando-a como um novo tipo de dado simples.\nAo definir o tipo do callback, tornamos a fun√ß√£o calcular muito mais limpa:\n// Definimos 'Operacao' como o tipo para qualquer fun√ß√£o\n// que retorna int e aceita dois int como par√¢metros.\ntypedef int (*Operacao)(int, int);\n\n// A fun√ß√£o 'calcular' agora usa o tipo 'Operacao', \n// simplificando sua assinatura.\nint calcular(int a, int b, Operacao operacao); \nO c√≥digo final ficaria assim:\n\n\ncalculadora_typedef.c\n\n#include &lt;stdio.h&gt;\n\n// Defini√ß√£o do TIPO de ponteiro de fun√ß√£o\ntypedef int (*Operacao)(int, int);\n\n// Fun√ß√µes concretas (omitidas para brevidade)\nint soma (int a, int b) { return a + b; }\n// ...\n\n// A Fun√ß√£o Coordenadora agora √© mais leg√≠vel\nint calcular(int a, int b, Operacao operacao) {\n  return operacao(a, b);\n}\n\nint main(){\n\n  int n1 = 10;\n  int n2 = 2;\n  \n  printf(\"Soma: %d\\n\", calcular(n1, n2, soma));\n  \n  return 0;\n}\n\n\n\nSe liga! Com typedef, ganhamos mais clareza no c√≥digo. A fun√ß√£o calcular se torna muito mais limpa e leg√≠vel.\nCom essa abrodardagem, ganhamos:\n\nReutiliza√ß√£o: A fun√ß√£o calcular √© reutilizada para todas as opera√ß√µes.\nF√°cil extens√£o: Para adicionar uma nova opera√ß√£o, basta criar a fun√ß√£o e pass√°-la para calcular. N√£o precisamos de blocos if/else ou switch dentro de calcular.\nBaixo acoplamento: calcular n√£o precisa saber como a opera√ß√£o √© feita (se √© soma ou subtra√ß√£o), apenas que a fun√ß√£o passada segue o contrato definido pelo tipo Operacao.\n\nDessa maneira, calcular se comporta de v√°rias formas (polimorfismo).",
    "crumbs": [
      "Callbacks"
    ]
  },
  {
    "objectID": "disciplinas/aed2/academic/unidade2/2-callback.html#sec-gen",
    "href": "disciplinas/aed2/academic/unidade2/2-callback.html#sec-gen",
    "title": "Callbacks",
    "section": "Ponteiro gen√©rico",
    "text": "Ponteiro gen√©rico\nAgora que compreendemos o funcionamento dos ponteiros, passagem por refer√™ncia e callbacks, podemos dar um passo al√©m. Vamos estudar um m√©todo para representar qualquer tipo de dado.\nEm C, o tipo void * √© conhecido como ponteiro gen√©rico (generic pointer). Ele √© um tipo especial de ponteiro que pode armazenar o endere√ßo de qualquer tipo de dado, por exemplo int, double, char, struct etc.\nint idade = 20;\ndouble meta = 8.5;\nchar letra = 'A';\n\nvoid *ptr;\n\nptr = &idade;\nprintf(\"idade: %d\\n\", *(int *)ptr);\n\nptr = &meta;\nprintf(\"meta: %.2f\\n\", *(double *)ptr);\n\nptr = &letra;\nprintf(\"letra: %c\\n\", *(char *)ptr);\n\n\nSe liga! N√£o podemos desreferenciar diretamente um ponteiro void * , pois o compilador n√£o sabe quantos bytes ele deve ler. Devemos sempre fazer um cast (convers√£o) do void * para o tipo espec√≠fico de ponteiro que desejamos, antes de poder us√°-lo.\nRepare que, embora ptr sempre seja do tipo void *, precisamos fazer um cast (convers√£o expl√≠cita) para o tipo correto antes de acessar o valor. Isso ocorre porque o compilador n√£o sabe qual √© o tipo real do dado armazenado e, portanto, n√£o pode fazer aritm√©tica de ponteiros nem desreferencia√ß√£o direta.\nEssa caracter√≠stica √© o que permite criar estruturas de dados gen√©ricas em C, como listas, pilhas ou filas capazes de armazenar qualquer tipo. Essas estruturas ir√£o guardar apenas endere√ßos gen√©ricos (void *) e n√£o se importar com o tipo concreto do dado. A responsabilidade de interpretar corretamente o tipo ser√° de quem usar a estrutura.",
    "crumbs": [
      "Callbacks"
    ]
  },
  {
    "objectID": "disciplinas/aed2/academic/unidade2/2-callback.html#sec-siz",
    "href": "disciplinas/aed2/academic/unidade2/2-callback.html#sec-siz",
    "title": "Callbacks",
    "section": "O papel de size_t",
    "text": "O papel de size_t\nAo manipular dados de tipos diferentes, precisamos tamb√©m saber quanto de mem√≥ria reservar ou copiar. √â a√≠ que entra o tipo size_t, definido no cabe√ßalho &lt;stddef.h&gt; (ou implicitamente inclu√≠do via &lt;stdlib.h&gt; ou &lt;stdio.h&gt;).\nComo um tipo num√©rico sem sinal (unsigned), size_t √© usado para representar tamanhos e quantidades de bytes. Ele √© o tipo de retorno de fun√ß√µes como sizeof, malloc, calloc e strlen.\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main() {\n    int x = 10;\n    double y = 3.14;\n\n    printf(\"sizeof(int)   : %zu bytes\\n\", sizeof(int));\n    printf(\"sizeof(double): %zu bytes\\n\", sizeof(double));\n\n    void *ptr = malloc(sizeof(double));\n    printf(\"Alocado %zu bytes em %p\\n\", sizeof(double), ptr);\n\n    free(ptr);\n    return 0;\n}\n\n\nSe liga!\n\nz √© um modificador de comprimento que especifica que o argumento √© do tipo size_t\nu √© o c√≥digo de convers√£o para inteiro decimal sem sinal (unsigned).\n\nSa√≠da t√≠pica:\nsizeof(int)   : 4 bytes\nsizeof(double): 8 bytes\nAlocado 8 bytes em 0x7ffee1\nA combina√ß√£o de void * e size_t √© fundamental para criar estruturas gen√©ricas, pois usaremos void * para representar o dado, independentemente de tipo e size_t para indicar o tamanho desse dado, permitindo c√≥pia, aloca√ß√£o e manipula√ß√£o seguras.\nFalta pouco para criarmos nossas estruturas gen√©ricas com comportamentos tamb√©m gen√©ricos. Por√©m, ainda precisamos pontuar algumas quest√µes sobre o gerenciamento de mem√≥ria.",
    "crumbs": [
      "Callbacks"
    ]
  },
  {
    "objectID": "disciplinas/aed2/academic/unidade2/1-ponteiros.html",
    "href": "disciplinas/aed2/academic/unidade2/1-ponteiros.html",
    "title": "Ponteiros (Revis√£o)",
    "section": "",
    "text": "Por muito tempo, construir estruturas de dados, como listas e √°rvores, exigia que os desenvolvedores as reescrevessem para cada tipo de dado. Era uma batalha constante: uma lista para n√∫meros inteiros, outra para textos, outra para dados de usu√°rios, e assim por diante. Essa repeti√ß√£o n√£o apenas consumia tempo, mas tamb√©m abria portas para erros e inconsist√™ncias.\nA ideia de estruturas gen√©ricas √© poder construir estruturas universais que podem ser aplicadas em qualquer projeto. Embora a linguagem C n√£o tenha suporte nativo a ‚Äúgen√©ricos‚Äù, como C++ ou Java, a solu√ß√£o tradicional e elegante √© usar ponteiros void* e fun√ß√µes de callback.\nAntes de explorarmos essas estruturas, √© fundamental revisar e aprofundar dois conceitos cruciais: ponteiros e ponteiros de fun√ß√£o.\nComo voc√™ deve ter visto em Algoritmos e Estruturas de Dados 1, um ponteiro √© uma vari√°vel que armazena o endere√ßo de mem√≥ria de outra vari√°vel. Essa capacidade √© a base para criar estruturas de dados com tamanho din√¢mico (que crescem ou diminuem em tempo de execu√ß√£o).",
    "crumbs": [
      "Ponteiros (Revis√£o)"
    ]
  },
  {
    "objectID": "disciplinas/aed2/academic/unidade2/1-ponteiros.html#sec-dec",
    "href": "disciplinas/aed2/academic/unidade2/1-ponteiros.html#sec-dec",
    "title": "Ponteiros (Revis√£o)",
    "section": "Declara√ß√£o",
    "text": "Declara√ß√£o\nQuando declaramos uma vari√°vel e atribu√≠mos um valor, esse valor √© armazenado em um endere√ßo de mem√≥ria. Quando escrevemos int x = 10;, ocorrem dois passos conceituais:\n\nDeclara√ß√£o: o programa reserva um espa√ßo na mem√≥ria para armazenar um inteiro.\nAtribui√ß√£o: o valor 10 √© gravado nesse espa√ßo de mem√≥ria, que possui um endere√ßo.\n\nA vari√°vel x √© apenas um r√≥tulo usado pelo programador.\n\n\nIlustra√ß√£o da mem√≥ria para uma vari√°vel do tipo int\n\n\nVari√°vel\nEndere√ßo\nConte√∫do\n\n\n\n\nx\n0x75\n10\n\n\n\n\n\n\nSe liga! A mem√≥ria em si √© ilustrada pelo endere√ßo e conte√∫do armazenado. A vari√°vel √© apenas um r√≥tulo que representa este par.\nO princ√≠pio b√°sico de um ponteiro √© a compatibilidade de tipo, ou seja, um ponteiro deve ser do mesmo tipo do dado que ele aponta.\ndouble meta = 7.5;\ndouble *meta_ptr = &meta; // O operador & retorna o endere√ßo na mem√≥ria\nNa linha 2, meta_ptr guarda o endere√ßo da vari√°vel meta.\nO quadro abaixo ilustra a mem√≥ria depois das declara√ß√µes do trecho de c√≥digo anterior.\n\n\nIlustra√ß√£o da mem√≥ria para um ponteiro\n\n\nVari√°vel\nEndere√ßo\nConte√∫do\n\n\n\n\nmeta\n0x55\n7.5\n\n\nmeta_ptr\n0x58\n0x55\n\n\n\n\nEstamos usando endere√ßos fict√≠cios. Note que meta_ptr guarda o endere√ßo de meta. Neste caso, dizemos que meta_ptr aponta para meta.\nVamos explorar outro exemplo usando um diagrama que ilustra uma mem√≥ria.\n\n\n\n\n\nflowchart RL\n    %% N√≥s de vari√°veis e ponteiros\n    X[\"üì¶ &lt;b&gt;x&lt;/b&gt;&lt;br/&gt;Endere√ßo: &lt;code&gt;0x100&lt;/code&gt;&lt;br/&gt;Conte√∫do: &lt;b&gt;42&lt;/b&gt;\"]\n    Y[\"üì¶ &lt;b&gt;y&lt;/b&gt;&lt;br/&gt;Endere√ßo: &lt;code&gt;0x200&lt;/code&gt;&lt;br/&gt;Conte√∫do: &lt;b&gt;137&lt;/b&gt;\"]\n    P[\"üéØ &lt;b&gt;p&lt;/b&gt;&lt;br/&gt;Endere√ßo: &lt;code&gt;0x300&lt;/code&gt;&lt;br/&gt;Conte√∫do: &lt;code&gt;0x100&lt;/code&gt;\"]\n    PP[\"üéØ &lt;b&gt;pp&lt;/b&gt;&lt;br/&gt;Endere√ßo: &lt;code&gt;0x400&lt;/code&gt;&lt;br/&gt;Conte√∫do: &lt;code&gt;0x300&lt;/code&gt;\"]\n\n    %% Conex√µes\n    PP --&gt;|\"aponta para\"| P\n    P --&gt;|\"aponta para\"| X\n    P ~~~ Y\n    Y ~~~ X\n\n    %% Estilos de formata√ß√£o\n    classDef var fill:#A8E6CF,stroke:#2E7D32,color:#000,stroke-width:1px;\n    classDef ptr fill:#FFD3B6,stroke:#E65100,color:#000,stroke-width:1px;\n    class X,Y var\n    class P,PP ptr\n\n\n\n\n\n\n\n\nSe liga! Cada quadro √© um bloco de mem√≥ria que possui um endere√ßo e um valor. Os ponteiros est√£o em laranja.\nAs vari√°veis x e y carregam dados que est√£o armazenados nos endere√ßos 0x100 e 0x200, respectivamente. A vari√°vel p √© um ponteiro cujo conte√∫do √© 0x100, portanto aponta para x. A vari√°vel pp √© outro ponteiro, mas com conte√∫do 0x300, ou seja, aponta para o local com endere√ßo 0x300, que seria p. Isso mesmo que voc√™ pensou, um ponteiro de ponteiro. O c√≥digo que representa esse diagrama pode ser o seguinte.\nint x = 42;\nint y = 137;\nint *p = &x;\nint **pp = &p;\nResumindo\n\nx ‚Üí cont√©m 42 e est√° no endere√ßo 0x100;\ny ‚Üí cont√©m 137 e est√° no endere√ßo 0x200;\np ‚Üí cont√©m 0x100 (o endere√ßo de x);\npp ‚Üí cont√©m 0x300 (o endere√ßo de p).\n\nVale salientar que h√° tr√™s declara√ß√µes de ponteiros ligeiramente diferentes:\ndouble *meta_ptr = &meta;\ndouble* meta_ptr = &meta;\ndouble * meta_ptr = &meta;\n\n\nSe liga! Essas declara√ß√µes dizem respeito ao local do s√≠mbolo *.\nNo entanto, a primeira √© mais recomendada: tipo *ponteiro = &variavel.",
    "crumbs": [
      "Ponteiros (Revis√£o)"
    ]
  },
  {
    "objectID": "disciplinas/aed2/academic/unidade2/1-ponteiros.html#sec-des",
    "href": "disciplinas/aed2/academic/unidade2/1-ponteiros.html#sec-des",
    "title": "Ponteiros (Revis√£o)",
    "section": "Desreferencia√ß√£o",
    "text": "Desreferencia√ß√£o\nUma opera√ß√£o importante com ponteiros √© a desreferencia√ß√£o (ou dereferencing). Ela ocorre quando acessamos o conte√∫do armazenado no endere√ßo que o ponteiro aponta. Por exemplo,\ndouble meta = 7.5;\ndouble *meta_ptr = &meta; // O operador & retorna o endere√ßo na mem√≥ria\nprintf(\"*meta_ptr: %.2f\\n\", *meta_ptr); // *meta_ptr: 7.50\nNa segunda linha, criamos um ponteiro que aponta para meta. Na linha 3, o operador * serve para desreferenciar, ou seja, ao usar *meta_ptr na impress√£o, o C acessa o valor armazenado no endere√ßo que meta_ptr aponta (7.5).\n\n\n\n\n\n\nDica\n\n\n\nO * tem dupla fun√ß√£o:\n\nDeclarar um ponteiro (double *p)\nDesreferenciar um ponteiro (*p)\n\n\n\n\n\nSe liga! Os operadores * e & se anulam, ou seja, *&p ou &*p √© o mesmo que p.\n√â v√°lido mencionar que, em uma vari√°vel que guarda um dado, podemos acessar o dado e o endere√ßo. J√° em um ponteiro, podemos acessar seu endere√ßo, o conte√∫do (outro endere√ßo) e o dado armazenado pela vari√°vel que ele aponta:\nint idade = 12;\nint *idade_ptr = &idade;\n\nprintf(\"idade: %d\\n\", idade);\nprintf(\"&idade: %x\\n\", &idade);\n\nprintf(\"&idade_ptr: %x\\n\", &idade_ptr); // Endere√ßo do ponteiro\nprintf(\"idade_ptr: %x\\n\", idade_ptr);   // Endere√ßo de idade\nprintf(\"*idade_ptr: %d\\n\", *idade_ptr); // Conte√∫do de idade\nAl√©m de ler o conte√∫do de uma vari√°vel, tamb√©m podemos modific√°-lo indiretamente usando ponteiros:\ndouble meta = 7.5;\ndouble *meta_ptr = &meta; \n\n*meta_ptr = 10;\nprintf(\"meta: %.2f\\n\", meta); // meta: 10.00\nMudamos o valor de meta sem acess√°-la diretamente. Isso √© o poder dos ponteiros!\n\n\n\n\n\n\nNotaüéØ Desafio de C√≥digo\n\n\n\n\nCrie um ponteiro p que aponte para uma vari√°vel x = 5.\nUse o ponteiro para alterar x para 42.\nDepois, exiba o valor e o endere√ßo de x no console.\n\n\n\n\n\n\n\n\n\nDicaSolu√ß√£o (clique para ver)\n\n\n\n\n\n#include &lt;stdio.h&gt; \n\nint main(){\n    int x = 5;   \n    int *p = &x; // Ponteiro apontando para x (ambos do mesmo tipo)\n    *p = 42;     // Modifica√ß√£o indireta\n\n    printf(\"x: %d\\n\", x);\n    printf(\"&x: %p\\n\", &x);\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\nNotaüéØ Desafio de C√≥digo\n\n\n\n\nPasso 1: Declare um ponteiro ponteiro_chave que aponte para a chave_secreta.\nPasso 2: Mude o valor da chave_secreta para 99 usando o ponteiro.\nPasso 3: Imprima o valor da chave secreta.\n\n#include &lt;stdio.h&gt;\n\nint main() {\n    int chave_secreta = 10;\n    // SEU C√ìDIGO\n\n    return 0;\n}\n\n\n\n\n\n\n\n\nDicaSolu√ß√£o (clique para ver)\n\n\n\n\n\n#include &lt;stdio.h&gt; \n\nint main() {\n    int chave_secreta = 10;\n    int *ponteiro_chave = &chave_secreta;\n    *ponteiro_chave = 99;\n\n    printf(\"chave_secreta: %d\\n\", chave_secreta);\n    return 0;\n}",
    "crumbs": [
      "Ponteiros (Revis√£o)"
    ]
  },
  {
    "objectID": "disciplinas/aed2/academic/unidade2/1-ponteiros.html#sec-par",
    "href": "disciplinas/aed2/academic/unidade2/1-ponteiros.html#sec-par",
    "title": "Ponteiros (Revis√£o)",
    "section": "Ponteiros como par√¢metros",
    "text": "Ponteiros como par√¢metros\nEm C, os par√¢metros s√£o passados por valor. Portanto, a fun√ß√£o recebe uma c√≥pia do argumento.\nvoid dobrar_meta (double meta){ \n    meta = 2*meta; \n}\nNa main:\ndouble meta = 7.5;\nprintf(\"meta: %.2f\\n\", meta);\ndobrar_meta(meta);\nprintf(\"meta: %.2f\\n\", meta);\nSa√≠da:\nmeta: 7.50\nmeta: 7.50\nEsperav√°mos que no exemplo acima, o valor de meta tivesse sido dobrado, mas nada mudou. A raz√£o √© que a fun√ß√£o alterou apenas a c√≥pia local. A vari√°vel meta na fun√ß√£o main √© global, j√° na fun√ß√£o dobrar_meta √© local. Significa que quando esta fun√ß√£o termina, as vari√°veis s√£o descartadas.1\n1¬†Se voc√™ declarar uma vari√°vel local com o mesmo nome de uma vari√°vel global, a vari√°vel local prevalece dentro do seu escopo, ocultando temporariamente a global.Imprimindo os endere√ßos, vamos constatar que trata-se de vari√°veis diferentes.\nvoid dobrar_meta (double meta){ \n    printf(\"local &meta: %x\\n\", &meta);\n    meta = 2*meta; \n}\nNa main:\ndouble meta = 7.5;\nprintf(\"main &meta: %x\\n\", &meta);\ndobrar_meta(meta);\nSa√≠da:\nmain &meta: 0xe8\nlocal &meta: 0xc0\nOs endere√ßos s√£o diferentes. Logo, n√£o s√£o as mesmas vari√°veis que estamos manipulando\nA vari√°vel interna em dobrar_meta √© criada em outra regi√£o de mem√≥ria e recebe uma c√≥pia do valor passado como argumento. Esse valor √© dobrado em seguida, mas n√£o reflete na vari√°vel da fun√ß√£o main, pois ela est√° alocada em outra posi√ß√£o.\n\n\n\n\n\nflowchart LR\n subgraph s1[\" \"]\n        X[\"üì¶ &lt;b&gt;meta&lt;/b&gt;&lt;br&gt;Endere√ßo: &lt;code&gt;0xe8&lt;/code&gt;&lt;br&gt;Conte√∫do: &lt;b&gt;7.5&lt;/b&gt;\"]\n        Y[\"üì¶ &lt;b&gt;meta&lt;/b&gt;&lt;br&gt;Endere√ßo: &lt;code&gt;0xc0&lt;/code&gt;&lt;br&gt;Conte√∫do: &lt;b&gt;7.5&lt;/b&gt;\"]\n  end\n\n subgraph s2[\" \"]\n        A[\"üì¶ &lt;b&gt;meta&lt;/b&gt;&lt;br&gt;Endere√ßo: &lt;code&gt;0xe8&lt;/code&gt;&lt;br&gt;Conte√∫do: &lt;b&gt;7.5&lt;/b&gt;\"]\n        B[\"üì¶ &lt;b&gt;meta&lt;/b&gt;&lt;br&gt;Endere√ßo: &lt;code&gt;0xc0&lt;/code&gt;&lt;br&gt;Conte√∫do: &lt;b&gt;15&lt;/b&gt;\"]\n  end\n\n    s1 --dobrar_meta--&gt; s2\n    \n     X:::var\n     Y:::var\n     A:::var\n     B:::var\n    classDef var fill:#A8E6CF,stroke:#2E7D32,color:#000,stroke-width:1px\n    style s1 fill:transparent\n    style s2 fill:transparent\n\n\n\n\n\n\n\nPara solucionar isso, ao inv√©s de passarmos o conte√∫do armazenado, podemos passar o endere√ßo. Isso √© conhecido como passagem por refer√™ncia. Na verdade, ainda ser√° feita uma c√≥pia do valor passado, mas como esse valor copiado √© um endere√ßo (o ponteiro), esse artif√≠cio ser√° suficiente para manipularmos os dados originais.\n#include &lt;stdio.h&gt;\n\nvoid dobrar_meta (double *meta){ \n    *meta = 2*(*meta); // Desreferencia√ß√£o \n}\n\nint main (){\n    double meta = 7.5;\n    \n    printf(\"meta: %.2f\\n\", meta);\n    dobrar_meta(&meta); // Passando o endere√ßo\n    printf(\"meta: %.2f\\n\", meta);\n\n    return 0;\n}\nSa√≠da:\nmeta: 7.50\nmeta: 15.00\nDessa vez, a fun√ß√£o modificou a vari√°vel original, pois passamos a refer√™ncia. Vamos ilustrar como isso aconteceu.\n\n\n\n\nVari√°vel\nEndere√ßo\nConte√∫do\n\n\n\n\nmain meta\n0xe8\n7.5\n\n\nlocal meta\n0xc0\n0xe8\n\n\n\n\nDentro da fun√ß√£o, quando fazemos *meta, o C faz a desreferencia√ß√£o, ou seja, retorna o conte√∫do do local cujo o endere√ßo √© 0xe8. Neste local, a opera√ß√£o de dobrar √© efetuada.\n\n\n\n\nVari√°vel\nEndere√ßo\nConte√∫do\n\n\n\n\nmain meta\n0xe8\n15\n\n\nlocal meta\n0xc0\n0xe8\n\n\n\n\nAo finalizar, a vari√°vel meta da fun√ß√£o main sofreu a altera√ß√£o.\n\n\n\n\n\nflowchart LR\n subgraph s1[\" \"]\n        X[\"üì¶ &lt;b&gt;meta&lt;/b&gt;&lt;br&gt;Endere√ßo: &lt;code&gt;0xe8&lt;/code&gt;&lt;br&gt;Conte√∫do: &lt;b&gt;7.5&lt;/b&gt;\"]\n        Y[\"üéØ &lt;b&gt;meta&lt;/b&gt;&lt;br&gt;Endere√ßo: &lt;code&gt;0xc0&lt;/code&gt;&lt;br&gt;Conte√∫do: &lt;b&gt;0xe8&lt;/b&gt;\"]\n  end\n subgraph s2[\" \"]\n        A[\"üì¶ &lt;b&gt;meta&lt;/b&gt;&lt;br&gt;Endere√ßo: &lt;code&gt;0xe8&lt;/code&gt;&lt;br&gt;Conte√∫do: &lt;b&gt;15&lt;/b&gt;\"]\n        B[\"üéØ &lt;b&gt;meta&lt;/b&gt;&lt;br&gt;Endere√ßo: &lt;code&gt;0xc0&lt;/code&gt;&lt;br&gt;Conte√∫do: &lt;b&gt;0xe8&lt;/b&gt;\"]\n  end\n    s1 -- dobrar_meta --&gt; s2\n\n     X:::var\n     Y:::ptr\n     A:::var\n     B:::ptr\n    classDef var fill:#A8E6CF,stroke:#2E7D32,color:#000,stroke-width:1px\n    classDef ptr fill:#FFD3B6,stroke:#E65100,color:#000,stroke-width:1px;\n    style s1 fill:transparent\n    style s2 fill:transparent\n\n\n\n\n\n\n\n\n\n\n\n\nImportante\n\n\n\nQuando passamos o endere√ßo (&meta) para a fun√ß√£o dobrar_meta, a vari√°vel meta interna vai armazenar em seu conte√∫do um endere√ßo de mem√≥ria. Ou seja, ela √© um ponteiro e, portanto, podemos desreferenciar. Por exemplo, considere as seguintes assinaturas de fun√ß√µes:\nvoid foo(int a);\nvoid bar(int* a);\nQuando fazemos foo(x), internamente √© feita uma c√≥pia do valor de x, ou seja, √© criado int a = x. Do mesmo modo, quando fazemos bar(&x), ent√£o √© criado int *a = &x. Se usarmos os mesmos nomes, o C consegue diferenciar a vari√°vel da fun√ß√£o da que vem como argumento.\n\n\n\n\n\n\n\n\nNotaüéØ Desafio de C√≥digo\n\n\n\nImplemente uma fun√ß√£o swap que troque os valores de duas vari√°veis. Teste na main com:\nint x = 10, y = 20;\nswap(&x, &y);\nprintf(\"x = %d, y = %d\\n\", x, y);\nSa√≠da esperada: x = 20, y = 10\n\n\n\n\n\n\n\n\nDicaSolu√ß√£o (clique para ver)\n\n\n\n\n\n#include &lt;stdio.h&gt; \n\nvoid swap(int *a, int *b){\n    int aux = *a;\n    a* = *b;\n    b* = aux;\n}\n\nint main(){\n    int x = 10, y = 20;\n    swap(&x, &y);\n    printf(\"x = %d, y = %d\\n\", x, y);\n\n    return 0;\n}\n\n\n\nNesta unidade, voc√™ aprendeu\n‚úÖ a declarar e desreferenciar ponteiros\n‚úÖ a modificar valores via ponteiros\n‚úÖ a passar vari√°veis por refer√™ncia\n\n\n\n\n\n\nDica\n\n\n\nSe voc√™ quiser aprofundar mais seu conhecimento sobre ponteiros, revise materiais sobre ponteiros para structs, aritm√©tica de ponteiros, ponteiros para strings e a rela√ß√£o entre arrays e ponteiros.",
    "crumbs": [
      "Ponteiros (Revis√£o)"
    ]
  },
  {
    "objectID": "disciplinas/algoritmos/index.html",
    "href": "disciplinas/algoritmos/index.html",
    "title": "Algoritmos",
    "section": "",
    "text": "Bem-vindo ao portal de REA sobre Algoritmos. Aqui voc√™ encontrar√° informa√ß√µes sobre a bibliografia, aulas ministradas e muito mais.\nEM CONSTRU√á√ÇO\n\n\n\n De volta ao topo"
  },
  {
    "objectID": "disciplinas/aed1/index.html",
    "href": "disciplinas/aed1/index.html",
    "title": "Algoritmos e Estruturas de Dados 1",
    "section": "",
    "text": "Bem-vindo ao portal de REA sobre Algoritmos e Estruturas de Dados 1. Aqui voc√™ encontrar√° informa√ß√µes sobre a bibliografia, aulas ministradas e muito mais.\nEM CONSTRU√á√ÇO\n\n\n\n De volta ao topo"
  },
  {
    "objectID": "contribuicao.html",
    "href": "contribuicao.html",
    "title": "Participe",
    "section": "",
    "text": "Nosso projeto de Recursos Educacionais Abertos (REA) √© colaborativo e est√° sempre aberto √† participa√ß√£o da comunidade. Se voc√™ √© estudante, docente ou profissional da √°rea de Computa√ß√£o e deseja contribuir com melhorias nos materiais ‚Äî como corre√ß√µes, atualiza√ß√µes, novos exemplos ou conte√∫dos complementares ‚Äî sua colabora√ß√£o ser√° muito bem-vinda!\nTodo o c√≥digo-fonte e os materiais deste portal est√£o dispon√≠veis em um reposit√≥rio p√∫blico no GitHub. Para contribuir, siga os passos abaixo:\nSe voc√™ identificar erros ou quiser apenas deixar sugest√µes, tamb√©m pode abrir uma issue diretamente no reposit√≥rio."
  },
  {
    "objectID": "contribuicao.html#como-posso-contribuir",
    "href": "contribuicao.html#como-posso-contribuir",
    "title": "Participe",
    "section": "Como posso contribuir?",
    "text": "Como posso contribuir?\n\nCorrigindo erros nos materiais (ortografia, l√≥gica, c√≥digo, etc.);\nSugerindo novos exerc√≠cios ou conte√∫dos;\nAdicionando recursos complementares (v√≠deos, slides, links √∫teis);\nSinalizando pontos que precisam de mais clareza ou revis√£o.\n\n\nTodo o conte√∫do aceito ser√° publicado sob uma licen√ßa aberta (Creative Commons), garantindo a reutiliza√ß√£o e o compartilhamento livre, com os devidos cr√©ditos √†s contribui√ß√µes.\nJunte-se a n√≥s nessa constru√ß√£o coletiva de conhecimento!"
  },
  {
    "objectID": "disciplinas.html",
    "href": "disciplinas.html",
    "title": "Recursos",
    "section": "",
    "text": "Explore nossos materiais sobre Algoritmos, Programa√ß√£o em C e Estruturas de Dados.\n\n\n\n\nAlgoritmos\n\n\n\n\n\nPrograma√ß√£o em C\n\n\n\n\n\nEstruturas de Dados I\n\n\n\n\n\nEstruturas de Dados II\n\n\n\n\nClique em uma op√ß√£o para come√ßar!\n\n\n\n Back to top"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Sobre",
    "section": "",
    "text": "Este portal re√∫ne Recursos Educacionais Abertos (REA) desenvolvidos para apoiar o ensino e a aprendizagem em Computa√ß√£o no campus da UFERSA em Pau dos Ferros. A iniciativa tem como foco tr√™s √°reas fundamentais da forma√ß√£o em Computa√ß√£o: Algoritmos, Programa√ß√£o e Estruturas de Dados.\nTodo o conte√∫do disponibilizado aqui √© aberto, gratuito e pode ser reutilizado, adaptado e compartilhado conforme as necessidades de estudantes, docentes e demais interessados. O objetivo √© promover o acesso democr√°tico ao conhecimento, estimular a autonomia no aprendizado e fortalecer a educa√ß√£o p√∫blica de qualidade.\nEste projeto faz parte do compromisso da UFERSA com a inova√ß√£o pedag√≥gica, a inclus√£o digital e a promo√ß√£o da ci√™ncia aberta.\n\n\n\n De volta ao topo"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Recursos Educacionais Abertos",
    "section": "",
    "text": "O movimento de Recursos Educacionais Abertos (REA) √© impulsionado pela internet e plataformas digitais, buscando tornar o conhecimento mais acess√≠vel. Eles permitem que terceiros os utilizem, adaptem e distribuam livremente, promovendo o acesso universal √† educa√ß√£o.\nA Universidade Federal Rural do Semi-√Årido (Ufersa) oferece REA atrav√©s da sua Biblioteca Digital de Recursos Educacionais Abertos (BDREA), um reposit√≥rio que disponibiliza materiais did√°ticos sob licen√ßas abertas e em dom√≠nio p√∫blico para uso e adapta√ß√£o por terceiros. Estes materiais incluem textos, imagens e outras ferramentas que visam promover o acesso gratuito e apropria√ß√£o do conhecimento.\nEste portal oferece REA na √°rea da computa√ß√£o e serve como recurso extra no processo de ensino-aprendizagem em algoritmos, programa√ß√£o e estruturas de dados.\n\n\n\n De volta ao topo"
  },
  {
    "objectID": "disciplinas/programacaoc/index.html",
    "href": "disciplinas/programacaoc/index.html",
    "title": "Programa√ß√£o em C",
    "section": "",
    "text": "Bem-vindo ao portal de REA sobre Programa√ß√£o em C. Aqui voc√™ encontrar√° informa√ß√µes sobre a bibliografia, aulas ministradas e muito mais.\nEM CONSTRU√á√ÇO\n\n\n\n De volta ao topo"
  },
  {
    "objectID": "disciplinas/aed2/academic/index.html",
    "href": "disciplinas/aed2/academic/index.html",
    "title": "Algoritmos e Estruturas de Dados 2",
    "section": "",
    "text": "Esta √© a vers√£o mais pr√≥xima do estilo acad√™mica de estudos em Algoritmos e Estruturas de Dados 2. O portal est√° organizado conforme o conte√∫do abaixo.\n\n\n\n\n√Årvores\n\n\n\n\n\nEstruturas Gen√©ricas\n\n\n\n\n\nTabela de Dispers√£o\n\n\n\n\n\nLista de Prioridade\n\n\n\n\n\nGrafos\n\n\n\n\n\n\n De volta ao topo"
  },
  {
    "objectID": "disciplinas/aed2/academic/unidade2/3-memoria.html",
    "href": "disciplinas/aed2/academic/unidade2/3-memoria.html",
    "title": "Gerenciamento da Mem√≥ria",
    "section": "",
    "text": "Trocar Tema\nAt√© aqui, vimos como generalizar dados e comportamentos em C usando ponteiros e callbacks. No entanto, toda essa flexibilidade traz a responsabilidade de gerenciar manualmente a mem√≥ria.\nNesta se√ß√£o, vamos entender como a linguagem C lida com a aloca√ß√£o din√¢mica, isto √©, a capacidade de reservar e liberar mem√≥ria em tempo de execu√ß√£o. Mais importante, veremos como evitar os erros de mem√≥ria mais comuns que podem comprometer a estabilidade e a seguran√ßa de um programa."
  },
  {
    "objectID": "disciplinas/aed2/academic/unidade2/3-memoria.html#sec-alo",
    "href": "disciplinas/aed2/academic/unidade2/3-memoria.html#sec-alo",
    "title": "Gerenciamento da Mem√≥ria",
    "section": "Aloca√ß√£o e libera√ß√£o din√¢mica",
    "text": "Aloca√ß√£o e libera√ß√£o din√¢mica\nQuando trabalhamos com arrays ou estruturas em C, geralmente definimos seus tamanhos em tempo de compila√ß√£o. Eles ficam armazenados em uma √°rea de mem√≥ria chamada stack.\nNo entanto, h√° muitos casos em que o tamanho dos dados n√£o √© conhecido antecipadamente. Para esses casos, o C fornece fun√ß√µes de aloca√ß√£o din√¢mica de mem√≥ria, que permitem reservar e liberar espa√ßo em tempo de execu√ß√£o. Esses blocos de mem√≥ria s√£o criados em uma regi√£o especial chamada heap.\nDizemos que a mem√≥ria stack √© est√°tica, enquanto que a heap √© din√¢mica. Na stack, quando a fun√ß√£o termina, a vari√°vel √© destru√≠da. J√° na heap, o programador decide quando alocar e liberar.\nA aloca√ß√£o din√¢mica oferece flexibilidade, mas tamb√©m exige disciplina. O princ√≠pio fundamental √©: quem aloca, deve liberar.\n\nAloca√ß√£o simples\nA fun√ß√£o malloc (de memory allocation) reserva um bloco cont√≠nuo de mem√≥ria de tamanho especificado em bytes.\nint *v = malloc(5 * sizeof(int));\nO argumento √© o n√∫mero total de bytes a serem alocados. No trecho acima, estamos alocando o espa√ßo suficiente para cinco inteiros. O retorno √© um ponteiro gen√©rico (void*) para o in√≠cio do bloco. Caso a aloca√ß√£o falhe, malloc retorna NULL.\n\n\n\n\n\n\nNota\n\n\n\nEm C, ao contr√°rio de C++, n√£o h√° necessidade de fazer o cast do ponteiro gen√©rico.\n\n\nComo n√£o temos garantia que a mem√≥ria foi alocada, precisamos tratar quando malloc falha. Isso √© geramente feito com um bloco if.\nint *v = malloc(5 * sizeof(int));\n    \nif (v == NULL) {\n    fprintf(stderr, \"Erro: sem mem√≥ria suficiente!\\n\");\n    return 1;\n}       \nNo trecho acima, poder√≠amos ter usado printf ao inv√©s de fprintf. A escolha, por fprintf se d√° por ser o padr√£o para erros. Ele permite especificar exatamente para onde a sa√≠da deve ir. Ao usarmos stderr (de standard error), estamos dizendo ao sistema que esta mensagem √© um erro e deve ser tratada como tal.\nQuando usamos printf a sa√≠da √© armazenada em buffer, portanto a mensagem de erro poderia ficar presa e nunca ser exibida antes do programa abortar. J√° quando optamos por fprintf, a sa√≠da √© unbuffered, ou seja, √© exibida imediatamente no terminal.\nResumindo, use fprinf mensagens de erro, diagn√≥stico e logs cr√≠ticos e use printf para mensagens de sucesso, resultado da aplica√ß√£o e sa√≠da esperada.\nO return 1 informa ao sistema operacional que algo deu errado .\n\n\nAloca√ß√£o e inicializa√ß√£o\nA fun√ß√£o calloc (de contiguous allocation) funciona como malloc, mas com duas diferen√ßas:\n\nRecebe dois par√¢metros, n√∫mero de elementos e tamanho de cada um;\nInicializa o bloco com zeros.\n\nint *v = calloc(5, sizeof(int));\nAssim, todo o vetor come√ßa zerado, o que evita leituras de lixo de mem√≥ria.\n\n\nRedimensionamento de bloco\nA fun√ß√£o realloc permite ajustar o tamanho de um bloco de mem√≥ria j√° alocado.\nint *novo = realloc(v, 10 * sizeof(int));\nSe houver espa√ßo cont√≠guo suficiente, o bloco √© expandido no mesmo local. Caso contr√°rio, um novo bloco √© alocado e o conte√∫do antigo √© copiado automaticamente. Em caso de falha, retorna NULL e n√£o desaloca o bloco de mem√≥ria original. Por isso, √© recomendado sempre usar um ponteiro tempor√°rio:\nint *temp = realloc(v, 10 * sizeof(int));\nif (temp == NULL) {\n    fprintf(stderr, \"Erro ao realocar mem√≥ria!\\n\");\n    return 1;\n}\nv = temp; // Atualiza o ponteiro com seguran√ßa\n\n\nLibera√ß√£o de mem√≥ria\nA fun√ß√£o free libera um bloco previamente alocado com malloc, calloc ou realloc. Ela devolve o espa√ßo ao sistema operacional, mas n√£o zera o ponteiro.\nfree(v);\nv = NULL; // Boa pr√°tica\n\n\n\n\n\n\nImportante\n\n\n\nAp√≥s liberar, o ponteiro ainda guarda o endere√ßo antigo, agora inv√°lido. Atribuir NULL ajuda a evitar o uso acidental, um erro cl√°ssico conhecido como dangling pointer.\n\n\nEste ciclo √© a base de toda manipula√ß√£o segura de mem√≥ria din√¢mica em C:\n\n\n\n\n\nflowchart LR\n    A(\"Alocar\") --&gt; B(\"Usar\")\n    B --&gt; C(\"Liberar\")  \n    C --&gt; D(\"Invalidar\")\n    D --&gt; A\n\n\n\n\n\n\n\nAlocar (malloc, calloc ou realloc)\nUsar (ler e escrever por meio do ponteiro)\nLiberar (free)\nInvalidar o ponteiro (ptr = NULL)\n\nCom essas fun√ß√µes, temos total controle sobre a vida √∫til de cada dado em mem√≥ria. No entanto, esse poder vem acompanhado de riscos: acessos indevidos, vazamentos e corrup√ß√£o de mem√≥ria s√£o erros comuns quando o ciclo de aloca√ß√£o n√£o √© seguido corretamente.\nNa pr√≥xima se√ß√£o, vamos explorar as fun√ß√µes de manipula√ß√£o de blocos de mem√≥ria e entender como oper√°-las com seguran√ßa antes de mergulhar nos erros cl√°ssicos de mem√≥ria."
  },
  {
    "objectID": "disciplinas/aed2/academic/unidade2/3-memoria.html#sec-man",
    "href": "disciplinas/aed2/academic/unidade2/3-memoria.html#sec-man",
    "title": "Gerenciamento da Mem√≥ria",
    "section": "Manipula√ß√£o de blocos de mem√≥ria",
    "text": "Manipula√ß√£o de blocos de mem√≥ria\nQuando trabalhamos com aloca√ß√£o din√¢mica, frequentemente precisamos copiar dados de uma regi√£o de mem√≥ria para outra. O C oferece um conjunto de fun√ß√µes na biblioteca &lt;string.h&gt; para manipular blocos de mem√≥ria de forma gen√©rica, usando ponteiros do tipo void*.\nEssas fun√ß√µes operam diretamente em bytes, e n√£o conhecem o tipo de dado armazenado. Por isso, exigem aten√ß√£o com o tamanho dos blocos manipulados (geralmente expresso com size_t).\nAs tr√™s fun√ß√µes principais para manipula√ß√£o de blocos de mem√≥ria s√£o:\n\nmemcpy: copia bytes de uma origem para um destino\nmemmove: copia bytes com seguran√ßa mesmo se houver sobreposi√ß√£o\nmemset: preenche uma √°rea de mem√≥ria com um valor constante\n\n\nCopiando blocos de mem√≥ria\nA fun√ß√£o memcpy copia \\(n\\) bytes do bloco apontado por src (origem) para o bloco apontado por dest (destino).\nvoid *memcpy(void *dest, const void *src, size_t n);\nExemplo pr√°tico:\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main() {\n    int origem[5] = {1, 2, 3, 4, 5};\n    int destino[5];\n\n    memcpy(destino, origem, 5 * sizeof(int));\n\n    for (int i = 0; i &lt; 5; i++)\n        printf(\"%d \", destino[i]);\n    \n    return 0;\n}\nSa√≠da:\n1 2 3 4 5\n\n\n\n\n\n\nImportante\n\n\n\nA fun√ß√£o memcpy n√£o deve ser usada quando as regi√µes de origem e destino se sobrep√µem. O comportamento √© indefinido, podendo corromper os dados.\n\n\n\n\nC√≥pia segura com sobreposi√ß√£o\nA fun√ß√£o memmove √© semelhante a memcpy, mas trata corretamente casos de sobreposi√ß√£o. Se o bloco de destino estiver dentro da √°rea de origem (ou vice-versa), ela ajusta a dire√ß√£o da c√≥pia automaticamente.\nvoid *memmove(void *dest, const void *src, size_t n);\nExemplo:\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main() {\n    char texto[20] = \"ABCDEF\";\n\n    // Copiando parte sobreposta\n    memmove(texto + 2, texto, 4);\n    texto[6] = '\\0';\n\n    printf(\"%s\\n\", texto); // Resultado: \"ABABCD\"\n    return 0;\n}\nSe tiv√©ssemos usado memcpy nesse exemplo, o conte√∫do de texto poderia ser corrompido, pois as regi√µes texto e texto + 2 se sobrep√µem.\n\n\nInicializando mem√≥ria\nA fun√ß√£o memset preenche um bloco de mem√≥ria com um valor constante em bytes. Ela √© muito usada para inicializar buffers ou zerar estruturas.\nvoid *memset(void *ptr, int valor, size_t n);\nExemplo:\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main() {\n    int v[5];\n    memset(v, 0, 5 * sizeof(int));\n\n    for (int i = 0; i &lt; 5; i++)\n        printf(\"%d \", v[i]);\n    \n    return 0;\n}\nSa√≠da:\n0 0 0 0 0\n\n\n\n\n\n\nImportante\n\n\n\nO valor passado a memset √© interpretado como um byte, e n√£o como um inteiro completo. Por exemplo, memset(v, 1, sizeof(int)*5) preencher√° todos os bytes com 0x01, n√£o com o inteiro 1."
  },
  {
    "objectID": "disciplinas/aed2/academic/unidade2/3-memoria.html#sec-cui",
    "href": "disciplinas/aed2/academic/unidade2/3-memoria.html#sec-cui",
    "title": "Gerenciamento da Mem√≥ria",
    "section": "Cuidados e boas pr√°ticas",
    "text": "Cuidados e boas pr√°ticas\n\nSempre use sizeof para calcular o n√∫mero correto de bytes.\n\nEvite express√µes m√°gicas como memcpy(dest, src, 20).\nUse memcpy(dest, src, n * sizeof(T)).\n\nPrefira memmove quando houver d√∫vida sobre sobreposi√ß√£o.\nZere estruturas antes de us√°-las (por exemplo, buffers de strings).\nEvite manipular mem√≥ria de tipos complexos (estruturas com ponteiros internos) com memcpy\n\nIsso pode quebrar o encapsulamento e gerar c√≥pias superficiais perigosas.\n\n\nCom essas fun√ß√µes, temos ferramentas poderosas para manipular diretamente a mem√≥ria. Isso √© um recurso essencial para implementar estruturas gen√©ricas e opera√ß√µes de baixo n√≠vel. Entretanto, o uso incorreto dessas fun√ß√µes √© uma das principais causas de erros sutis e dif√≠ceis de depurar em C.\nNa pr√≥xima se√ß√£o, estudaremos exatamente esses erros, os erros cl√°ssicos de mem√≥ria, como dangling pointers, buffer overflow e double free, e como evit√°-los com boas pr√°ticas.\n\nErros cl√°ssicos de mem√≥ria\nGerenciar mem√≥ria manualmente √© uma das maiores responsabilidades (e riscos) ao programar em C. Ao lidar com ponteiros e aloca√ß√£o din√¢mica, pequenos descuidos podem causar comportamentos indefinidos, travamentos ou at√© falhas de seguran√ßa.\nNesta se√ß√£o, veremos os erros mais comuns, seus sintomas e como evit√°-los.\n\nPonteiros n√£o inicializados (wild pointers)\nUm wild pointer √© um ponteiro que n√£o foi inicializado antes do uso. Ele cont√©m um valor de endere√ßo aleat√≥rio, podendo apontar para qualquer lugar da mem√≥ria.\n#include &lt;stdio.h&gt;\n\nint main() {\n    int *p;       // n√£o inicializado!\n    *p = 42;      // comportamento indefinido!\n    printf(\"%d\\n\", *p);\n    return 0;\n}\n\n\n\n\n\n\nCuidado\n\n\n\nEsse c√≥digo pode travar o programa (segmentation fault), corromper dados ou at√© ‚Äúfuncionar‚Äù, mascarando o erro (o pior cen√°rio).\n\n\nComo boa pr√°tica, sempre inicialize ponteiros:\nint *p = NULL;\n\n\nPonteiros pendentes (dangling pointers)\nUm dangling pointer ocorre quando o ponteiro ainda referencia uma regi√£o de mem√≥ria j√° liberada.\n#include &lt;stdlib.h&gt;\n\nint main() {\n    int *p = malloc(sizeof(int));\n    *p = 10;\n    free(p);\n    printf(\"%d\\n\", *p); // uso ap√≥s libera√ß√£o ‚Äî ERRO\n    return 0;\n}\n\n\n\n\n\n\nCuidado\n\n\n\nO bloco de mem√≥ria foi liberado, mas o ponteiro ainda ‚Äúacha‚Äù que √© v√°lido. Acessar ou modificar essa regi√£o causa comportamento indefinido.\n\n\nComo boa pr√°tica, ap√≥s free(p), defina p = NULL; para evitar acessos acidentais.\n\n\nVazamentos de mem√≥ria (memory leaks)\nUm memory leak acontece quando um programa perde a refer√™ncia para uma regi√£o de mem√≥ria alocada, sem cham√°-la com free().\n#include &lt;stdlib.h&gt;\n\nint main() {\n    int *p = malloc(100 * sizeof(int));\n    p = NULL;  // perdemos a refer√™ncia ‚Äî vazamento!\n    return 0;\n}\n\n\n\n\n\n\nCuidado\n\n\n\nA mem√≥ria continua alocada, mas inacess√≠vel. Em programas longos, isso pode acumular e exaurir a mem√≥ria do sistema.\n\n\nComo boas pr√°tica, sempre emparelhe malloc e free. Em fun√ß√µes complexas, adote o princ√≠pio ‚Äúquem aloca, libera‚Äù.\n\n\nLibera√ß√£o duplicada (double free)\nUm double free ocorre quando tentamos liberar o mesmo bloco de mem√≥ria mais de uma vez.\n#include &lt;stdlib.h&gt;\n\nint main() {\n    int *p = malloc(sizeof(int));\n    free(p);\n    free(p); // ERRO: double free\n    return 0;\n}\n\n\n\n\n\n\nCuidado\n\n\n\nIsso causa corrup√ß√£o da estrutura interna do heap e frequentemente resulta em segmentation fault.\n\n\nComo boa pr√°tica, ap√≥s liberar, defina p = NULL.\n\n\nAcesso fora dos limites (buffer overflow e underrun)\nUm buffer overflow ocorre quando se escreve al√©m do final (ou antes do in√≠cio) de um bloco de mem√≥ria.\n#include &lt;stdio.h&gt;\n\nint main() {\n    int v[3] = {1, 2, 3};\n    v[3] = 99; // √≠ndice inv√°lido ‚Äî overflow\n    printf(\"%d\\n\", v[3]); // comportamento indefinido\n    return 0;\n}\n\n\n\n\n\n\nCuidado\n\n\n\nEsse tipo de erro √© grave: pode corromper vari√°veis adjacentes, causar travamentos ou vulnerabilidades de seguran√ßa (explora√ß√£o de stack overflow).\n\n\nComo boas pr√°tica, sempre verifique limites de vetores. Al√©m disso, prefira fun√ß√µes seguras (ex: strncpy no lugar de strcpy). Ao usar malloc, garanta que o tamanho esteja correto com sizeof.\nPodemos resumir os tipos de erros abordados por meio da seguinte tabela.\n\n\n\n\n\n\n\n\n\nTipo de Erro\nCausa\nSintoma\nPreven√ß√£o\n\n\n\n\nWild Pointer\nPonteiro n√£o inicializado\nCrash aleat√≥rio\nInicializar com NULL\n\n\nDangling Pointer\nUso ap√≥s free\nSegmentation fault\np = NULL ap√≥s free\n\n\nMemory Leak\nPerda de refer√™ncia\nAumento de uso de mem√≥ria\nSempre liberar\n\n\nDouble Free\nLibera√ß√£o repetida\nCorrup√ß√£o do heap\nControle de ownership\n\n\nBuffer Overflow\nEscrita fora dos limites\nCorrup√ß√£o de mem√≥ria\nVerificar limites\n\n\n\nErros de mem√≥ria est√£o entre os mais sutis e perigosos em C. Eles n√£o apenas causam falhas, mas podem introduzir vulnerabilidades de seguran√ßa s√©rias. Com boas pr√°ticas e ferramentas adequadas, √© poss√≠vel evit√°-los e desenvolver sistemas robustos e confi√°veis."
  },
  {
    "objectID": "disciplinas/aed2/academic/unidade2/3-memoria.html#sec-boa",
    "href": "disciplinas/aed2/academic/unidade2/3-memoria.html#sec-boa",
    "title": "Gerenciamento da Mem√≥ria",
    "section": "Boas pr√°ticas e padr√µes",
    "text": "Boas pr√°ticas e padr√µes\nGerenciar mem√≥ria em C exige disciplina. A responsabilidade √© totalmente do programador, pois o compilador n√£o faz verifica√ß√µes autom√°ticas. A seguir, apresentamos um conjunto de princ√≠pios e padr√µes que ajudam a escrever c√≥digo seguro, previs√≠vel e f√°cil de manter.\n\nInicializa√ß√£o defensiva\nSempre inicialize ponteiros, mesmo quando voc√™ ainda n√£o sabe qual endere√ßo eles ter√£o.\nint *p = NULL;\nEssa pr√°tica evita comportamentos indefinidos quando o ponteiro √© usado antes de ser atribu√≠do. Ela tamb√©m facilita verifica√ß√µes de seguran√ßa:\nif (p != NULL) {\n    *p = 42;\n}\n\n\n\n\n\n\nDica\n\n\n\nUm ponteiro deve sempre apontar para algo v√°lido, ou para NULL.\n\n\n\n\nO princ√≠pio da propriedade (ownership)\nEm programas maiores, √© comum que uma fun√ß√£o aloca mem√≥ria e outra a utilize. Para evitar vazamentos ou libera√ß√µes incorretas, defina quem √© o dono (owner) de cada bloco alocado.\nüî∏ Quem aloca √© respons√°vel por liberar.\nExemplo:\nchar* criar_mensagem() {\n    char *msg = malloc(50);\n    sprintf(msg, \"Ol√°, mundo!\");\n    return msg;  // a fun√ß√£o devolve a posse\n}\n\nint main() {\n    char *m = criar_mensagem();\n    puts(m);\n    free(m);     // responsabilidade de quem recebeu\n}\n\n\nPar malloc e free\nCada chamada de aloca√ß√£o din√¢mica deve ter uma contrapartida de libera√ß√£o. Evite fluxos de execu√ß√£o que impe√ßam o free de ser chamado.\nchar *p = malloc(100);\nif (!p) return;   // erro de aloca√ß√£o\n// ...\nfree(p);\n\n\n\n\n\n\nDica\n\n\n\nCentralize libera√ß√µes num √∫nico ponto de sa√≠da, especialmente em fun√ß√µes longas.\n\n\n\n\nEvite opera√ß√µes parciais\nNunca tente liberar apenas parte de uma estrutura alocada. Sempre opere sobre a mesma refer√™ncia retornada por malloc.\nint *v = malloc(10 * sizeof(int));\nint *p = v + 5;\nfree(p); // ‚ùå comportamento indefinido\nfree(v); // ‚úÖ correto\n\n\nZerar mem√≥ria ap√≥s libera√ß√£o (quando necess√°rio)\nEm sistemas que lidam com dados sens√≠veis (como senhas), vale a pena limpar o conte√∫do antes de liberar.\nmemset(senha, 0, tamanho);\nfree(senha);\nIsso impede que dados fiquem acess√≠veis em regi√µes de mem√≥ria reaproveitadas.\n\n\nMacros e wrappers de seguran√ßa\nEm projetos grandes, √© comum encapsular chamadas de aloca√ß√£o/libera√ß√£o em fun√ß√µes auxiliares. Isso facilita rastrear erros e aplicar verifica√ß√µes centralizadas.\nvoid* safe_malloc(size_t n) {\n    void *p = malloc(n);\n    if (p == NULL) {\n        fprintf(stderr, \"Erro: malloc falhou\\n\");\n        exit(EXIT_FAILURE);\n    }\n    return p;\n}\nüîπ Com esse padr√£o, voc√™ garante que toda aloca√ß√£o seja verificada.\nGerenciar mem√≥ria em C √© uma arte de equil√≠brio entre controle total e responsabilidade absoluta. Com disciplina e padr√µes bem definidos, √© poss√≠vel construir sistemas robustos, perform√°ticos e seguros."
  },
  {
    "objectID": "disciplinas/aed2/index.html",
    "href": "disciplinas/aed2/index.html",
    "title": "Algoritmos e Estruturas de Dados 2",
    "section": "",
    "text": "Bem-vindo ao portal de REA sobre Algoritmos e Estruturas de Dados 2. Aqui voc√™ encontrar√° informa√ß√µes sobre a bibliografia, aulas ministradas e muito mais. Para iniciar ou continuar seus estudos, escolha uma das vers√µes dispon√≠veis abaixo.\nOs exerc√≠cios propostos est√£o divididos em tr√™s categorias:\nAl√©m disso, h√° um conjunto de exerc√≠cios interativos, onde voc√™ pode aprender de forma descontra√≠da o funcionamento das mais diversas estruturas como √°rvores, filas de prioridade, heaps, tabelas hash e grafos."
  },
  {
    "objectID": "disciplinas/aed2/index.html#bibliografia",
    "href": "disciplinas/aed2/index.html#bibliografia",
    "title": "Algoritmos e Estruturas de Dados 2",
    "section": "Bibliografia",
    "text": "Bibliografia\n\nRecomendada\n\n\nASCENCIO, A. F. G. Estrutura de Dados. S√£o Paulo: Pearson, 2011. 448 p.\n\nSZWARCFITER, J. L.; MARKENZON, L. Estruturas de Dados e Seus Algoritmos. 3¬™ ed.¬†Rio de Janeiro: LTC, 2010. 318 p.\n\nZIVIANI, N. Projeto de Algoritmos com Implementa√ß√µes em Java e C++. S√£o Paulo: Thomson Learning, 2006. 642 p.\n\n\n\nComplementar\nTOSCANI, L. V.; VELOSO, P. A. S. Complexidade de Algoritmos ‚Äì Vol. 13. 3¬™ ed.¬†Porto Alegre: Bookman, 2012. 280 p.¬†(S√©rie de livros did√°ticos em inform√°tica ‚Äì UFRGS).\nLOPES, A.; GARCIA, G. Introdu√ß√£o √† Programa√ß√£o. Rio de Janeiro: Campus, 2002. 488 p.\nDEITEL, P.; DEITEL, H. C: Como Programar. 6¬™ ed.¬†S√£o Paulo: Pearson, 2007. 848 p.\nTENENBAUM, A. M.; LANGSAM, Y.; AUGENSTEIN, M. J. Estruturas de Dados Usando C. S√£o Paulo: Makron Books, 1995. 904 p.\nMIZRAHI, V. V. Treinamento em Linguagem C. 2¬™ ed.¬†S√£o Paulo: Prentice-Hall, 2008. 432 p."
  },
  {
    "objectID": "disciplinas/aed2/gaming/unidade2/1-ponteiros.html",
    "href": "disciplinas/aed2/gaming/unidade2/1-ponteiros.html",
    "title": "üèùÔ∏è Ilha dos Ponteiros",
    "section": "",
    "text": "Sauda√ß√µes!\nInfelizmente, naufragamos na trai√ßoeira Ilha dos Ponteiros. Este lugar √© uma pris√£o natural, cheia de refer√™ncias complexas e caminhos que se perdem se n√£o forem gerenciados corretamente.\nJuntamente com Shell, usaremos nossas habilidades para escapar."
  },
  {
    "objectID": "disciplinas/aed2/gaming/unidade2/1-ponteiros.html#sec-dec",
    "href": "disciplinas/aed2/gaming/unidade2/1-ponteiros.html#sec-dec",
    "title": "üèùÔ∏è Ilha dos Ponteiros",
    "section": "Declara√ß√£o e Desreferencia√ß√£o",
    "text": "Declara√ß√£o e Desreferencia√ß√£o\nQuando declaramos uma vari√°vel e atribu√≠mos um valor, esse valor √© armazenado em um endere√ßo de mem√≥ria. Quando escrevemos int x = 10;, ocorrem dois passos conceituais:\n\nDeclara√ß√£o: o programa reserva um espa√ßo na mem√≥ria para armazenar um inteiro.\nAtribui√ß√£o: o valor 10 √© gravado nesse espa√ßo de mem√≥ria, que possui um endere√ßo.\n\nA vari√°vel x √© apenas um r√≥tulo usado pelo programador.\n\n\n\nVari√°vel\nEndere√ßo\nConte√∫do\n\n\n\n\nx\n0x75\n10\n\n\n\nUm ponteiro tamb√©m √© uma vari√°vel, mas sempre armazena o endere√ßo de mem√≥ria de outra vari√°vel. Essa habilidade √© essencial para criar estruturas de dados din√¢micas.\nO princ√≠pio b√°sico √© a compatibilidade de tipo, ou seja, um ponteiro deve ser do mesmo tipo do dado que ele aponta.\ndouble meta = 7.5;\ndouble *meta_ptr = &meta; // O operador & retorna o endere√ßo na mem√≥ria\nprintf(\"*meta_ptr: %.2f\\n\", *meta_ptr); // *meta_ptr: 7.50\nüí° Na linha 2, meta_ptr guarda o endere√ßo da vari√°vel meta. Na linha 3, o operador * serve para desreferenciar, isto √©, acessar o valor no endere√ßo armazenado.\nüßÆ Mem√≥ria ilustrada\n\n\n\nVari√°vel\nEndere√ßo\nConte√∫do\n\n\n\n\nmeta\n0x55\n7.5\n\n\nmeta_ptr\n0x58\n0x55\n\n\n\nEstamos usando endere√ßos fict√≠cios. Note que meta_ptr guarda o endere√ßo de meta. Ao usar *meta_ptr na impress√£o, o C acessa o valor armazenado nesse endere√ßo (7.5).\n\n\n\n\n\n\nDica‚ö° Dica do Mentor\n\n\n\nO * tem dupla fun√ß√£o:\n\nDeclarar um ponteiro (double *p)\nDesreferenciar um ponteiro (*p)\n\n\n\n\n\n\n\nPodemos ir um pouco devagar aqui, pois √© crucial entender como funciona esse mecanismo. Para isso, eu criei a seguinte ilustra√ß√£o.\n\n\n\n\n\n\n\n\nflowchart RL\n    %% N√≥s de vari√°veis e ponteiros\n    X[\"üì¶ &lt;b&gt;x&lt;/b&gt;&lt;br/&gt;Endere√ßo: &lt;code&gt;0x100&lt;/code&gt;&lt;br/&gt;Conte√∫do: &lt;b&gt;42&lt;/b&gt;\"]\n    Y[\"üì¶ &lt;b&gt;y&lt;/b&gt;&lt;br/&gt;Endere√ßo: &lt;code&gt;0x200&lt;/code&gt;&lt;br/&gt;Conte√∫do: &lt;b&gt;137&lt;/b&gt;\"]\n    P[\"üéØ &lt;b&gt;p&lt;/b&gt;&lt;br/&gt;Endere√ßo: &lt;code&gt;0x300&lt;/code&gt;&lt;br/&gt;Conte√∫do: &lt;code&gt;0x100&lt;/code&gt;\"]\n    PP[\"üéØ &lt;b&gt;pp&lt;/b&gt;&lt;br/&gt;Endere√ßo: &lt;code&gt;0x400&lt;/code&gt;&lt;br/&gt;Conte√∫do: &lt;code&gt;0x300&lt;/code&gt;\"]\n\n    %% Conex√µes\n    PP --&gt;|\"aponta para\"| P\n    P --&gt;|\"aponta para\"| X\n    P ~~~ Y\n    Y ~~~ X\n\n    %% Estilos de formata√ß√£o\n    classDef var fill:#A8E6CF,stroke:#2E7D32,color:#000,stroke-width:1px;\n    classDef ptr fill:#FFD3B6,stroke:#E65100,color:#000,stroke-width:1px;\n    class X,Y var\n    class P,PP ptr\n\n\n\n\n\n\nAs vari√°veis x e y carregam dados que est√£o armazenados nos endere√ßos 0x100 e 0x200, respectivamente. A vari√°vel p √© um ponteiro cujo conte√∫do √© 0x100, portanto aponta para x. A vari√°vel pp √© outro ponteiro, mas com conte√∫do 0x300, ou seja, aponta para o local com endere√ßo 0x300, que seria p. Isso mesmo um ponteiro de ponteiro. O c√≥digo que representa esse diagrama poder ser o seguinte.\nint x = 42;\nint y = 137;\nint *p = &x;\nint **pp = &p;\n\n\n\n\n\n\nResumindo\n\nx ‚Üí cont√©m 42 e est√° no endere√ßo 0x100;\ny ‚Üí cont√©m 137 e est√° no endere√ßo 0x200;\np ‚Üí cont√©m 0x100 (o endere√ßo de x);\npp ‚Üí cont√©m 0x300 (o endere√ßo de p).\n\n\n\n\nPodemos declarar ponteiros de v√°rias formas:\ndouble *meta_ptr = &meta;\ndouble* meta_ptr = &meta;\ndouble * meta_ptr = &meta;\nNo entanto, a primeira √© mais recomendada: tipo *ponteiro = &variavel.\n‚úÖ +5 XP : Voc√™ agora entende a sintaxe dos ponteiros!"
  },
  {
    "objectID": "disciplinas/aed2/gaming/unidade2/1-ponteiros.html#sec-mod",
    "href": "disciplinas/aed2/gaming/unidade2/1-ponteiros.html#sec-mod",
    "title": "üèùÔ∏è Ilha dos Ponteiros",
    "section": "Modificando Valores Indiretamente",
    "text": "Modificando Valores Indiretamente\nAl√©m de ler, voc√™ tamb√©m pode modificar valores indiretamente usando ponteiros:\ndouble meta = 7.5;\ndouble *meta_ptr = &meta; \n\n*meta_ptr = 10;\nprintf(\"meta: %.2f\\n\", meta); // meta: 10.00\n\n\n\n\nMudamos o valor de meta sem acess√°-la diretamente. Isso √© o poder dos ponteiros!\n\n\n\n\n\n\n\n\n\nNotaüéØ Desafio de C√≥digo\n\n\n\n\nCrie um ponteiro int *p que aponte para uma vari√°vel x = 5.\nUse *p para alterar x para 42.\nDepois, exiba o valor e o endere√ßo de x no console.\n\n\n\n\n\n\n\n\n\nDicaSolu√ß√£o (clique para ver)\n\n\n\n\n\n#include &lt;stdio.h&gt; \n\nint main(){\n    int x = 5;\n    int *p = &x;\n    *p = 42;\n\n    printf(\"x: %d\\n\", x);\n    printf(\"&x: %p\\n\", &x);\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\nNotaüéØ Desafio de C√≥digo\n\n\n\n\nPasso 1: Declare um ponteiro ponteiro_chave que aponte para a chave_secreta.\nPasso 2: Mude o valor da chave_secreta para 99 usando o ponteiro.\nPasso 3: Imprima o valor da chave secreta.\n\n#include &lt;stdio.h&gt;\n\nint main() {\n    int chave_secreta = 10;\n    // SEU C√ìDIGO\n\n    return 0;\n}\n\n\n\n\n\n\n\n\nDicaSolu√ß√£o (clique para ver)\n\n\n\n\n\n#include &lt;stdio.h&gt; \n\nint main() {\n    int chave_secreta = 10;\n    int *ponteiro_chave = &chave_secreta;\n    *ponteiro_chave = 99;\n\n    printf(\"chave_secreta: %d\\n\", chave_secreta);\n    return 0;\n}\n\n\n\nüèÖ +10 XP : Voc√™ dominou a manipula√ß√£o indireta de valores!"
  },
  {
    "objectID": "disciplinas/aed2/gaming/unidade2/1-ponteiros.html#sec-par",
    "href": "disciplinas/aed2/gaming/unidade2/1-ponteiros.html#sec-par",
    "title": "üèùÔ∏è Ilha dos Ponteiros",
    "section": "Ponteiros como Par√¢metros",
    "text": "Ponteiros como Par√¢metros\nAcredito que estamos perto de deixar esta ilha. Por enquanto, a situa√ß√£o est√° calma, mas n√£o podemos subestimar este local. Parece que encontramos algo que exige a nossa aten√ß√£o imetata.\nEm C, os par√¢metros s√£o passados por valor. Portanto, a fun√ß√£o recebe uma c√≥pia do argumento.\nvoid dobrar_meta (double meta){ \n    meta = 2*meta; \n}\nNa main:\ndouble meta = 7.5;\nprintf(\"meta: %.2f\\n\", meta);\ndobrar_meta(meta);\nprintf(\"meta: %.2f\\n\", meta);\nSa√≠da:\nmeta: 7.50\nmeta: 7.50\nNada mudou, pois a fun√ß√£o alterou apenas a c√≥pia local.\n\n\n\n\nA vari√°vel meta na fun√ß√£o main √© global, j√° na fun√ß√£o dobrar_meta √© local. Significa que quando esta fun√ß√£o termina, as vari√°veis s√£o descartadas.\n\n\n\nüí° Vamos imprimir os endere√ßos\nvoid dobrar_meta (double meta){ \n    printf(\"local &meta: %x\\n\", &meta);\n    meta = 2*meta; \n}\nNa main:\ndouble meta = 7.5;\nprintf(\"main &meta: %x\\n\", &meta);\ndobrar_meta(meta);\nSa√≠da:\nmain &meta: 0xe8\nlocal &meta: 0xc0\nüßÆ Mem√≥ria ilustrada\n\n\n\nVari√°vel\nEndere√ßo\nConte√∫do\n\n\n\n\nmain meta\n0xe8\n7.5\n\n\nlocal meta\n0xc0\n7.5\n\n\n\n\n\n\n\nComo eu suspeitava, os endere√ßos s√£o diferentes. Logo, n√£o s√£o as mesmas vari√°veis que estamos manipulando.\n\n\n\nA vari√°vel interna em dobrar_meta √© criada em outra regi√£o de mem√≥ria e recebe uma c√≥pia do valor passado como argumento. Esse valor √© dobrado em seguida, mas n√£o reflete na vari√°vel da fun√ß√£o main, pois ela est√° alocada em outro local.\n\n\n\n\n\nflowchart LR\n subgraph s1[\" \"]\n        X[\"üì¶ &lt;b&gt;meta&lt;/b&gt;&lt;br&gt;Endere√ßo: &lt;code&gt;0xe8&lt;/code&gt;&lt;br&gt;Conte√∫do: &lt;b&gt;7.5&lt;/b&gt;\"]\n        Y[\"üì¶ &lt;b&gt;meta&lt;/b&gt;&lt;br&gt;Endere√ßo: &lt;code&gt;0xc0&lt;/code&gt;&lt;br&gt;Conte√∫do: &lt;b&gt;7.5&lt;/b&gt;\"]\n  end\n\n subgraph s2[\" \"]\n        A[\"üì¶ &lt;b&gt;meta&lt;/b&gt;&lt;br&gt;Endere√ßo: &lt;code&gt;0xe8&lt;/code&gt;&lt;br&gt;Conte√∫do: &lt;b&gt;7.5&lt;/b&gt;\"]\n        B[\"üì¶ &lt;b&gt;meta&lt;/b&gt;&lt;br&gt;Endere√ßo: &lt;code&gt;0xc0&lt;/code&gt;&lt;br&gt;Conte√∫do: &lt;b&gt;15&lt;/b&gt;\"]\n  end\n\n    s1 --dobrar_meta--&gt; s2\n    \n     X:::var\n     Y:::var\n     A:::var\n     B:::var\n    classDef var fill:#A8E6CF,stroke:#2E7D32,color:#000,stroke-width:1px\n    style s1 fill:transparent\n    style s2 fill:transparent\n\n\n\n\n\n\n\n\n\n\n\nE se, ao inv√©s de passarmos o conte√∫do armazenado, a gente passar o endere√ßo ?\n\n\n\nShell, isso √© conhecido como passagem por refer√™ncia. Na verdade, ainda ser√° feita uma c√≥pia do valor passado, mas como esse valor copiado √© um endere√ßo (o ponteiro), esse artif√≠cio ser√° suficiente para manipularmos os dados originais.\n#include &lt;stdio.h&gt;\n\nvoid dobrar_meta (double *meta){ \n    *meta = 2*(*meta); // Desreferencia√ß√£o \n}\n\nint main (){\n    double meta = 7.5;\n    \n    printf(\"meta: %.2f\\n\", meta);\n    dobrar_meta(&meta); // Passando o endere√ßo\n    printf(\"meta: %.2f\\n\", meta);\n\n    return 0;\n}\nSa√≠da:\nmeta: 7.50\nmeta: 15.00\nüéâ Agora sim! A fun√ß√£o modificou a vari√°vel original, pois passamos a refer√™ncia.\n\n\n\n\nNossa! que m√°gica foi essa?\n\n\n\nüßÆ Mem√≥ria ilustrada\n\n\n\nVari√°vel\nEndere√ßo\nValor\n\n\n\n\nmain meta\n0xe8\n7.5\n\n\nlocal meta\n0xc0\n0xe8\n\n\n\nDentro da fun√ß√£o, quando fazemos *meta, o C vai na linha de endere√ßo com o valor de meta (0xe8). Neste local, ele efetua a opera√ß√£o de dobrar.\n\n\n\nVari√°vel\nEndere√ßo\nValor\n\n\n\n\nmain meta\n0xe8\n15\n\n\nlocal meta\n0xc0\n0xe8\n\n\n\nAo finalizar, a meta da fun√ß√£o main sofreu a altera√ß√£o.\n\n\n\n\n\nflowchart LR\n subgraph s1[\" \"]\n        X[\"üì¶ &lt;b&gt;meta&lt;/b&gt;&lt;br&gt;Endere√ßo: &lt;code&gt;0xe8&lt;/code&gt;&lt;br&gt;Conte√∫do: &lt;b&gt;7.5&lt;/b&gt;\"]\n        Y[\"üéØ &lt;b&gt;meta&lt;/b&gt;&lt;br&gt;Endere√ßo: &lt;code&gt;0xc0&lt;/code&gt;&lt;br&gt;Conte√∫do: &lt;b&gt;0xe8&lt;/b&gt;\"]\n  end\n subgraph s2[\" \"]\n        A[\"üì¶ &lt;b&gt;meta&lt;/b&gt;&lt;br&gt;Endere√ßo: &lt;code&gt;0xe8&lt;/code&gt;&lt;br&gt;Conte√∫do: &lt;b&gt;15&lt;/b&gt;\"]\n        B[\"üéØ &lt;b&gt;meta&lt;/b&gt;&lt;br&gt;Endere√ßo: &lt;code&gt;0xc0&lt;/code&gt;&lt;br&gt;Conte√∫do: &lt;b&gt;0xe8&lt;/b&gt;\"]\n  end\n    s1 -- dobrar_meta --&gt; s2\n\n     X:::var\n     Y:::ptr\n     A:::var\n     B:::ptr\n    classDef var fill:#A8E6CF,stroke:#2E7D32,color:#000,stroke-width:1px\n    classDef ptr fill:#FFD3B6,stroke:#E65100,color:#000,stroke-width:1px;\n    style s1 fill:transparent\n    style s2 fill:transparent\n\n\n\n\n\n\n\n\n\n\n\n\nNotaüéØ Desafio de C√≥digo\n\n\n\nImplemente uma fun√ß√£o swap que troque os valores de duas vari√°veis. Teste na main com:\nint x = 10, y = 20;\nswap(&x, &y);\nprintf(\"x = %d, y = %d\\n\", x, y);\nSa√≠da esperada: x = 20, y = 10\n\n\n\n\n\n\n\n\nDicaSolu√ß√£o (clique para ver)\n\n\n\n\n\n#include &lt;stdio.h&gt; \n\nvoid swap(int *a, int *b){\n    int aux = *a;\n    a* = *b;\n    b* = aux;\n}\n\nint main(){\n    int x = 10, y = 20;\n    swap(&x, &y);\n    printf(\"x = %d, y = %d\\n\", x, y);\n\n    return 0;\n}\n\n\n\nüéñÔ∏è +20 XP: Voc√™ aplicou a passagem por refer√™ncia\n\n\n\n\n\n\nCuidadoConquista Desbloqueada\n\n\n\n Manipulador de Ponteiros\n\n\n\n\n\n\n\n\nImportanteüèÜ Checkpoint\n\n\n\nVoc√™ aprendeu:\n‚úÖ A declarar e desreferenciar ponteiros\n‚úÖ A modificar valores via ponteiros\n‚úÖ A passar vari√°veis por refer√™ncia\nRecompensas:\nüèÖ +35 XP\nüí•T√≠tulo: Manipulador de Ponteiros\n\n\n\n\n\n\nIhuuu! conseguimos passar com √™xito por todos os desafios da ilha. Precisamos resgatar a Hashy no Deserto dos Callbacks.\n\n\n\n\n\n\n\n\n\n\nCuidadoüèÅ Fase Conclu√≠da!\n\n\n\nA palavra-chave para desbloquear a pr√≥xima fase √©:\nCHAVE: callback"
  },
  {
    "objectID": "disciplinas/aed2/gaming/unidade2/fundamentos.html",
    "href": "disciplinas/aed2/gaming/unidade2/fundamentos.html",
    "title": "Fundamentos e Ferramentas Gen√©ricas",
    "section": "",
    "text": "Nesta unidade do curso, iremos estudar as estruturas gen√©ricas. Imagine poder criar uma lista ou uma √°rvore que funciona com qualquer tipo de dado, sem precisar mudar uma √∫nica linha do c√≥digo principal. As estruturas gen√©ricas permitem criar c√≥digos flex√≠veis usando conceitos como listas gen√©ricas, o uso de callbacks para opera√ß√µes personalizadas, e a constru√ß√£o de √°rvores de busca gen√©ricas.\nAntes de tudo, precisamos preparar o terreno para que n√£o nenhuma ponta solta. Iniciaremos com um pequena revis√£o sobre ponteiros. Em seguida, introduzir os callbacks, seguido por gerenciamento de mem√≥ria."
  },
  {
    "objectID": "disciplinas/aed2/gaming/unidade2/fundamentos.html#sec-mapa",
    "href": "disciplinas/aed2/gaming/unidade2/fundamentos.html#sec-mapa",
    "title": "Fundamentos e Ferramentas Gen√©ricas",
    "section": "üó∫Ô∏è Mapa da Jornada",
    "text": "üó∫Ô∏è Mapa da Jornada\n\n\n\n\n\n\n\n\nDigite a palavra-chave para desbloquear uma fase:\n\n  \n\n\n\n\n\nAo completar desafios ou uma fase, voc√™ encontrar√° a palavra-chave para desbloquear a pr√≥xima.\nFique atento √†s nossas dicas!"
  }
]