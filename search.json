[
  {
    "objectID": "disciplinas/aed2/gaming/unidade2/2-callback.html",
    "href": "disciplinas/aed2/gaming/unidade2/2-callback.html",
    "title": "üèúÔ∏è Deserto dos Callbacks",
    "section": "",
    "text": "Voc√™ chegou ao Deserto dos Callbacks, uma terra √°rida onde apenas os programadores mais habilidosos conseguem sobreviver. Dizem que quem domina os ponteiros de fun√ß√£o e os callbacks pode invocar comportamentos gen√©ricos e controlar o fluxo da execu√ß√£o com maestria.\nPrepare-se, nossa miss√£o come√ßa agora."
  },
  {
    "objectID": "disciplinas/aed2/gaming/unidade2/2-callback.html#sec-fun",
    "href": "disciplinas/aed2/gaming/unidade2/2-callback.html#sec-fun",
    "title": "üèúÔ∏è Deserto dos Callbacks",
    "section": "O Mapa dos Endere√ßos",
    "text": "O Mapa dos Endere√ßos\nUm ponteiro tamb√©m pode armazenar o endere√ßo de uma fun√ß√£o. O racioc√≠nio √© o mesmo, mas a sintaxe para a declara√ß√£o √© mais espec√≠fica, pois ela precisa descrever a assinatura completa da fun√ß√£o: seu tipo de retorno e seus par√¢metros.\nA sintaxe de declara√ß√£o pode parecer confusa no in√≠cio, mas pode ser lida assim:\ntipo_de_retorno (*nome_do_ponteiro)(tipos_de_parametros);\nVamos tomar a fun√ß√£o meta como exemplo:\ndouble meta (double n1, double n2){\n  return (n1 + n2)/2;\n}\n\n// Declara√ß√£o de um ponteiro de fun√ß√£o:\ndouble (*meta_ptr)(double, double) = meta;\nA sintaxe de declara√ß√£o deve ser lida da seguinte forma:\n\ndouble: √© o tipo de retorno;\n(*meta_ptr): indica que meta_ptr √© um ponteiro para fun√ß√£o. Os par√™nteses s√£o obrigat√≥rios para diferenci√°-lo de uma fun√ß√£o que retorna um ponteiro;\n(double, double): s√£o os tipos dos par√¢metros da fun√ß√£o apontada.\n\n\n\n\n\n\n\nNota\n\n\n\nDiferentemente das vari√°veis, ao atribuir o endere√ßo de uma fun√ß√£o a um ponteiro de fun√ß√£o, n√£o √© necess√°rio usar o operador & (o nome da fun√ß√£o sozinho j√° representa seu endere√ßo).\n\n\nNote que a fun√ß√£o meta obedece a assinatura (ou contrato) estabelecido pelo ponteiro de fun√ß√£o meta_ptr, ou seja, possui o mesmo tipo de retorno e os mesmos tipos de par√¢metros de entrada (double, double) Portanto, devemos manter a compatibilidade de tipos."
  },
  {
    "objectID": "disciplinas/aed2/gaming/unidade2/2-callback.html#sec-cal",
    "href": "disciplinas/aed2/gaming/unidade2/2-callback.html#sec-cal",
    "title": "üèúÔ∏è Deserto dos Callbacks",
    "section": "Introdu√ß√£o aos Callbacks",
    "text": "Introdu√ß√£o aos Callbacks\nO verdadeiro poder dos ponteiros de fun√ß√£o aparece quando uma fun√ß√£o √© passada como argumento para outra. Nesse caso, a fun√ß√£o que recebe outra fun√ß√£o √© chamada de fun√ß√£o de ordem superior, enquanto a fun√ß√£o fornecida como argumento √© chamada de callback.\nEssa t√©cnica permite que um trecho de c√≥digo delegue parte de seu comportamento a outro, tornando o programa mais flex√≠vel, modular e param√©trico.\nAbaixo, um exemplo de uma calculadora de inteiros, onde calcular √© uma fun√ß√£o de ordem superior, pois recebe outra fun√ß√£o como par√¢metro. As fun√ß√µes soma, subtracao, produto e divisao s√£o callbacks, pois s√£o passadas para calcular para que ela decida qual comportamento executar.\n\n\ncalculadora_param.c\n\n#include &lt;stdio.h&gt;\n\n// Fun√ß√µes concretas (implementam comportamentos espec√≠ficos)\nint soma (int a, int b)     { return a + b; }\nint subtracao (int a, int b){ return a - b; }\nint produto (int a, int b)  { return a * b; }\nint divisao (int a, int b)  { return a / b; }\n\n// Fun√ß√£o coordenadora (de ordem superior)\n// Recebe duas vari√°veis e uma fun√ß√£o como par√¢metro\nint calcular(int a, int b, int (*operacao)(int, int)) {\n  return operacao(a, b);\n}\n\nint main(){\n\n  int n1 = 10;\n  int n2 = 2;\n  \n  printf(\"Soma:      %d\\n\", calcular(n1, n2, soma));\n  printf(\"Subtra√ß√£o: %d\\n\", calcular(n1, n2, subtracao));\n  printf(\"Produto:   %d\\n\", calcular(n1, n2, produto));\n  printf(\"Divis√£o:   %d\\n\", calcular(n1, n2, divisao));  \n  \n  return 0;\n}\n\nA fun√ß√£o calcular n√£o sabe qual opera√ß√£o ser√° executada, ela apenas invoca o comportamento recebido como par√¢metro. Isso √© o que chamamos de abstra√ß√£o de comportamento.\nA sa√≠da desse programa ser√°\n  Soma:      12\n  Subtra√ß√£o: 8\n  Produto:   20\n  Divis√£o:   5 \nAo passar a fun√ß√£o como par√¢metro, tornamos o c√≥digo de C extremamente poderoso e reutiliz√°vel. A fun√ß√£o calcular n√£o se importa como o c√°lculo √© feito, apenas que a fun√ß√£o fornecida (o callback) respeite o contrato de tipos (int para retorno, e int, int para par√¢metros).\nPodemos ir al√©m nessa reutiliza√ß√£o? Sim, mas atingimos o limite do polimorfismo simples em C. Imagine que voc√™ queira adicionar uma opera√ß√£o com n√∫meros de ponto flutuante:\ndouble somad (double a, double b) { return a + b; }\nO problema √© que n√£o podemos passar somad para a fun√ß√£o calcular e nem a usar para operar com double, pois o callback int (*operacao)(int, int) e os par√¢metros fixos em calcular(int a, int b, ...) tornam essa fun√ß√£o totalmente incompat√≠vel com o tipo double.\nPara resolver esse problema e criar uma √∫nica fun√ß√£o verdadeiramente gen√©rica que aceite qualquer tipo de dado, precisamos abandonar os tipos concretos (int, double) e generalizar usando o ponteiro sem tipo (void*).\nAntes de darmos o salto para o c√≥digo verdadeiramente gen√©rico usando void*, vamos usar o typedef para melhorar a legibilidade de nosso c√≥digo.\nA sintaxe de um ponteiro de fun√ß√£o (int (*operacao)(int, int)) √© complexa e pode dificultar a leitura do c√≥digo. O typedef permite que voc√™ crie um apelido para essa assinatura complexa, tratando-a como um novo tipo de dado simples.\nAo definir o tipo do callback, tornamos a fun√ß√£o calcular muito mais limpa:\n// Definimos 'Operacao' como o tipo para qualquer fun√ß√£o\n// que retorna int e aceita dois int como par√¢metros.\ntypedef int (*Operacao)(int, int);\n\n// A fun√ß√£o 'calcular' agora usa o tipo 'Operacao', \n// simplificando sua assinatura.\nint calcular(int a, int b, Operacao operacao); \nO c√≥digo final ficaria assim:\n\n\ncalculadora_typedef.c\n\n#include &lt;stdio.h&gt;\n\n// Defini√ß√£o do TIPO de ponteiro de fun√ß√£o\ntypedef int (*Operacao)(int, int);\n\n// Fun√ß√µes concretas (omitidas para brevidade)\nint soma (int a, int b) { return a + b; }\n// ...\n\n// A Fun√ß√£o Coordenadora agora √© mais leg√≠vel\nint calcular(int a, int b, Operacao operacao) {\n  return operacao(a, b);\n}\n\nint main(){\n\n  int n1 = 10;\n  int n2 = 2;\n  \n  printf(\"Soma: %d\\n\", calcular(n1, n2, soma));\n  \n  return 0;\n}"
  },
  {
    "objectID": "disciplinas/aed2/gaming/unidade2/2-callback.html#sec-gen",
    "href": "disciplinas/aed2/gaming/unidade2/2-callback.html#sec-gen",
    "title": "üèúÔ∏è Deserto dos Callbacks",
    "section": "Ponteiro gen√©rico",
    "text": "Ponteiro gen√©rico\nAgora que compreendemos o funcionamento dos ponteiros e a passagem por refer√™ncia, podemos dar um passo al√©m, como representar qualquer tipo de dado usando ponteiros gen√©ricos.\nEm C, o tipo void* √© conhecido como ponteiro gen√©rico (generic pointer). Ele √© um tipo especial de ponteiro que pode armazenar o endere√ßo de qualquer tipo de dado, por exemplo int, double, char, struct etc.\nint idade = 20;\ndouble meta = 8.5;\nchar letra = 'A';\n\nvoid *ptr;\n\nptr = &idade;\nprintf(\"idade: %d\\n\", *(int*)ptr);\n\nptr = &meta;\nprintf(\"meta: %.2f\\n\", *(double*)ptr);\n\nptr = &letra;\nprintf(\"letra: %c\\n\", *(char*)ptr);\nRepare que, embora ptr sempre seja do tipo void*, precisamos fazer um cast (convers√£o expl√≠cita) para o tipo correto antes de acessar o valor. Isso ocorre porque o compilador n√£o sabe qual √© o tipo real do dado armazenado e, portanto, n√£o pode fazer aritm√©tica de ponteiros nem desreferencia√ß√£o direta.\nEssa caracter√≠stica √© o que permite criar estruturas de dados gen√©ricas em C, como listas, pilhas ou filas capazes de armazenar qualquer tipo. Essas estruturas ir√£o guardar apenas endere√ßos gen√©ricos (void*) e n√£o se importar com o tipo concreto do dado. A responsabilidade de interpretar corretamente o tipo ser√° de quem usar a estrutura."
  },
  {
    "objectID": "disciplinas/aed2/gaming/unidade2/2-callback.html#sec-siz",
    "href": "disciplinas/aed2/gaming/unidade2/2-callback.html#sec-siz",
    "title": "üèúÔ∏è Deserto dos Callbacks",
    "section": "O papel de size_t",
    "text": "O papel de size_t\nAo manipular dados de tipos diferentes, precisamos tamb√©m saber quanto de mem√≥ria reservar ou copiar. √â a√≠ que entra o tipo size_t, definido no cabe√ßalho &lt;stddef.h&gt; (ou implicitamente inclu√≠do via &lt;stdlib.h&gt; ou &lt;stdio.h&gt;).\nComo um tipo num√©rico sem sinal (unsigned), size_t √© usado para representar tamanhos e quantidades de bytes. Ele √© o tipo de retorno de fun√ß√µes como sizeof, malloc, calloc e strlen.\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main() {\n    int x = 10;\n    double y = 3.14;\n\n    printf(\"sizeof(int): %zu bytes\\n\", sizeof(int));\n    printf(\"sizeof(double): %zu bytes\\n\", sizeof(double));\n\n    void *ptr = malloc(sizeof(double));\n    printf(\"Alocado %zu bytes em %p\\n\", sizeof(double), ptr);\n\n    free(ptr);\n    return 0;\n}\nSa√≠da t√≠pica:\nsizeof(int): 4 bytes\nsizeof(double): 8 bytes\nAlocado 8 bytes em 0x7ffee1\nA combina√ß√£o de void* e size_t √© fundamental para criar estruturas gen√©ricas, pois usaremos void* para representar o dado, independentemente de tipo e size_t para indicar o tamanho desse dado, permitindo c√≥pia, aloca√ß√£o e manipula√ß√£o seguras.\nFalta pouco para criarmos nossas estruturas gen√©ricas com comportamentos tamb√©m gen√©ricos. Antes, precisamos entender como generalizar a√ß√µes, ou seja, como permitir que uma estrutura chame fun√ß√µes que mudam conforme o tipo de dado.\nE √© aqui que entra o pr√≥ximo conceito fundamental, a abstra√ß√£o de comportamento. Para isso, devemos estudar os ponteiros para fun√ß√£o e callbacks."
  },
  {
    "objectID": "disciplinas/aed2/gaming/unidade2/3-memoria.html",
    "href": "disciplinas/aed2/gaming/unidade2/3-memoria.html",
    "title": "‚õ∞Ô∏è Vale da Mem√≥ria",
    "section": "",
    "text": "Trocar Tema\nAt√© aqui, vimos como generalizar dados e comportamentos em C usando ponteiros e callbacks. No entanto, toda essa flexibilidade traz a responsabilidade de gerenciar manualmente a mem√≥ria.\nNesta se√ß√£o, vamos entender como a linguagem C lida com a aloca√ß√£o din√¢mica, isto √©, a capacidade de reservar e liberar mem√≥ria em tempo de execu√ß√£o. Mais importante, veremos como evitar os erros de mem√≥ria mais comuns que podem comprometer a estabilidade e a seguran√ßa de um programa."
  },
  {
    "objectID": "disciplinas/aed2/gaming/unidade2/3-memoria.html#sec-alo",
    "href": "disciplinas/aed2/gaming/unidade2/3-memoria.html#sec-alo",
    "title": "‚õ∞Ô∏è Vale da Mem√≥ria",
    "section": "Aloca√ß√£o e libera√ß√£o din√¢mica",
    "text": "Aloca√ß√£o e libera√ß√£o din√¢mica\nQuando trabalhamos com arrays ou estruturas em C, geralmente definimos seus tamanhos em tempo de compila√ß√£o. Eles ficam armazenados em uma √°rea de mem√≥ria chamada stack.\nNo entanto, h√° muitos casos em que o tamanho dos dados n√£o √© conhecido antecipadamente. Para esses casos, o C fornece fun√ß√µes de aloca√ß√£o din√¢mica de mem√≥ria, que permitem reservar e liberar espa√ßo em tempo de execu√ß√£o. Esses blocos de mem√≥ria s√£o criados em uma regi√£o especial chamada heap.\nDizemos que a mem√≥ria stack √© est√°tica, enquanto que a heap √© din√¢mica. Na stack, quando a fun√ß√£o termina, a vari√°vel √© destru√≠da. J√° na heap, o programador decide quando alocar e liberar.\nA aloca√ß√£o din√¢mica oferece flexibilidade, mas tamb√©m exige disciplina. O princ√≠pio fundamental √©: quem aloca, deve liberar.\n\nAloca√ß√£o simples\nA fun√ß√£o malloc (de memory allocation) reserva um bloco cont√≠nuo de mem√≥ria de tamanho especificado em bytes.\nint *v = malloc(5 * sizeof(int));\nO argumento √© o n√∫mero total de bytes a serem alocados. No trecho acima, estamos alocando o espa√ßo suficiente para cinco inteiros. O retorno √© um ponteiro gen√©rico (void*) para o in√≠cio do bloco. Caso a aloca√ß√£o falhe, malloc retorna NULL.\n\n\n\n\n\n\nNota\n\n\n\nEm C, ao contr√°rio de C++, n√£o h√° necessidade de fazer o cast do ponteiro gen√©rico.\n\n\nComo n√£o temos garantia que a mem√≥ria foi alocada, precisamos tratar quando malloc falha. Isso √© geramente feito com um bloco if.\nint *v = malloc(5 * sizeof(int));\n    \nif (v == NULL) {\n    fprintf(stderr, \"Erro: sem mem√≥ria suficiente!\\n\");\n    return 1;\n}       \nNo trecho acima, poder√≠amos ter usado printf ao inv√©s de fprintf. A escolha, por fprintf se d√° por ser o padr√£o para erros. Ele permite especificar exatamente para onde a sa√≠da deve ir. Ao usarmos stderr (de standard error), estamos dizendo ao sistema que esta mensagem √© um erro e deve ser tratada como tal.\nQuando usamos printf a sa√≠da √© armazenada em buffer, portanto a mensagem de erro poderia ficar presa e nunca ser exibida antes do programa abortar. J√° quando optamos por fprintf, a sa√≠da √© unbuffered, ou seja, √© exibida imediatamente no terminal.\nResumindo, use fprinf mensagens de erro, diagn√≥stico e logs cr√≠ticos e use printf para mensagens de sucesso, resultado da aplica√ß√£o e sa√≠da esperada.\nO return 1 informa ao sistema operacional que algo deu errado .\n\n\nAloca√ß√£o e inicializa√ß√£o\nA fun√ß√£o calloc (de contiguous allocation) funciona como malloc, mas com duas diferen√ßas:\n\nRecebe dois par√¢metros, n√∫mero de elementos e tamanho de cada um;\nInicializa o bloco com zeros.\n\nint *v = calloc(5, sizeof(int));\nAssim, todo o vetor come√ßa zerado, o que evita leituras de lixo de mem√≥ria.\n\n\nRedimensionamento de bloco\nA fun√ß√£o realloc permite ajustar o tamanho de um bloco de mem√≥ria j√° alocado.\nint *novo = realloc(v, 10 * sizeof(int));\nSe houver espa√ßo cont√≠guo suficiente, o bloco √© expandido no mesmo local. Caso contr√°rio, um novo bloco √© alocado e o conte√∫do antigo √© copiado automaticamente. Em caso de falha, retorna NULL e n√£o desaloca o bloco de mem√≥ria original. Por isso, √© recomendado sempre usar um ponteiro tempor√°rio:\nint *temp = realloc(v, 10 * sizeof(int));\nif (temp == NULL) {\n    fprintf(stderr, \"Erro ao realocar mem√≥ria!\\n\");\n    return 1;\n}\nv = temp; // Atualiza o ponteiro com seguran√ßa\n\n\nLibera√ß√£o de mem√≥ria\nA fun√ß√£o free libera um bloco previamente alocado com malloc, calloc ou realloc. Ela devolve o espa√ßo ao sistema operacional, mas n√£o zera o ponteiro.\nfree(v);\nv = NULL; // Boa pr√°tica\n\n\n\n\n\n\nImportante\n\n\n\nAp√≥s liberar, o ponteiro ainda guarda o endere√ßo antigo, agora inv√°lido. Atribuir NULL ajuda a evitar o uso acidental, um erro cl√°ssico conhecido como dangling pointer.\n\n\nEste ciclo √© a base de toda manipula√ß√£o segura de mem√≥ria din√¢mica em C:\n\n\n\n\n\nflowchart LR\n    A(\"Alocar\") --&gt; B(\"Usar\")\n    B --&gt; C(\"Liberar\")  \n    C --&gt; D(\"Invalidar\")\n    D --&gt; A\n\n\n\n\n\n\n\nAlocar (malloc, calloc ou realloc)\nUsar (ler e escrever por meio do ponteiro)\nLiberar (free)\nInvalidar o ponteiro (ptr = NULL)\n\nCom essas fun√ß√µes, temos total controle sobre a vida √∫til de cada dado em mem√≥ria. No entanto, esse poder vem acompanhado de riscos: acessos indevidos, vazamentos e corrup√ß√£o de mem√≥ria s√£o erros comuns quando o ciclo de aloca√ß√£o n√£o √© seguido corretamente.\nNa pr√≥xima se√ß√£o, vamos explorar as fun√ß√µes de manipula√ß√£o de blocos de mem√≥ria e entender como oper√°-las com seguran√ßa antes de mergulhar nos erros cl√°ssicos de mem√≥ria."
  },
  {
    "objectID": "disciplinas/aed2/gaming/unidade2/3-memoria.html#sec-man",
    "href": "disciplinas/aed2/gaming/unidade2/3-memoria.html#sec-man",
    "title": "‚õ∞Ô∏è Vale da Mem√≥ria",
    "section": "Manipula√ß√£o de blocos de mem√≥ria",
    "text": "Manipula√ß√£o de blocos de mem√≥ria\nQuando trabalhamos com aloca√ß√£o din√¢mica, frequentemente precisamos copiar dados de uma regi√£o de mem√≥ria para outra. O C oferece um conjunto de fun√ß√µes na biblioteca &lt;string.h&gt; para manipular blocos de mem√≥ria de forma gen√©rica, usando ponteiros do tipo void*.\nEssas fun√ß√µes operam diretamente em bytes, e n√£o conhecem o tipo de dado armazenado. Por isso, exigem aten√ß√£o com o tamanho dos blocos manipulados (geralmente expresso com size_t).\nAs tr√™s fun√ß√µes principais para manipula√ß√£o de blocos de mem√≥ria s√£o:\n\nmemcpy: copia bytes de uma origem para um destino\nmemmove: copia bytes com seguran√ßa mesmo se houver sobreposi√ß√£o\nmemset: preenche uma √°rea de mem√≥ria com um valor constante\n\n\nCopiando blocos de mem√≥ria\nA fun√ß√£o memcpy copia \\(n\\) bytes do bloco apontado por src (origem) para o bloco apontado por dest (destino).\nvoid *memcpy(void *dest, const void *src, size_t n);\nExemplo pr√°tico:\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main() {\n    int origem[5] = {1, 2, 3, 4, 5};\n    int destino[5];\n\n    memcpy(destino, origem, 5 * sizeof(int));\n\n    for (int i = 0; i &lt; 5; i++)\n        printf(\"%d \", destino[i]);\n    \n    return 0;\n}\nSa√≠da:\n1 2 3 4 5\n\n\n\n\n\n\nImportante\n\n\n\nA fun√ß√£o memcpy n√£o deve ser usada quando as regi√µes de origem e destino se sobrep√µem. O comportamento √© indefinido, podendo corromper os dados.\n\n\n\n\nC√≥pia segura com sobreposi√ß√£o\nA fun√ß√£o memmove √© semelhante a memcpy, mas trata corretamente casos de sobreposi√ß√£o. Se o bloco de destino estiver dentro da √°rea de origem (ou vice-versa), ela ajusta a dire√ß√£o da c√≥pia automaticamente.\nvoid *memmove(void *dest, const void *src, size_t n);\nExemplo:\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main() {\n    char texto[20] = \"ABCDEF\";\n\n    // Copiando parte sobreposta\n    memmove(texto + 2, texto, 4);\n    texto[6] = '\\0';\n\n    printf(\"%s\\n\", texto); // Resultado: \"ABABCD\"\n    return 0;\n}\nSe tiv√©ssemos usado memcpy nesse exemplo, o conte√∫do de texto poderia ser corrompido, pois as regi√µes texto e texto + 2 se sobrep√µem.\n\n\nInicializando mem√≥ria\nA fun√ß√£o memset preenche um bloco de mem√≥ria com um valor constante em bytes. Ela √© muito usada para inicializar buffers ou zerar estruturas.\nvoid *memset(void *ptr, int valor, size_t n);\nExemplo:\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main() {\n    int v[5];\n    memset(v, 0, 5 * sizeof(int));\n\n    for (int i = 0; i &lt; 5; i++)\n        printf(\"%d \", v[i]);\n    \n    return 0;\n}\nSa√≠da:\n0 0 0 0 0\n\n\n\n\n\n\nImportante\n\n\n\nO valor passado a memset √© interpretado como um byte, e n√£o como um inteiro completo. Por exemplo, memset(v, 1, sizeof(int)*5) preencher√° todos os bytes com 0x01, n√£o com o inteiro 1."
  },
  {
    "objectID": "disciplinas/aed2/gaming/unidade2/3-memoria.html#sec-cui",
    "href": "disciplinas/aed2/gaming/unidade2/3-memoria.html#sec-cui",
    "title": "‚õ∞Ô∏è Vale da Mem√≥ria",
    "section": "Cuidados e boas pr√°ticas",
    "text": "Cuidados e boas pr√°ticas\n\nSempre use sizeof para calcular o n√∫mero correto de bytes.\n\nEvite express√µes m√°gicas como memcpy(dest, src, 20).\nUse memcpy(dest, src, n * sizeof(T)).\n\nPrefira memmove quando houver d√∫vida sobre sobreposi√ß√£o.\nZere estruturas antes de us√°-las (por exemplo, buffers de strings).\nEvite manipular mem√≥ria de tipos complexos (estruturas com ponteiros internos) com memcpy\n\nIsso pode quebrar o encapsulamento e gerar c√≥pias superficiais perigosas.\n\n\nCom essas fun√ß√µes, temos ferramentas poderosas para manipular diretamente a mem√≥ria. Isso √© um recurso essencial para implementar estruturas gen√©ricas e opera√ß√µes de baixo n√≠vel. Entretanto, o uso incorreto dessas fun√ß√µes √© uma das principais causas de erros sutis e dif√≠ceis de depurar em C.\nNa pr√≥xima se√ß√£o, estudaremos exatamente esses erros, os erros cl√°ssicos de mem√≥ria, como dangling pointers, buffer overflow e double free, e como evit√°-los com boas pr√°ticas.\n\nErros cl√°ssicos de mem√≥ria\nGerenciar mem√≥ria manualmente √© uma das maiores responsabilidades (e riscos) ao programar em C. Ao lidar com ponteiros e aloca√ß√£o din√¢mica, pequenos descuidos podem causar comportamentos indefinidos, travamentos ou at√© falhas de seguran√ßa.\nNesta se√ß√£o, veremos os erros mais comuns, seus sintomas e como evit√°-los.\n\nPonteiros n√£o inicializados (wild pointers)\nUm wild pointer √© um ponteiro que n√£o foi inicializado antes do uso. Ele cont√©m um valor de endere√ßo aleat√≥rio, podendo apontar para qualquer lugar da mem√≥ria.\n#include &lt;stdio.h&gt;\n\nint main() {\n    int *p;       // n√£o inicializado!\n    *p = 42;      // comportamento indefinido!\n    printf(\"%d\\n\", *p);\n    return 0;\n}\n\n\n\n\n\n\nCuidado\n\n\n\nEsse c√≥digo pode travar o programa (segmentation fault), corromper dados ou at√© ‚Äúfuncionar‚Äù, mascarando o erro (o pior cen√°rio).\n\n\nComo boa pr√°tica, sempre inicialize ponteiros:\nint *p = NULL;\n\n\nPonteiros pendentes (dangling pointers)\nUm dangling pointer ocorre quando o ponteiro ainda referencia uma regi√£o de mem√≥ria j√° liberada.\n#include &lt;stdlib.h&gt;\n\nint main() {\n    int *p = malloc(sizeof(int));\n    *p = 10;\n    free(p);\n    printf(\"%d\\n\", *p); // uso ap√≥s libera√ß√£o ‚Äî ERRO\n    return 0;\n}\n\n\n\n\n\n\nCuidado\n\n\n\nO bloco de mem√≥ria foi liberado, mas o ponteiro ainda ‚Äúacha‚Äù que √© v√°lido. Acessar ou modificar essa regi√£o causa comportamento indefinido.\n\n\nComo boa pr√°tica, ap√≥s free(p), defina p = NULL; para evitar acessos acidentais.\n\n\nVazamentos de mem√≥ria (memory leaks)\nUm memory leak acontece quando um programa perde a refer√™ncia para uma regi√£o de mem√≥ria alocada, sem cham√°-la com free().\n#include &lt;stdlib.h&gt;\n\nint main() {\n    int *p = malloc(100 * sizeof(int));\n    p = NULL;  // perdemos a refer√™ncia ‚Äî vazamento!\n    return 0;\n}\n\n\n\n\n\n\nCuidado\n\n\n\nA mem√≥ria continua alocada, mas inacess√≠vel. Em programas longos, isso pode acumular e exaurir a mem√≥ria do sistema.\n\n\nComo boas pr√°tica, sempre emparelhe malloc e free. Em fun√ß√µes complexas, adote o princ√≠pio ‚Äúquem aloca, libera‚Äù.\n\n\nLibera√ß√£o duplicada (double free)\nUm double free ocorre quando tentamos liberar o mesmo bloco de mem√≥ria mais de uma vez.\n#include &lt;stdlib.h&gt;\n\nint main() {\n    int *p = malloc(sizeof(int));\n    free(p);\n    free(p); // ERRO: double free\n    return 0;\n}\n\n\n\n\n\n\nCuidado\n\n\n\nIsso causa corrup√ß√£o da estrutura interna do heap e frequentemente resulta em segmentation fault.\n\n\nComo boa pr√°tica, ap√≥s liberar, defina p = NULL.\n\n\nAcesso fora dos limites (buffer overflow e underrun)\nUm buffer overflow ocorre quando se escreve al√©m do final (ou antes do in√≠cio) de um bloco de mem√≥ria.\n#include &lt;stdio.h&gt;\n\nint main() {\n    int v[3] = {1, 2, 3};\n    v[3] = 99; // √≠ndice inv√°lido ‚Äî overflow\n    printf(\"%d\\n\", v[3]); // comportamento indefinido\n    return 0;\n}\n\n\n\n\n\n\nCuidado\n\n\n\nEsse tipo de erro √© grave: pode corromper vari√°veis adjacentes, causar travamentos ou vulnerabilidades de seguran√ßa (explora√ß√£o de stack overflow).\n\n\nComo boas pr√°tica, sempre verifique limites de vetores. Al√©m disso, prefira fun√ß√µes seguras (ex: strncpy no lugar de strcpy). Ao usar malloc, garanta que o tamanho esteja correto com sizeof.\nPodemos resumir os tipos de erros abordados por meio da seguinte tabela.\n\n\n\n\n\n\n\n\n\nTipo de Erro\nCausa\nSintoma\nPreven√ß√£o\n\n\n\n\nWild Pointer\nPonteiro n√£o inicializado\nCrash aleat√≥rio\nInicializar com NULL\n\n\nDangling Pointer\nUso ap√≥s free\nSegmentation fault\np = NULL ap√≥s free\n\n\nMemory Leak\nPerda de refer√™ncia\nAumento de uso de mem√≥ria\nSempre liberar\n\n\nDouble Free\nLibera√ß√£o repetida\nCorrup√ß√£o do heap\nControle de ownership\n\n\nBuffer Overflow\nEscrita fora dos limites\nCorrup√ß√£o de mem√≥ria\nVerificar limites\n\n\n\nErros de mem√≥ria est√£o entre os mais sutis e perigosos em C. Eles n√£o apenas causam falhas, mas podem introduzir vulnerabilidades de seguran√ßa s√©rias. Com boas pr√°ticas e ferramentas adequadas, √© poss√≠vel evit√°-los e desenvolver sistemas robustos e confi√°veis."
  },
  {
    "objectID": "disciplinas/aed2/gaming/unidade2/3-memoria.html#sec-boa",
    "href": "disciplinas/aed2/gaming/unidade2/3-memoria.html#sec-boa",
    "title": "‚õ∞Ô∏è Vale da Mem√≥ria",
    "section": "Boas pr√°ticas e padr√µes",
    "text": "Boas pr√°ticas e padr√µes\nGerenciar mem√≥ria em C exige disciplina. A responsabilidade √© totalmente do programador, pois o compilador n√£o faz verifica√ß√µes autom√°ticas. A seguir, apresentamos um conjunto de princ√≠pios e padr√µes que ajudam a escrever c√≥digo seguro, previs√≠vel e f√°cil de manter.\n\nInicializa√ß√£o defensiva\nSempre inicialize ponteiros, mesmo quando voc√™ ainda n√£o sabe qual endere√ßo eles ter√£o.\nint *p = NULL;\nEssa pr√°tica evita comportamentos indefinidos quando o ponteiro √© usado antes de ser atribu√≠do. Ela tamb√©m facilita verifica√ß√µes de seguran√ßa:\nif (p != NULL) {\n    *p = 42;\n}\n\n\n\n\n\n\nDica\n\n\n\nUm ponteiro deve sempre apontar para algo v√°lido, ou para NULL.\n\n\n\n\nO princ√≠pio da propriedade (ownership)\nEm programas maiores, √© comum que uma fun√ß√£o aloca mem√≥ria e outra a utilize. Para evitar vazamentos ou libera√ß√µes incorretas, defina quem √© o dono (owner) de cada bloco alocado.\nüî∏ Quem aloca √© respons√°vel por liberar.\nExemplo:\nchar* criar_mensagem() {\n    char *msg = malloc(50);\n    sprintf(msg, \"Ol√°, mundo!\");\n    return msg;  // a fun√ß√£o devolve a posse\n}\n\nint main() {\n    char *m = criar_mensagem();\n    puts(m);\n    free(m);     // responsabilidade de quem recebeu\n}\n\n\nPar malloc e free\nCada chamada de aloca√ß√£o din√¢mica deve ter uma contrapartida de libera√ß√£o. Evite fluxos de execu√ß√£o que impe√ßam o free de ser chamado.\nchar *p = malloc(100);\nif (!p) return;   // erro de aloca√ß√£o\n// ...\nfree(p);\n\n\n\n\n\n\nDica\n\n\n\nCentralize libera√ß√µes num √∫nico ponto de sa√≠da, especialmente em fun√ß√µes longas.\n\n\n\n\nEvite opera√ß√µes parciais\nNunca tente liberar apenas parte de uma estrutura alocada. Sempre opere sobre a mesma refer√™ncia retornada por malloc.\nint *v = malloc(10 * sizeof(int));\nint *p = v + 5;\nfree(p); // ‚ùå comportamento indefinido\nfree(v); // ‚úÖ correto\n\n\nZerar mem√≥ria ap√≥s libera√ß√£o (quando necess√°rio)\nEm sistemas que lidam com dados sens√≠veis (como senhas), vale a pena limpar o conte√∫do antes de liberar.\nmemset(senha, 0, tamanho);\nfree(senha);\nIsso impede que dados fiquem acess√≠veis em regi√µes de mem√≥ria reaproveitadas.\n\n\nMacros e wrappers de seguran√ßa\nEm projetos grandes, √© comum encapsular chamadas de aloca√ß√£o/libera√ß√£o em fun√ß√µes auxiliares. Isso facilita rastrear erros e aplicar verifica√ß√µes centralizadas.\nvoid* safe_malloc(size_t n) {\n    void *p = malloc(n);\n    if (p == NULL) {\n        fprintf(stderr, \"Erro: malloc falhou\\n\");\n        exit(EXIT_FAILURE);\n    }\n    return p;\n}\nüîπ Com esse padr√£o, voc√™ garante que toda aloca√ß√£o seja verificada.\nGerenciar mem√≥ria em C √© uma arte de equil√≠brio entre controle total e responsabilidade absoluta. Com disciplina e padr√µes bem definidos, √© poss√≠vel construir sistemas robustos, perform√°ticos e seguros."
  },
  {
    "objectID": "disciplinas/aed2/gaming/index.html",
    "href": "disciplinas/aed2/gaming/index.html",
    "title": "Algoritmos e Estruturas de Dados 2",
    "section": "",
    "text": "Bem-vindo ao portal de REA sobre Algoritmos e Estruturas de Dados 2. Aqui voc√™ encontrar√° informa√ß√µes sobre a bibliografia, aulas ministradas e muito mais. Nesta empreitada, n√£o estaremos sozinhos, vamos conhecer quem trilhar√° conosco e nos ajudar√° a compreender melhor alguns conceitos importantes desta mat√©ria."
  },
  {
    "objectID": "disciplinas/aed2/gaming/index.html#companheiros-de-jornada",
    "href": "disciplinas/aed2/gaming/index.html#companheiros-de-jornada",
    "title": "Algoritmos e Estruturas de Dados 2",
    "section": "Companheiros de Jornada",
    "text": "Companheiros de Jornada\n\n\n\nShellSort e Hashy\n\n\n\n\n\n\nOl√°, pessoal! Eu sou o ShellSort, mas podem me chamar de Shell!\n\n\n\n\n\nE eu sou a Hashy!\n\n\n\n\n\nVamos te auxiliar na jornada pelos Algoritmos e Estruturas de Dados. Como podem ver, levo minha ‚Äòestrutura de dados‚Äô (meu casco) por onde ando. Mas n√£o se enganem: por dentro, sou cheio de n√≥s e refer√™ncias, pronto para guiar voc√™s pelo universo da programa√ß√£o!\n\n\n\n\n\nShellzinho, voc√™ √© realmente √≥timo em colocar as coisas em ordem com paci√™ncia, mas eu sou a especialista em organiza√ß√£o r√°pida e busca eficiente.\n\n\n\n\n\n√â verdade Hashy, a gente se completa. Nossa miss√£o √© simples: mostrar que, com paci√™ncia e m√©todo, at√© os conceitos mais complexos se tornam f√°ceis de dominar.‚ÄúDevagar e sempre avante, esse √© o meu algoritmo!‚Äù\n\n\n\n\n\nMeu casco pode parecer um s√≥, mas por dentro √© uma rede superorganizada, pronta para armazenar conhecimento e refer√™ncias. Podem contar comigo para entender como otimizar seus c√≥digos em C e resolver problemas com velocidade!‚ÄúSeja r√°pida, seja precisa. Ache a chave!‚Äù\n\n\n\n\n\nVamos juntos nessa jornada de aprendizado!\n\n\n\n\nJuntos com Shell e Hashy, vamos explorar o mundo das estruturas de dados e seus algoritmos. Prepare-se para um jornada desafiadora e divertida enfrentando os diversos desafios que nos tornar√£o melhores programadores."
  },
  {
    "objectID": "disciplinas/aed2/gaming/index.html#portal-dos-mundos",
    "href": "disciplinas/aed2/gaming/index.html#portal-dos-mundos",
    "title": "Algoritmos e Estruturas de Dados 2",
    "section": "Portal dos Mundos",
    "text": "Portal dos Mundos\n\n\n\n\nExplore o mundo das estruturas de dados e desbloqueie novos desafios de aprendizado!\n\n\n\n\n \n    üå≥ Arquip√©lago das √Årvores\n   \n      üå± √Årvores\n      üå≤ √Årvores Bin√°rias\n      üîç √Årvore Bin√°ria de Busca\n      ‚öñÔ∏è √Årvore AVL\n    \n  \n\n  \n    üß© Plan√≠cie Gen√©rica\n    \n      üèùÔ∏è Fundamentos e Ferramentas Gen√©ricas\n      ‚öôÔ∏è Aplica√ß√£o: A Calculadora Gen√©rica\n      üå≥ Listas e √Årvores Gen√©ricas\n    \n  \n\n  \n    üí† Deserto da Dispers√£o\n    \n      üî¢ Tabela de Dispers√£o\n      üí• Tratamento de Colis√£o\n      üåÄ Tabela de Dispers√£o Din√¢mica\n    \n  \n\n  \n    üèîÔ∏è Montanha de Prioridades\n    \n      üì¶ Representa√ß√£o por Vetor\n      üèóÔ∏è Constru√ß√£o\n      üß± Estrutura Heap e Algoritmo HeapSort\n    \n   \n\n  \n    üï∏Ô∏è Labirinto dos Grafos\n    \n      üîó Introdu√ß√£o a Grafos\n      üö∂ Busca em Largura e Profundidade\n      üó∫Ô∏è Caminho M√≠nimo"
  },
  {
    "objectID": "disciplinas/aed2/academic/unidade2/2-callback.html",
    "href": "disciplinas/aed2/academic/unidade2/2-callback.html",
    "title": "Callbacks",
    "section": "",
    "text": "Nossa jornada pelos ponteiros ainda n√£o acabou. Nesta unidade vamos estudar o uso de ponteiros com fun√ß√µes. Isso mesmo, uma fun√ß√£o tamb√©m possui um endere√ßo de mem√≥ria. Poderemos chamar fun√ß√µes indiretamente e passar fun√ß√µes como param√™tros para outras fun√ß√µes.",
    "crumbs": [
      "Callbacks"
    ]
  },
  {
    "objectID": "disciplinas/aed2/academic/unidade2/2-callback.html#sec-fun",
    "href": "disciplinas/aed2/academic/unidade2/2-callback.html#sec-fun",
    "title": "Callbacks",
    "section": "Ponteiros de Fun√ß√µes",
    "text": "Ponteiros de Fun√ß√µes\nUm ponteiro tamb√©m pode armazenar o endere√ßo de uma fun√ß√£o. O racioc√≠nio √© o mesmo de antes, mas a sintaxe para a declara√ß√£o √© mais espec√≠fica, pois ela precisa descrever a assinatura completa da fun√ß√£o: seu tipo de retorno e seus par√¢metros.\nA sintaxe de declara√ß√£o pode parecer confusa no in√≠cio, mas pode ser lida assim:\ntipo_de_retorno (*nome_do_ponteiro)(tipos_de_parametros);\nVamos tomar a fun√ß√£o media como exemplo. Ela recebe dois valores e retorna a m√©dia aritm√©tica deles.\ndouble media (double n1, double n2){\n  return (n1 + n2)/2;\n}\n\n// Declara√ß√£o de um ponteiro de fun√ß√£o:\ndouble (*media_ptr)(double, double) = media;\nA sintaxe de declara√ß√£o do ponteiro media_prt deve ser lida da seguinte forma:\n\ndouble: √© o tipo de retorno;\n(*media_ptr): indica que media_ptr √© um ponteiro para fun√ß√£o. Os par√™nteses s√£o obrigat√≥rios para diferenci√°-lo de uma fun√ß√£o que retorna um ponteiro;\n(double, double): s√£o os tipos dos par√¢metros da fun√ß√£o apontada.\n\n\n\n\n\n\n\nNota\n\n\n\nDiferentemente das vari√°veis, ao atribuir o endere√ßo de uma fun√ß√£o a um ponteiro de fun√ß√£o, n√£o √© necess√°rio usar o operador & (o nome da fun√ß√£o sozinho j√° representa seu endere√ßo).\n\n\nNote que a fun√ß√£o media obedece a assinatura (ou contrato) estabelecido pelo ponteiro de fun√ß√£o media_ptr, ou seja, possui o mesmo tipo de retorno e os mesmos tipos de par√¢metros de entrada (double, double). Portanto, devemos manter a compatibilidade de tipos, como fizemos com as vari√°veis na se√ß√£o anterior.",
    "crumbs": [
      "Callbacks"
    ]
  },
  {
    "objectID": "disciplinas/aed2/academic/unidade2/2-callback.html#sec-cal",
    "href": "disciplinas/aed2/academic/unidade2/2-callback.html#sec-cal",
    "title": "Callbacks",
    "section": "Introdu√ß√£o aos Callbacks",
    "text": "Introdu√ß√£o aos Callbacks\nO verdadeiro poder dos ponteiros de fun√ß√£o aparece quando uma fun√ß√£o √© passada como argumento para outra. Nesse caso, a fun√ß√£o que recebe outra fun√ß√£o √© chamada de fun√ß√£o de ordem superior, enquanto a fun√ß√£o fornecida como argumento √© chamada de callback.\nEssa t√©cnica permite que um trecho de c√≥digo delegue parte de seu comportamento a outro, tornando o programa mais flex√≠vel, modular e param√©trico.\nAbaixo, um exemplo de uma calculadora de inteiros, onde calcular √© uma fun√ß√£o de ordem superior, pois recebe outra fun√ß√£o como par√¢metro. As fun√ß√µes soma, subtracao, produto e divisao s√£o callbacks, pois s√£o passadas para calcular.\n\n\ncalculadora_param.c\n\n#include &lt;stdio.h&gt;\n\n// Fun√ß√µes concretas (implementam comportamentos espec√≠ficos)\nint soma (int a, int b)     { return a + b; }\nint subtracao (int a, int b){ return a - b; }\nint produto (int a, int b)  { return a * b; }\nint divisao (int a, int b)  { return a / b; }\n\n// Fun√ß√£o coordenadora (de ordem superior)\n// Recebe duas vari√°veis e um ponteior de fun√ß√£o como par√¢metros\nint calcular(int a, int b, int (*operacao)(int, int)) {\n  return operacao(a, b);\n}\n\nint main(){\n\n  int n1 = 10;\n  int n2 = 2;\n  \n  printf(\"Soma:      %d\\n\", calcular(n1, n2, soma));\n  printf(\"Subtra√ß√£o: %d\\n\", calcular(n1, n2, subtracao));\n  printf(\"Produto:   %d\\n\", calcular(n1, n2, produto));\n  printf(\"Divis√£o:   %d\\n\", calcular(n1, n2, divisao));  \n  \n  return 0;\n}\n\n\n\nSe liga! A fun√ß√£o calcular n√£o sabe qual opera√ß√£o ser√° executada, ela apenas invoca o comportamento recebido como par√¢metro. Isso √© o que chamamos de abstra√ß√£o de comportamento.\nA sa√≠da desse programa ser√°\n  Soma:      12\n  Subtra√ß√£o: 8\n  Produto:   20\n  Divis√£o:   5 \nAo passar a fun√ß√£o como par√¢metro, tornamos o c√≥digo de C extremamente poderoso e reutiliz√°vel. A fun√ß√£o calcular n√£o se importa como o c√°lculo √© feito, apenas que a fun√ß√£o fornecida (o callback) respeite o contrato de tipos (int para retorno, e int, int para par√¢metros).\nPodemos ir al√©m nessa reutiliza√ß√£o? Sim, mas atingimos o limite do polimorfismo simples em C. Imagine que voc√™ queira adicionar uma opera√ß√£o com n√∫meros de ponto flutuante:\ndouble somad (double a, double b) { return a + b; }\nO problema √© que n√£o podemos passar somad para a fun√ß√£o calcular e nem a usar para operar com double, pois o callback int (*operacao)(int, int) e os par√¢metros fixos em calcular(int a, int b, ...) tornam essa fun√ß√£o totalmente incompat√≠vel com o tipo double.\nPara resolver esse problema e criar uma √∫nica fun√ß√£o verdadeiramente gen√©rica que aceite qualquer tipo de dado, precisamos abandonar os tipos concretos (int, double) e generalizar usando o ponteiro sem tipo (void*).\nAntes de darmos o salto para o c√≥digo verdadeiramente gen√©rico usando void*, vamos usar o typedef para melhorar a legibilidade de nosso c√≥digo.\nA sintaxe de um ponteiro de fun√ß√£o (por exemplo, int (*operacao)(int, int)) pode dificultar a leitura do c√≥digo, principalmente como argumentos de fun√ß√£o. O typedef permite que voc√™ crie um apelido para essa assinatura complexa, tratando-a como um novo tipo de dado simples.\nAo definir o tipo do callback, tornamos a fun√ß√£o calcular muito mais limpa:\n// Definimos 'Operacao' como o tipo para qualquer fun√ß√£o\n// que retorna int e aceita dois int como par√¢metros.\ntypedef int (*Operacao)(int, int);\n\n// A fun√ß√£o 'calcular' agora usa o tipo 'Operacao', \n// simplificando sua assinatura.\nint calcular(int a, int b, Operacao operacao); \nO c√≥digo final ficaria assim:\n\n\ncalculadora_typedef.c\n\n#include &lt;stdio.h&gt;\n\n// Defini√ß√£o do TIPO de ponteiro de fun√ß√£o\ntypedef int (*Operacao)(int, int);\n\n// Fun√ß√µes concretas (omitidas para brevidade)\nint soma (int a, int b) { return a + b; }\n// ...\n\n// A Fun√ß√£o Coordenadora agora √© mais leg√≠vel\nint calcular(int a, int b, Operacao operacao) {\n  return operacao(a, b);\n}\n\nint main(){\n\n  int n1 = 10;\n  int n2 = 2;\n  \n  printf(\"Soma: %d\\n\", calcular(n1, n2, soma));\n  \n  return 0;\n}\n\n\n\nSe liga! Com typedef, ganhamos mais clareza no c√≥digo. A fun√ß√£o calcular se torna muito mais limpa e leg√≠vel.\nCom essa abrodardagem, ganhamos:\n\nReutiliza√ß√£o: A fun√ß√£o calcular √© reutilizada para todas as opera√ß√µes.\nF√°cil extens√£o: Para adicionar uma nova opera√ß√£o, basta criar a fun√ß√£o e pass√°-la para calcular. N√£o precisamos de blocos if/else ou switch dentro de calcular.\nBaixo acoplamento: calcular n√£o precisa saber como a opera√ß√£o √© feita (se √© soma ou subtra√ß√£o), apenas que a fun√ß√£o passada segue o contrato definido pelo tipo Operacao.\n\nDessa maneira, calcular se comporta de v√°rias formas (polimorfismo).\nUma das grandes vantagens de usar ponteiros para fun√ß√µes √© a possibilidade de criar um menu interativo, permitindo ao usu√°rio escolher qual opera√ß√£o deseja executar.\nOperacao escolha(){\n  printf(\"Esolha a Opera√ß√£o Desejada\\n\");\n  printf(\"1 - Soma\\n\");\n  printf(\"2 - Subtra√ß√£o\\n\");\n  printf(\"3 - Multiplica√ß√£o\\n\");\n  printf(\"4 - Divis√£o\\n\");\n    \n  int s = 0;\n  scanf(\"%d\", &s);\n\n  if (s == 1) return soma;\n  if (s == 2) return subtracao;\n  if (s == 3) return produto;\n  if (s == 4) return divisao;\n  \n  return NULL;  // Retorna NULL se a escolha for inv√°lida\n}\nNa vers√£o acima, a possibilidade de repetir o menu, em caso de entrada inv√°lida, n√£o est√° implementado. Todavia, podemos modificar para um problema espec√≠fico. O que notamos de mais problem√°tico √© que a fun√ß√£o escolha possui duas responsabilidades e devemos evitar isso no futuro para deixar o c√≥digo mais modular e facilitar a manuten√ß√£o.",
    "crumbs": [
      "Callbacks"
    ]
  },
  {
    "objectID": "disciplinas/aed2/academic/unidade2/2-callback.html#sec-gen",
    "href": "disciplinas/aed2/academic/unidade2/2-callback.html#sec-gen",
    "title": "Callbacks",
    "section": "Ponteiro gen√©rico",
    "text": "Ponteiro gen√©rico\nAgora que compreendemos o funcionamento dos ponteiros, passagem por refer√™ncia e callbacks, podemos dar um passo al√©m. Vamos estudar um m√©todo para representar qualquer tipo de dado.\nEm C, o tipo void * √© conhecido como ponteiro gen√©rico (generic pointer). Ele √© um tipo especial de ponteiro que pode armazenar o endere√ßo de qualquer tipo de dado, por exemplo int, double, char, struct etc.\nint idade = 20;\ndouble meta = 8.5;\nchar letra = 'A';\n\nvoid *ptr;\n\nptr = &idade;\nprintf(\"idade: %d\\n\", *(int *)ptr);\n\nptr = &meta;\nprintf(\"meta: %.2f\\n\", *(double *)ptr);\n\nptr = &letra;\nprintf(\"letra: %c\\n\", *(char *)ptr);\n\n\nSe liga! N√£o podemos desreferenciar diretamente um ponteiro void * , pois o compilador n√£o sabe quantos bytes ele deve ler. Devemos sempre fazer um cast (convers√£o) do void * para o tipo espec√≠fico de ponteiro que desejamos, antes de poder us√°-lo.\nRepare que, embora ptr sempre seja do tipo void *, precisamos fazer um cast (convers√£o expl√≠cita) para o tipo correto antes de acessar o valor. Isso ocorre porque o compilador n√£o sabe qual √© o tipo real do dado armazenado e, portanto, n√£o pode fazer aritm√©tica de ponteiros nem desreferencia√ß√£o direta.\nEssa caracter√≠stica √© o que permite criar estruturas de dados gen√©ricas em C, como listas, pilhas ou filas capazes de armazenar qualquer tipo. Essas estruturas ir√£o guardar apenas endere√ßos gen√©ricos (void *) e n√£o se importar com o tipo concreto do dado. A responsabilidade de interpretar corretamente o tipo ser√° de quem usar a estrutura.",
    "crumbs": [
      "Callbacks"
    ]
  },
  {
    "objectID": "disciplinas/aed2/academic/unidade2/2-callback.html#sec-siz",
    "href": "disciplinas/aed2/academic/unidade2/2-callback.html#sec-siz",
    "title": "Callbacks",
    "section": "O papel de size_t",
    "text": "O papel de size_t\nAo manipular dados de tipos diferentes, precisamos tamb√©m saber quanto de mem√≥ria reservar ou copiar. √â a√≠ que entra o tipo size_t, definido no cabe√ßalho &lt;stddef.h&gt; (ou implicitamente inclu√≠do via &lt;stdlib.h&gt; ou &lt;stdio.h&gt;).\nComo um tipo num√©rico sem sinal (unsigned), size_t √© usado para representar tamanhos e quantidades de bytes. Ele √© o tipo de retorno de fun√ß√µes como sizeof, malloc, calloc e strlen.\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main() {\n    int x = 10;\n    double y = 3.14;\n\n    printf(\"sizeof(int)   : %zu bytes\\n\", sizeof(int));\n    printf(\"sizeof(double): %zu bytes\\n\", sizeof(double));\n\n    void *ptr = malloc(sizeof(double));\n    printf(\"Alocado %zu bytes em %p\\n\", sizeof(double), ptr);\n\n    free(ptr);\n    return 0;\n}\n\n\nSe liga!\n\nz √© um modificador de comprimento que especifica que o argumento √© do tipo size_t\nu √© o c√≥digo de convers√£o para inteiro decimal sem sinal (unsigned).\n\nSa√≠da t√≠pica:\nsizeof(int)   : 4 bytes\nsizeof(double): 8 bytes\nAlocado 8 bytes em 0x7ffee1\nA combina√ß√£o de void * e size_t √© fundamental para criar estruturas gen√©ricas, pois usaremos void * para representar o dado, independentemente de tipo e size_t para indicar o tamanho desse dado, permitindo c√≥pia, aloca√ß√£o e manipula√ß√£o seguras.\n\n\n\n\n\n\nNotaüéØ Desafio de C√≥digo\n\n\n\nCrie uma fun√ß√£o aplicar que recebe um vetor de inteiros e uma fun√ß√£o callback que √© aplicada a cada elemento do vetor. Para as fun√ß√µes de callback, implemente:\n\ndobra: dobra o valor de cada elemento do vetor\nzerar: Define cada elemento como zero\nincrementar: soma um a cada elemento do vetor\n\nSegue a decla√ß√£o da fun√ß√µes de callback e ordem superior, al√©m de um exemplo de uso.\n#include &lt;stdio.h&gt;\n\nvoid dobrar(int *x);\nvoid zerar(int *x);\nvoid incrementar(int *x);\n\nvoid aplicar(int *vetor, int tamanho, void (*funcao)(int *));\n\nint main() {\n    int numeros[] = {1, 2, 3, 4, 5};\n    aplicar(numeros, 5, dobrar);\n\n    for (int i = 0; i &lt; 5; i++) {\n        printf(\"%d \", numeros[i]);\n    }\n\n    return 0;\n}\n\n\n\n\n\n\n\n\nDicaSolu√ß√£o (clique para ver)\n\n\n\n\n\nvoid dobrar(int *x){ *x = *x * 2; }\n\nvoid zerar(int *x){ *x = 0; }\n\nvoid incrementar(int *x){ *x = *x + 1; }\n\nvoid aplicar(int *vetor, int tamanho, void (*funcao)(int *)){\n  for (int i = 0; i &lt; tamanho; i++)\n        funcao(&vetor[i]);\n}    \n\n\n\n\nNesta unidade, voc√™ aprendeu\n‚úÖ a declarar um ponteiro de fun√ß√£o\n‚úÖ a criar fun√ß√µes de ordem superior e de callbacks\n‚úÖ a usar ponteiros sem tipo (void *)\n‚úÖ a usar site_t para designar tamanho ou quantidade de bytes\nFalta pouco para criarmos nossas estruturas gen√©ricas com comportamentos tamb√©m gen√©ricos. Por√©m, ainda precisamos pontuar algumas quest√µes sobre o gerenciamento de mem√≥ria.\n\n# O que √© um ponteiro de fun√ß√£o?\n\n&gt; Ele armazena o endere√ßo de uma fun√ß√£o e permite cham√°-la indiretamente.\n\n1. [ ] Um tipo especial de ponteiro usado apenas para vari√°veis globais\n1. [ ] Um ponteiro que aponta para dados armazenados na pilha\n1. [x] Um ponteiro que armazena o endere√ßo de uma fun√ß√£o\n1. [ ] Um operador utilizado para alocar mem√≥ria din√¢mica\n\n\n# Qual √© a sintaxe correta para declarar um ponteiro para fun√ß√£o que retorna `int` e recebe dois `int`?\n\n&gt; Observe a posi√ß√£o dos par√™nteses e do asterisco.\n\n1. [x] `int (*ptr)(int, int);`\n1. [ ] `int *ptr(int, int);`\n1. [ ] `(*int ptr)(int, int);`\n1. [ ] `int (ptr*)(int, int);`\n\n\n# Sobre a atribui√ß√£o de uma fun√ß√£o a um ponteiro de fun√ß√£o, √© correto afirmar que...\n\n&gt; Lembre-se de como nomes de fun√ß√µes se comportam em C.\n\n1. [ ] √â necess√°rio usar o operador `&` sempre.\n1. [x] O nome da fun√ß√£o j√° representa seu endere√ßo.\n1. [ ] O operador `*` deve ser usado antes do nome da fun√ß√£o.\n1. [ ] S√≥ √© poss√≠vel atribuir fun√ß√µes `void` a ponteiros.\n\n\n# O que caracteriza uma fun√ß√£o *callback*?\n\n&gt; Ela √© passada como argumento para outra fun√ß√£o.\n\n1. [ ] Uma fun√ß√£o que chama a si mesma recursivamente.\n1. [ ] Uma fun√ß√£o que √© executada no in√≠cio do programa.\n1. [x] Uma fun√ß√£o passada como par√¢metro para outra.\n1. [ ] Uma fun√ß√£o que aloca mem√≥ria dinamicamente.\n\n\n# No exemplo da fun√ß√£o `calcular`, qual das seguintes op√ß√µes √© verdadeira?\n\n&gt; Considere o papel de `calcular` e das fun√ß√µes `soma`, `subtracao` etc.\n\n- [x] `calcular` √© uma fun√ß√£o de ordem superior.\n- [x] `soma` e `subtracao` s√£o fun√ß√µes *callback*.\n- [ ] `calcular` precisa conhecer a l√≥gica de cada opera√ß√£o.\n- [ ] `soma` e `subtracao` devem ter tipos de retorno diferentes.\n\n\n# Quais das op√ß√µes abaixo s√£o vantagens do uso de `typedef` para ponteiros de fun√ß√£o?\n\n&gt; Pense em legibilidade e clareza do c√≥digo.\n\n- [x] Aumenta a legibilidade e clareza do c√≥digo.\n- [x] Simplifica a assinatura de fun√ß√µes que usam ponteiros de fun√ß√£o.\n- [ ] Impede erros de compila√ß√£o.\n- [ ] Aumenta o desempenho em tempo de execu√ß√£o.\n\n\n# Coloque em ordem as etapas de funcionamento da fun√ß√£o `calcular` com um *callback*.\n\n&gt; Pense na sequ√™ncia de chamadas entre `main`, `calcular` e `operacao`.\n\n1. A fun√ß√£o `main` chama `calcular`, passando uma fun√ß√£o de opera√ß√£o.\n2. `calcular` recebe os par√¢metros e o ponteiro de fun√ß√£o.\n3. `calcular` invoca a fun√ß√£o apontada.\n4. A fun√ß√£o apontada executa o c√°lculo e retorna o resultado.\n5. O resultado √© exibido em `main`.\n\n\n# Sobre o uso de `void *`, marque as afirmativas corretas.\n\n&gt; Ele √© o ponteiro gen√©rico em C.\n\n- [x] Pode armazenar o endere√ßo de qualquer tipo de dado.\n- [x] Precisa ser convertido (cast) antes de ser desreferenciado.\n- [ ] Pode ser desreferenciado diretamente.\n- [ ] Armazena sempre um n√∫mero inteiro, n√£o um endere√ßo.\n\n\n# O que o tipo `size_t` representa em C? \n\n&gt; Ele √© usado para representar quantidades de bytes.\n\n1. [ ] Um tipo de dado usado para caracteres Unicode.\n1. [x] Um tipo sem sinal que representa tamanhos e quantidades de bytes.\n1. [ ] Um ponteiro gen√©rico que aponta para qualquer tipo.\n1. [ ] Um tipo que indica o n√∫mero de elementos em um vetor.",
    "crumbs": [
      "Callbacks"
    ]
  },
  {
    "objectID": "disciplinas/aed2/academic/unidade2/7-funcaohash.html",
    "href": "disciplinas/aed2/academic/unidade2/7-funcaohash.html",
    "title": "Fun√ß√£o Hash",
    "section": "",
    "text": "A fun√ß√£o hash √© usada para mapear uma chave para um valor, gerando um c√≥digo hash que, por sua vez, √© usado para encontrar a localiza√ß√£o de um item em uma estrutura de dados como uma tabela hash.\nflowchart LR\n subgraph s1[\"üîë Chaves\"]\n        A0[\"'ma√ß√£'\"]\n        B0[\"'uva'\"]\n        C0[\"'laranja'\"]\n        D0[\"'banana'\"]\n  end\n subgraph s2[\"‚öôÔ∏è Fun√ß√£o Hash\"]\n  end\n subgraph s3[\"üìä Tabela Hash\"]\n        A2[\"√çndice 0: ‚ùå      \"]\n        B2[\"√çndice 1: 'laranja'\"]\n        C2[\"√çndice 2: 'uva'\"]\n        D2[\"√çndice 3: 'ma√ß√£'\"]\n        E2[\"√çndice 4: 'banana'\"]\n  end\n    A0 ==&gt; s2\n    B0 ==&gt; s2\n    C0 ==&gt; s2\n    D0 ==&gt; s2\n    s2 ==\"h('laranja')=1\"==&gt; B2\n    s2 ==\"h('uva')=2\"==&gt; C2\n    s2 ==\"h('ma√ß√£')=3\"==&gt; D2\n    s2 ==\"h('banana')=4\"==&gt; E2\n\n    classDef box fill:#fff,stroke:#000,color:#000,stroke-width:1px;\n    \n    class A0 box\n    class B0 box\n    class C0 box\n    class D0 box\n    class A2 box\n    class B2 box\n    class C2 box\n    class D2 box\n    class E2 box\n    \n    style s2 stroke:none,fill:#BBDEFB\n    style s1 stroke:none,fill:#FFE0B2\n    style s3 stroke:none,fill:#FFE0B2\n    \n    linkStyle 0 stroke:#D50000,fill:none\n    linkStyle 1 stroke:#00C853,fill:none\n    linkStyle 2 stroke:#2962FF,fill:none\n    linkStyle 4 stroke:#2962FF\n    linkStyle 5 stroke:#00C853,fill:none\n    linkStyle 6 stroke:#D50000,fill:none",
    "crumbs": [
      "Fun√ß√£o Hash"
    ]
  },
  {
    "objectID": "disciplinas/aed2/academic/unidade2/7-funcaohash.html#caracter√≠sticas-da-fun√ß√£o-hash",
    "href": "disciplinas/aed2/academic/unidade2/7-funcaohash.html#caracter√≠sticas-da-fun√ß√£o-hash",
    "title": "Fun√ß√£o Hash",
    "section": "Caracter√≠sticas da Fun√ß√£o Hash",
    "text": "Caracter√≠sticas da Fun√ß√£o Hash\n\nF√°cil de ser calculada;\nDistribui√ß√£o uniforme dos dados;\nMinimiza as colis√µes;\nCapaz de resolver poss√≠veis colis√µes.\n\nA vantagem da tabela hash √© a velocidade de busca, uma fun√ß√£o muito complicada para calcular √© incoveniente, pois pode demorar mais que uma busca em uma √°rvore bin√°ria, por exemplo. Al√©m disso, se a fun√ß√£o n√£o distribui as chaves de maneira uniforme, muitas delas ir√£o se concentrar em um local do vetor, aumentando a probabilidade de colis√µes.",
    "crumbs": [
      "Fun√ß√£o Hash"
    ]
  },
  {
    "objectID": "disciplinas/aed2/academic/unidade2/7-funcaohash.html#m√©todo-da-divis√£o",
    "href": "disciplinas/aed2/academic/unidade2/7-funcaohash.html#m√©todo-da-divis√£o",
    "title": "Fun√ß√£o Hash",
    "section": "M√©todo da Divis√£o",
    "text": "M√©todo da Divis√£o\nNo m√©todo da divis√£o, usamos o resultado do resto da divis√£o do valor da chave pelo tamanho da tabela. \\[h(k) = k \\bmod m\\]\nO ideal √© que \\(m\\) seja um n√∫mero primo e n√£o muito pr√≥ximo de pot√™ncias de \\(2\\).\nPor exemplo, se \\(k=12345\\) e \\(m=101\\), ent√£o \\[h(k) = h(12345)= 12345 \\bmod 101 = 22\\]\nA chave \\(12345\\) deve ser alocada na posi√ß√£o \\(22\\) do vetor de \\(101\\) posi√ß√µes.\n\n\nSe liga! Nem sempre trateremos com chaves inteiras simples como as vistas at√© aqui. Nesses casos, precisamos de um mecanismo para transformar em um valor inteiro antes de processar a fun√ß√£o hash. Veremos isso √† frente.\nEste √© o m√©todo mais simples e f√°cil de gerar um valor de hash. A fun√ß√£o hash divide o valor \\(k\\) (chave) por \\(m\\) (tamanho da tabela) e, em seguida, usa o resto obtido. √â mais adequado que \\(m\\) seja um n√∫mero primo, pois isso pode garantir que as chaves sejam distribu√≠das de forma mais uniforme.\nEmbora simples, o m√©todo da divis√£o leva a um desempenho ruim, uma vez que chaves consecutivas mapeiam para valores de hash consecutivos na tabela de hash.\n\n\n\n\n\n\nNotaExerc√≠cio\n\n\n\nDada a fun√ß√£o hash \\(h(k) = k^2\\bmod 7\\), calcule os valores hash para as chaves \\[4, 17, 13, 35, 25, 11, 2, 10, 32\\].\n\n\n\n\n\n\n\n\nDicaSolu√ß√£o (clique para ver)\n\n\n\n\n\n\n\\(h(4)\\,\\,\\,=\\,\\,\\,4^2\\bmod 7=16\\bmod 7\\,\\,\\,\\,\\,\\,=2\\)\n\\(h(17)=17^2\\bmod 7=289\\bmod 7\\,\\,\\,=2\\)\n\\(h(13)=13^2\\bmod 7=169\\bmod 7\\,\\,\\,=1\\)\n\\(h(35)=35^2\\bmod 7=1225\\bmod 7=0\\)\n\\(h(25)=25^2\\bmod 7=625\\bmod 7\\,\\,\\,=2\\)\n\\(h(11)=11^2\\bmod 7=121\\bmod 7\\,\\,\\,=2\\)\n\\(h(2)\\,\\,\\,=\\,\\,\\,2^2\\bmod 7=4\\bmod 7\\,\\,\\,\\,\\,\\,\\,\\,\\,=4\\)\n\\(h(10)=10^2\\bmod 7=100\\bmod 7\\,\\,\\,=2\\)\n\\(h(32)=32^2\\bmod 7=1024\\bmod 7=2\\)\n\nMuitas colis√µes ocorreram! Era evidente que haveria sobreposi√ß√£o de chaves, pois temos somentes sete espa√ßos.",
    "crumbs": [
      "Fun√ß√£o Hash"
    ]
  },
  {
    "objectID": "disciplinas/aed2/academic/unidade2/7-funcaohash.html#m√©todo-da-multiplica√ß√£o",
    "href": "disciplinas/aed2/academic/unidade2/7-funcaohash.html#m√©todo-da-multiplica√ß√£o",
    "title": "Fun√ß√£o Hash",
    "section": "M√©todo da Multiplica√ß√£o",
    "text": "M√©todo da Multiplica√ß√£o\nNo m√©todo da multiplica√ß√£o, realizamos os seguintes passos:\n\nMultiplicamos a chave (\\(k\\)) por uma constante \\(A\\) entre \\(0\\) e \\(1\\);\nExtra√≠mos a parte fracion√°ria de \\(kA\\);\nMultiplicamos esse valor por \\(m\\) (tamanho da tabela);\nArredondamos para baixo;\n\nOu seja,\n\\[h(k) = \\lfloor m (kA \\bmod 1) \\rfloor, \\text{ com } 0 &lt; A &lt; 1\\]\nPor exemplo, considere \\(k = 123\\), \\(m = 1000\\), e \\(A \\approx 0,618\\).\n\\[h(k) = \\lfloor 1000 (123 \\cdot 0,618 \\bmod 1) \\rfloor=\\lfloor 1000 (76,014 \\bmod 1) \\rfloor=\\lfloor 1000\\cdot 0,014 \\rfloor=14\\]\nA vantagem do m√©todo de multiplica√ß√£o √© que ele pode trabalhar com qualquer valor entre 0 e 1.\n\n\nSe liga! O m√©todo de multiplica√ß√£o √© geralmente adequado quando o tamanho da tabela √© uma pot√™ncia de dois.\n\n\n\n\n\n\nNotaExerc√≠cio\n\n\n\nSeja a chave \\(k = 12345\\), a constante \\(A = 0,357840\\) e o tamanho da tabela \\(m = 100\\), calcule o valor hash usando o m√©todo da multiplica√ß√£o.\n\n\n\n\n\n\n\n\nDicaSolu√ß√£o (clique para ver)\n\n\n\n\n\n\\[h(k) = \\lfloor m (kA \\bmod 1) \\rfloor\\] \\(h(12345) = \\lfloor 100 (12345\\cdot 0,357840 \\bmod 1) \\rfloor=\\lfloor 100 (4417,5348 \\bmod 1) \\rfloor=\\lfloor 100 (0,5348) \\rfloor=\\lfloor 53,48 \\rfloor=53\\)",
    "crumbs": [
      "Fun√ß√£o Hash"
    ]
  },
  {
    "objectID": "disciplinas/aed2/academic/unidade2/7-funcaohash.html#hashing-universal",
    "href": "disciplinas/aed2/academic/unidade2/7-funcaohash.html#hashing-universal",
    "title": "Fun√ß√£o Hash",
    "section": "Hashing Universal",
    "text": "Hashing Universal\nO hash universal tenta resolver o problema das colis√µes usando uma fam√≠lia de fun√ß√µes de hash, \\(\\mathcal{H}\\), que possui uma propriedade matem√°tica crucial:\n\nPara quaisquer duas chaves distintas, \\(k_1\\) e \\(k_2\\), a probabilidade de que a fun√ß√£o de hash \\(h \\in \\mathcal{H}\\) escolhida aleatoriamente cause uma colis√£o √© no m√°ximo igual √† probabilidade de colis√£o aleat√≥ria, que √© \\(1/m\\), onde \\(m\\) √© o n√∫mero de posi√ß√µes na tabela hash.\n\nUma das fam√≠lias universais mais usadas para chaves que s√£o n√∫meros inteiros e uma tabela de tamanho \\(m\\) √© definida da seguinte forma:\nSeja \\(p\\) um n√∫mero primo maior que qualquer chave poss√≠vel, e \\(m\\) o tamanho da tabela hash. A fam√≠lia \\(\\mathcal{H}\\) √© o conjunto de fun√ß√µes \\(h_{a,b}\\) dadas pela f√≥rmula: \\[h_{a,b}(k) = ((ak + b) \\bmod p) \\bmod m\\]\nOnde \\(a\\) e \\(b\\) s√£o par√¢metros inteiros aleat√≥rios escolhidos no in√≠cio, com \\(a\\in[1, p-1]\\) e \\(b\\in[0, p-1]\\).\nOs par√¢metros aleat√≥rios ajudam a dispersar o valor da chave. J√° a opera√ß√£o de m√≥dulo por um primo \\(p\\) ajuda a garantir que a distribui√ß√£o do resultado seja uniforme no intervalo \\([0, p-1]\\). Finalmente, o resultado final √© mapeado para o √≠ndice da tabela hash, no intervalo \\([0, m-1]\\).\nPor exemplo, digamos uma tabela com \\(m=10\\) slots e escolhamos \\(p=103\\).\n\nSorteamos \\(a\\) entre \\(1\\) e \\(p-1\\), ou seja, no intervalo \\([1, 102]\\)\nSorteamos \\(b\\) entre \\(0\\) e \\(p-1\\), ou seja, no intervalo \\([0, 102]\\)\n\nDigamos que \\(a=5\\) e \\(b=13\\), ent√£o nossa fun√ß√£o sorteada da fam√≠lia universal ser√°: \\[h_{5,13}(k)=((5k+13)\\bmod103)\\bmod 10\\]\nVamos calcular alguns valores de hash para fixa√ß√£o.\n\n\\(h(4)\\,\\,\\,=\\,\\,\\,((5\\cdot4+13)\\bmod103)\\bmod 10=\\,\\,\\,(33\\bmod103)\\bmod 10=33 \\bmod 10=3\\)\n\\(h(17)=((5\\cdot17+13)\\bmod103)\\bmod 10=\\,\\,\\,(98\\bmod103)\\bmod 10= 98\\bmod 10=8\\)\n\\(h(25)=((5\\cdot25+13)\\bmod103)\\bmod 10=(138\\bmod103)\\bmod 10=35\\bmod 10=5\\)\n\\(h(32)=((5\\cdot32+13)\\bmod103)\\bmod 10=(173\\bmod103)\\bmod 10=70\\bmod 10=0\\)\n\nMesmo com os melhores m√©todos, √© imposs√≠vel evitar colis√µes. Quando acontece, devemos trat√°-la de modo que o desempenho da busca n√£o seja muito afetado. No entanto, antes de estudarmos os tratamentos de coli√ß√µes, iremos abordar as estrat√©gias para mapeamento de chaves em inteiros.",
    "crumbs": [
      "Fun√ß√£o Hash"
    ]
  },
  {
    "objectID": "disciplinas/aed2/academic/unidade2/7-funcaohash.html#estrat√©gias-para-mapeamento",
    "href": "disciplinas/aed2/academic/unidade2/7-funcaohash.html#estrat√©gias-para-mapeamento",
    "title": "Fun√ß√£o Hash",
    "section": "Estrat√©gias para Mapeamento",
    "text": "Estrat√©gias para Mapeamento\nQuando falamos em mapeamento de chaves em inteiros, estamos nos referindo a um pr√©-processamento que transforma uma chave (como uma string ou um n√∫mero muito grande) em um inteiro mais adequado para ser usado por uma fun√ß√£o de hash.\nEmbora seja poss√≠vel criar suas pr√≥prias estrat√©gias, apresentamos a seguir alguns m√©todos cl√°ssicos encontrados na literatura.\n\nChaves do tipo string\nOs m√©todos cl√°ssicos para tratar strings usam o fato de cada letra ter um inteiro correspondente na tabela ASCII.\n\nSoma\nMuitas vezes, as chaves que estamos trabalhando s√£o strings. Uma forma simples de convert√™-las em inteiros √© somar os valores ASCII de cada caractere: \\[k=\\sum_{i=0}^{n-1}s[i]=s[0]+s[1]+s[2]+\\cdots+s[n-1]\\]\nonde \\(n\\) √© o tamanho da palavra.\nPor exemplo, a palavra ‚ÄúPAI‚Äù (P = 80, A = 65 e I = 73): \\[k=\\sum_{i=0}^{3-1}s[i]=\\sum_{i=0}^{2}s[i]=s[0]+s[1]+s[2]=80+65+73=218\\]\nEsse m√©todo √© simples, mas apresenta m√° distribui√ß√£o, ou seja, palavras com as mesmas letras em ordem diferente geram o mesmo valor.\n\n\nMultiplica√ß√£o Polinomial\nUm m√©todo mais robusto √© o da multiplica√ß√£o polinomial. Aqui, tratamos a string como um n√∫mero em uma base \\(\\beta\\) (Œ≤ (geralmente um n√∫mero primo pequeno): \\[k=s[0]\\cdot\\beta^{n-1}+s[1]\\cdot\\beta^{n-2}+\\cdots+s[n-1]\\cdot\\beta^{0}\\]\nPor exemplo, a palavra ‚ÄúPAI‚Äù (P = 80, A = 65 e I = 73) e \\(\\beta=13\\): \\[k=s[0]\\cdot 13^{3-1}+s[1]\\cdot 13^{3-2}+\\cdots+s[2]\\cdot 13^{0}=80\\cdot13^2+65\\cdot13^1+73\\cdot13^0=14438\\]\n\n\nSe liga! A multiplica√ß√£o por um n√∫mero primo ajuda a espalhar os valores de forma mais uniforme do que se us√°ssemos um n√∫mero composto.\nEssa t√©cnica √© superior √† soma simples, pois considera a ordem dos caracteres. Para palavras como ‚Äúcama‚Äù e ‚Äúmaca‚Äù, a soma simples ir√° retornar os mesmos valores, enquanto que a multiplica√ß√£o polinomial n√£o.\nExemplo simples:\n\n\\(BA : 66\\cdot13^1 + 65\\cdot13^0 = 923\\).\n\\(AB : 65\\cdot13^1 + 66\\cdot13^0 = 911\\).\n\nDessa forma, ‚ÄúBA‚Äù e ‚ÄúAB‚Äù produzem resultados distintos, evitando colis√µes triviais.\n\n\n\nChaves do tipo int grandes\nQuando lidamos com inteiros muito grandes, precisamos reduzi-los para evitar estouro de capacidade (overflow) ou para encaix√°-los em um intervalo menor. A seguir, apresentamos tr√™s m√©todos comuns: dobramento (folding), XOR e quadrado central (mid-square).\n\nDobramento (Folding)\nConsiste em dividir a chave em partes menores e, em seguida, som√°-las ou aplicar XOR entre elas para gerar um n√∫mero reduzido. Por exemplo, suponha \\(k = 83.529.170\\), vamos dividir a chave assim:\n\n\\(k_1 = 835\\)\n\\(k_2 = 291\\)\n\\(k_3 = 70\\)\n\nO dobramento por soma resulta em \\(k_1+k_2+k_3=835+291+70=1196\\).\nNo dobramento por XOR, as partes s√£o combinadas usando a opera√ß√£o l√≥gica OU exclusivo (XOR), muito comum em fun√ß√µes de hash criptogr√°ficas. Primeiro, convertemos as partes para bin√°rio (aqui, usando 10 bits para simplificar):\n\n\n\nParte\nDecimal\nBin√°rio (10 bits)\n\n\n\n\n\\(k_1\\)\n835\n1101000011\n\n\n\\(k_2\\)\n291\n0100100011\n\n\n\\(k_3\\)\n70\n0001000110\n\n\n\nRealizamos a opera√ß√£o XOR bit a bit entre as partes. \\[k_1 \\oplus k_2 \\oplus k_3\\]\\[\\begin{array}{r l l} & 1101000011 & (k_1) \\\\ \\oplus & 0100100011 & (k_2) \\\\ \\hline & 1001100000 & (k_1 \\oplus k_2) \\\\ \\oplus & 0001000110 & (k_3) \\\\ \\hline & \\mathbf{1000100110} & (\\text{Resultado}) \\end{array}\\]\nTransformando 1000100110 de volta para decimal: \\[1000100110_2=512+64+8+4+2=590\\]\nO m√©todo XOR tende a preservar melhor as caracter√≠sticas de todas as partes da chave, ainda que seja um pouco mais complexo de implementar do que a soma simples.\n\n\nMid-Square\nO m√©todo do quadrado central √© uma t√©cnica cl√°ssica de extra√ß√£o. A chave √© elevada ao quadrado, e ent√£o o hash √© formado pelos d√≠gitos centrais do resultado. A quantidade de d√≠gitos extra√≠dos √© indicada por \\(d\\).\nApesar de ser simples, ele pode gerar um c√≥digo hash razoavelmente bem distribu√≠do. Como exemplo, considere uma \\(k=931\\) e \\(d=3\\). \\[k^2=931^2=866761\\] Assim, podemos selecionar \\(676\\), ou at√© \\(667\\).\nEsses m√©todos apresentados podem ser combinados ou at√© mesmo utilizados como substitutos de uma fun√ß√£o hash. Em sistemas mais complexos, essas abordagens costumam ser empregadas como etapas auxiliares dentro de fun√ß√µes de hash mais sofisticadas.\n\nNesta unidade, voc√™ aprendeu\n‚úÖ quais caracter√≠sticas uma fun√ß√£o hash deve possuir\n‚úÖ met√≥dos cl√°ssicos para definir fun√ß√µes hash\n‚úÖ como mapear palavras e grandes n√∫meros em chaves\n\n# O que √© uma fun√ß√£o hash?\n\n&gt; Pense no papel dela dentro de uma tabela de dispers√£o.\n\n1. [ ] Um algoritmo que ordena elementos de forma crescente.\n1. [x] Uma fun√ß√£o que transforma uma chave em um √≠ndice de armazenamento.\n1. [ ] Uma t√©cnica de compress√£o de dados.\n1. [ ] Uma estrutura de dados hier√°rquica.\n\n\n# Quais s√£o caracter√≠sticas desej√°veis de uma boa fun√ß√£o hash? \n\n&gt; Elas influenciam diretamente na efici√™ncia e distribui√ß√£o das chaves.\n\n- [x] Ser f√°cil de calcular.\n- [x] Produzir distribui√ß√£o uniforme dos dados.\n- [x] Minimizar colis√µes.\n- [ ] Depender de opera√ß√µes aleat√≥rias complexas.\n\n\n# No m√©todo da divis√£o, qual das op√ß√µes expressa corretamente a fun√ß√£o hash? \n\n&gt; Observe a opera√ß√£o usada para gerar o √≠ndice.\n\n1. [x] $h(k) = k \\bmod m$\n1. [ ] $h(k) = k / m$\n1. [ ] $h(k) = k^2 \\bmod m$\n1. [ ] $h(k) = \\sqrt{k} \\bmod m$\n\n\n# Por que √© ideal escolher $m$ como um n√∫mero primo no m√©todo da divis√£o? \n\n&gt; Isso afeta a forma como os valores se espalham na tabela.\n\n1. [x] Porque ajuda a distribuir as chaves de forma mais uniforme.\n1. [ ] Porque facilita o c√°lculo de ra√≠zes quadradas.\n1. [ ] Porque garante que n√£o ocorram colis√µes.\n1. [ ] Porque simplifica a implementa√ß√£o de XOR.\n\n\n# Considere $h(k) = k \\bmod 101$. Qual o valor de $h(12345)$?\n\n&gt; Aplique o operador m√≥dulo diretamente.\n\n1. [ ] 12\n1. [x] 22\n1. [ ] 45\n1. [ ] 99\n\n\n# Quais s√£o as etapas do m√©todo da multiplica√ß√£o?\n\n&gt; Relembre a ordem dos c√°lculos realizados.\n\n1. Multiplicar a chave ($k$) por uma constante $A$ entre 0 e 1.  \n2. Extrair a parte fracion√°ria de $kA$.  \n3. Multiplicar o resultado por $m$.  \n4. Arredondar para baixo.\n\n\n# No m√©todo da multiplica√ß√£o, qual √© uma vantagem importante? \n\n&gt; Observe a observa√ß√£o sobre o tamanho da tabela.\n\n1. [ ] √â ideal quando $m$ √© primo.  \n1. [x] √â adequado quando o tamanho da tabela √© uma pot√™ncia de dois.  \n1. [ ] Garante aus√™ncia total de colis√µes.  \n1. [ ] Dispensa o uso do operador m√≥dulo.\n\n\n# O que caracteriza o hashing universal? \n\n&gt; Est√° relacionado √† escolha aleat√≥ria de fun√ß√µes.\n\n1. [ ] Usa apenas o m√©todo da divis√£o.  \n1. [ ] Calcula o hash como a m√©dia de v√°rias fun√ß√µes.  \n1. [x] Escolhe aleatoriamente uma fun√ß√£o de uma fam√≠lia de fun√ß√µes que minimiza colis√µes.  \n1. [ ] Utiliza constantes irracionais para dispers√£o.\n\n\n# A f√≥rmula do hashing universal $h_{a,b}(k)=((ak+b)\\bmod p)\\bmod m$ cont√©m quais par√¢metros aleat√≥rios?\n\n&gt; Eles s√£o escolhidos no in√≠cio do processo.\n\n- [x] $a$\n- [x] $b$\n- [ ] $p$\n- [ ] $m$\n\n\n# Quais s√£o m√©todos cl√°ssicos para transformar _strings_ em inteiros? \n\n&gt; Pense nos dois tipos mencionados no texto.\n\n- [x] Soma dos valores ASCII.  \n- [x] Multiplica√ß√£o polinomial.  \n- [ ] Hashing universal.  \n- [ ] M√©todo da divis√£o.\n\n\n# Por que a multiplica√ß√£o polinomial √© superior √† soma simples? \n\n&gt; Compare o que cada m√©todo considera.\n\n1. [x] Porque considera a ordem dos caracteres.  \n1. [ ] Porque ignora os valores ASCII.  \n1. [ ] Porque usa n√∫meros compostos.  \n1. [ ] Porque sempre gera n√∫meros primos.\n\n\n# Se $\\beta = 13$, qual √© o valor de $k$ para a palavra \"BA\"? \n\n&gt; Use a f√≥rmula da multiplica√ß√£o polinomial.\n\n1. [ ] 911  \n1. [x] 923  \n1. [ ] 1213  \n1. [ ] 1001  \n\n\n# No m√©todo de dobramento (folding), o que fazemos com a chave?\n\n&gt; Veja como ela √© reduzida.\n\n1. [x] Dividimos em partes menores e as combinamos por soma ou XOR.  \n1. [ ] Multiplicamos por um n√∫mero primo e aplicamos m√≥dulo.  \n1. [ ] Extra√≠mos os d√≠gitos centrais do quadrado da chave.  \n1. [ ] Aplicamos o logaritmo da chave.\n\n\n# No exemplo do m√©todo XOR, qual foi o resultado decimal final? \n\n&gt; Observe a convers√£o final do n√∫mero bin√°rio.\n\n1. [ ] 512  \n1. [ ] 5900  \n1. [x] 590  \n1. [ ] 676\n\n\n# O m√©todo do quadrado central (mid-square) consiste em:\n\n&gt; Ele √© simples, mas eficaz.\n\n1. [ ] Somar as partes da chave.  \n1. [x] Elevar a chave ao quadrado e extrair os d√≠gitos centrais.  \n1. [ ] Dividir a chave por um n√∫mero primo.  \n1. [ ] Converter a chave em bin√°rio e aplicar XOR.\n\n\n# Quais m√©todos s√£o indicados para mapear inteiros muito grandes? \n\n&gt; Lembre dos tr√™s apresentados no texto.\n\n- [x] Dobramento (folding)  \n- [x] XOR  \n- [x] Quadrado central (mid-square)  \n- [ ] Divis√£o inteira simples",
    "crumbs": [
      "Fun√ß√£o Hash"
    ]
  },
  {
    "objectID": "disciplinas/aed2/academic/unidade2/8-colisoes.html",
    "href": "disciplinas/aed2/academic/unidade2/8-colisoes.html",
    "title": "Tratamento de Colis√µes",
    "section": "",
    "text": "Sabemos que uma colis√£o ocorre quando a fun√ß√£o hash produz o mesmo valor para duas ou mais chaves distintas. Isto √©: \\[h(k1) = h(k2)\\]\nColis√µes s√£o praticamente inevit√°veis, por isso devemos trat√°-las. As principais abordagens s√£o endere√ßamento aberto e encadeamento separado.",
    "crumbs": [
      "Tratamento de Colis√µes"
    ]
  },
  {
    "objectID": "disciplinas/aed2/academic/unidade2/8-colisoes.html#endere√ßamento-aberto",
    "href": "disciplinas/aed2/academic/unidade2/8-colisoes.html#endere√ßamento-aberto",
    "title": "Tratamento de Colis√µes",
    "section": "Endere√ßamento aberto",
    "text": "Endere√ßamento aberto\nA t√©cnica de endere√ßamento aberto tenta resolver o problema de colis√£o buscando um outro lugar vazio para armazenar a chave que colidiu. As maneiras principais de sondar um espa√ßo vazio s√£o:\n\nSondagem linear;\nSondagem quadr√°tica;\nDuplo hash\n\n\nSondagem linear\nA sondagem linear procura pela pr√≥xima posi√ß√£o vazia do vetor. A fun√ß√£o de hash possui uma nova vari√°vel iterativa que permitir√° a procura por esse lugar vazio: \\[h(k,i) = (h'(k)+i)\\bmod m\\] onde \\(i=0,1,2,3,\\ldots\\)\nSempre que ocorre uma colis√£o, esta vari√°vel (\\(i\\)) √© incrementada em uma unidade.\nPor exemplo, considere o vetor abaixo:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nslot\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n\nchave\n‚ùå\n21\n42\n63\n‚ùå\n‚ùå\n‚ùå\n‚ùå\n‚ùå\n69\n\n\n\n\nE a fun√ß√£o de hash auxiliar \\(h'(k)=k\\bmod 10\\).\nVamos adicionar a chave 81:\n\n\\(h(81,0) = (h'(81) + 0) \\bmod 10 = (1+0) \\bmod 10 = 1\\), colis√£o com 21\n\\(h(81,1) = (h'(81) + 1) \\bmod 10 = (1+1) \\bmod 10 = 2\\), colis√£o com 42\n\\(h(81,2) = (h'(81) + 2) \\bmod 10 = (1+2) \\bmod 10 = 3\\), colis√£o com 63\n\\(h(81,3) = (h'(81) + 3) \\bmod 10 = (1+3) \\bmod 10 = 4\\)\n\nComo a posi√ß√£o 4 est√° vazia, a chave 81 ser√° alocada l√°.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nslot\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n\nchave\n‚ùå\n21\n42\n63\n81\n‚ùå\n‚ùå\n‚ùå\n‚ùå\n69\n\n\n\n\n\n\nSondagem quadr√°tica\nA sondagem quadr√°tica procura pela pr√≥xima posi√ß√£o vazia usando uma fun√ß√£o quadr√°tica. \\[h(k,i) = (h'(k)+c_1i+c_2i^2)\\bmod m\\] onde \\(c_1 e c_2\\) s√£o constantes escolhidas e \\(i=0,1,2,3,\\ldots\\)\nConsidere o exemplo anterior com sondagem quadr√°tica. Vamos escolher \\(c_1=0\\) e \\(c_2=1\\).\n\n\\(h(81,0) = (h'(81) + 0^2) \\bmod 10 = (1+0) \\bmod 10 = 1\\), colis√£o com 21\n\\(h(81,1) = (h'(81) + 1^2) \\bmod 10 = (1+1) \\bmod 10 = 2\\), colis√£o com 42\n\\(h(81,2) = (h'(81) + 2^2) \\bmod 10 = (1+4) \\bmod 10 = 5\\)\n\nComo a posi√ß√£o 5 est√° vazia, a chave 81 ser√° alocada l√°.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nslot\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n\nchave\n‚ùå\n21\n42\n63\n‚ùå\n81\n‚ùå\n‚ùå\n‚ùå\n69\n\n\n\n\n\n\nDuplo hash\nComo o nome sugere, o tratamento de colis√£o usa duas fun√ß√µes hash (\\(h_1\\) e \\(h_2\\)). \\[h(k,i) = (h_1(k) + i\\cdot h_2(k)) \\bmod m\\] onde \\(i=0,1,2,3,\\ldots\\)\nPor exemplo, suponha \\(h_1(k) = k \\bmod 10\\) e \\(h_2(k) = 5 ‚àí (k \\bmod 5)\\).\nNo exemplo anterior teremos:\n\n\\(h(81,0) = (h_1(81) + 0 \\cdot h_2(81)) \\bmod 10 = (1+0) \\bmod 10 = 1\\), colis√£o com 21\n\\(h(81,1) = (h_1(81) + 1 \\cdot h_2(81)) \\bmod 10 = (1 + 4) \\bmod 10 = 5\\)\n\nOu seja,\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nslot\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n\nchave\n‚ùå\n21\n42\n63\n‚ùå\n81\n‚ùå\n‚ùå\n‚ùå\n69\n\n\n\n\nAbaixo, listamos mais um exemplo considerando as tr√™s abordagens apresentadas:\n\nchaves: 15, 22, 7, 13, 25 e 14\ntamanho: 7 slots\n\n\nLinearQuadr√°ticoDuplo Hash\n\n\n\\[h'(k)=k \\bmod 7\\] \\[h(k,i)=(h'(k)+i) \\bmod 7\\]\nChave 15 \\(\\rightarrow h'(15)=15 \\bmod 7=1\\)\n\n\\(h(15,0)=(h'(15)+0) \\bmod 7=(1+0) \\bmod 7=1\\)\n\n\nChave 22 \\(\\rightarrow h'(22)=22 \\bmod 7=1\\)\n\n\\(h(22,0)=(h'(22)+0) \\bmod 7=(1+0) \\bmod 7=1\\), ocupado\n\\(h(22,1)=(h'(22)+1) \\bmod 7=(1+1) \\bmod 7=2\\)\n\n\nChave 7 \\(\\rightarrow h'(7)=7 \\bmod 7=0\\)\n\n\\(h(7,0)=(h'(7)+0) \\bmod 7=(0+0) \\bmod 7=0\\)\n\n\nChave 13 \\(\\rightarrow h'(13)=13 \\bmod 7=6\\)\n\n\\(h(13,0)=(h'(13)+0) \\bmod 7=(6+0) \\bmod 7=6\\)\n\n\nChave 25 \\(\\rightarrow h'(25)=25 \\bmod 7=4\\)\n\n\\(h(25,0)=(h'(25)+0) \\bmod 7=(4+0) \\bmod 7=4\\)\n\n\nChave 14 \\(\\rightarrow h'(14)=14 \\bmod 7=0\\)\n\n\\(h(14,0)=(h'(14)+0) \\bmod 7=(0+0) \\bmod 7=0\\), ocupado\n\\(h(14,1)=(h'(14)+1) \\bmod 7=(0+1) \\bmod 7=1\\), ocupado\n\\(h(14,2)=(h'(14)+2) \\bmod 7=(0+2) \\bmod 7=2\\), ocupado\n\\(h(14,3)=(h'(14)+3) \\bmod 7=(0+3) \\bmod 7=3\\)\n\n\nResultado:\n\n\n\n\nslot\n0\n1\n2\n3\n4\n5\n6\n\n\n\n\nchave\n7\n15\n22\n14\n25\n‚ùå\n13\n\n\n\n\n\n\n\\[h'(k)=k \\bmod 7\\] \\[h(k,i)=(h'(k)+i+i^2) \\bmod 7\\]\nChave 15 \\(\\rightarrow h'(15)=15 \\bmod 7=1\\)\n\n\\(h(15,0)=(h'(15)+0+0^2) \\bmod 7=(1+0) \\bmod 7=1\\)\n\n\nChave 22 \\(\\rightarrow h'(22)=22 \\bmod 7=1\\)\n\n\\(h(22,0)=(h'(22)+0+0^2) \\bmod 7=(1+0) \\bmod 7=1\\), ocupado\n\\(h(22,1)=(h'(22)+1+1^2) \\bmod 7=(1+2) \\bmod 7=3\\)\n\n\nChave 7 \\(\\rightarrow h'(7)=7 \\bmod 7=0\\)\n\n\\(h(7,0)=(h'(7)+0+0^2) \\bmod 7=(0+0) \\bmod 7=0\\)\n\n\nChave 13 \\(\\rightarrow h'(13)=13 \\bmod 7=6\\)\n\n\\(h(13,0)=(h'(13)+0+0^2) \\bmod 7=(6+0) \\bmod 7=6\\)\n\n\nChave 25 \\(\\rightarrow h'(25)=25 \\bmod 7=4\\)\n\n\\(h(25,0)=(h'(25)+0+0^2) \\bmod 7=(4+0) \\bmod 7=4\\)\n\n\nChave 14 \\(\\rightarrow h'(14)=14 \\bmod 7=0\\)\n\n\\(h(14,0)=(h'(14)+0+0^2) \\bmod 7=(0+0) \\bmod 7=0\\), ocupado\n\\(h(14,1)=(h'(14)+1+1^2) \\bmod 7=(0+2) \\bmod 7=2\\)\n\n\nResultado:\n\n\n\n\nslot\n0\n1\n2\n3\n4\n5\n6\n\n\n\n\nchave\n7\n15\n14\n22\n25\n‚ùå\n13\n\n\n\n\n\n\n\\[h_1(k)=k \\bmod 7 \\qquad h_2(k) = 1 + (k \\bmod 6)\\] \\[h(k,i)=(h_1(k)+ih_2(k)) \\bmod 7\\]\nChave 15 \\(\\rightarrow h_1(15)=15 \\bmod 7=1\\)\n\n\\(h(15,0)=(h_1(15)+0\\cdot h_2(15)) \\bmod 7=(1+0) \\bmod 7=1\\)\n\n\nChave 22 \\(\\rightarrow h_1(22)=22 \\bmod 7=1\\) e \\(h_2(22)=1+(22 \\bmod 6)=5\\)\n\n\\(h(22,0)=(h_1(22)+0\\cdot h_2(22)) \\bmod 7=(1+0) \\bmod 7=1\\), ocupado\n\\(h(22,1)=(h_1(22)+1\\cdot h_2(22)) \\bmod 7=(1+5) \\bmod 7=6\\)\n\n\nChave 7 \\(\\rightarrow h_1(7)=7 \\bmod 7=0\\)\n\n\\(h(7,0)=(h_1(7)+0\\cdot h_2(7)) \\bmod 7=(0+0) \\bmod 7=0\\)\n\n\nChave 13 \\(\\rightarrow h_1(13)=13 \\bmod 7=6\\) e \\(h_2(13)=1+(13 \\bmod 6)=2\\)\n\n\\(h(13,0)=(h_1(13)+0\\cdot h_2(13)) \\bmod 7=(6+0) \\bmod 7=6\\), ocupado\n\\(h(13,1)=(h_1(13)+1\\cdot h_2(13)) \\bmod 7=(6+2) \\bmod 7=1\\), ocupado\n\\(h(13,2)=(h_1(13)+2\\cdot h_2(13)) \\bmod 7=(6+4) \\bmod 7=3\\)\n\n\nChave 25 \\(\\rightarrow h_1(25)=25 \\bmod 7=4\\)\n\n\\(h(25,0)=(h_1(25)+0\\cdot h_2(25)) \\bmod 7=(4+0) \\bmod 7=4\\)\n\n\nChave 14 \\(\\rightarrow h_1(14)=14 \\bmod 7=0\\) e \\(h_2(14)=1+(14 \\bmod 6)=3\\)\n\n\\(h(14,0)=(h_1(14)+0\\cdot h_2(14)) \\bmod 7=(0+0) \\bmod 7=0\\), ocupado\n\\(h(14,1)=(h_1(14)+1\\cdot h_2(14)) \\bmod 7=(0+3) \\bmod 7=3\\), ocupado\n\\(h(14,2)=(h_1(14)+2\\cdot h_2(14)) \\bmod 7=(0+6) \\bmod 7=6\\), ocupado\n\\(h(14,3)=(h_1(14)+3\\cdot h_2(14)) \\bmod 7=(0+9) \\bmod 7=2\\)\n\n\nResultado:\n\n\n\n\nslot\n0\n1\n2\n3\n4\n5\n6\n\n\n\n\nchave\n7\n15\n14\n13\n25\n‚ùå\n22",
    "crumbs": [
      "Tratamento de Colis√µes"
    ]
  },
  {
    "objectID": "disciplinas/aed2/academic/unidade2/8-colisoes.html#encadeamento-separado",
    "href": "disciplinas/aed2/academic/unidade2/8-colisoes.html#encadeamento-separado",
    "title": "Tratamento de Colis√µes",
    "section": "Encadeamento separado",
    "text": "Encadeamento separado\nA t√©cnica de encadeamento separado √© bastante simples. Ao inv√©s de tratar a colis√£o procurando um lugar vazio, iremos colocar as colis√µes em uma lista encadeada. Logo, n√£o teremos um vetor de chaves, mas sim um vetor de ponteiros que apontam para listas encadeadas separadamente.\n\n\n\n\n\nflowchart LR\n subgraph s1[\"üîë Chaves\"]\n        A0@{ label: \"'ma√ß√£'\" }\n        B0@{ label: \"'uva'\" }\n        C0@{ label: \"'laranja'\" }\n        D0@{ label: \"'banana'\" }\n        E0@{ label: \"'morango'\" }\n  end\n subgraph s2[\"‚öôÔ∏è Fun√ß√£o Hash\"]\n  end\n subgraph s3[\"üìä Tabela Hash\"]\n        A2[\"√çndice 0: ‚ùå\"]\n        B2[\"√çndice 1: üîó\"]\n        C2[\"√çndice 2: üîó\"]\n        D2[\"√çndice 3: üîó\"]\n        E2[\"√çndice 4: üîó\"]\n  end\n subgraph s4[\" \"]\n        C1@{ label: \"üéØ 'uva'\" }\n        B1@{ label: \"üéØ 'laranja'\" }\n        A1@{ label: \"üéØ 'ma√ß√£'\" }\n        D1@{ label: \"üéØ 'banana'\" }\n        E1@{ label: \"üéØ 'morango'\" }\n        n1[\"NULL\"]\n        n2[\"NULL\"]\n        n3[\"NULL\"]\n        n4[\"NULL\"]\n  end\n    A0 ==&gt; s2\n    B0 ==&gt; s2\n    C0 ==&gt; s2\n    D0 ==&gt; s2\n    E0 ==&gt; s2\n    s2 ==&gt; B2 & C2 & D2 & E2\n    B2 -.- C1\n    C2 -.- B1\n    D2 -.- A1\n    E2 -.- D1\n    A1 --&gt; E1\n    C1 --&gt; n1\n    B1 --&gt; n2\n    E1 --&gt; n3\n    D1 --&gt; n4\n\n    A0@{ shape: rect}\n    B0@{ shape: rect}\n    C0@{ shape: rect}\n    D0@{ shape: rect}\n    E0@{ shape: rect}\n    B2@{ shape: rect}\n    C2@{ shape: rect}\n    D2@{ shape: rect}\n    E2@{ shape: rect}\n    C1@{ shape: subproc}\n    B1@{ shape: subproc}\n    A1@{ shape: subproc}\n    D1@{ shape: subproc}\n    E1@{ shape: subproc}\n    n1@{ shape: subproc}\n    n2@{ shape: subproc}\n    n3@{ shape: subproc}\n    n4@{ shape: subproc}\n     A0:::box\n     B0:::box\n     C0:::box\n     D0:::box\n     E0:::box\n     A2:::box\n     B2:::box\n     C2:::box\n     D2:::box\n     E2:::box\n     n1:::NULL_NODE\n     n2:::NULL_NODE\n     n3:::NULL_NODE\n     n4:::NULL_NODE\n    classDef box fill:#fff,stroke:#000,color:#000,stroke-width:1px\n    classDef NULL_NODE fill:#F5F5F5, stroke:#BDBDBD, color:#757575, stroke-dasharray: 5 5\n    style s2 stroke:none,fill:#BBDEFB\n    style s1 stroke:none,fill:#FFE0B2\n    style s3 stroke:none,fill:#FFE0B2\n    style s4 stroke:none,fill:transparent\n    linkStyle 0 stroke:#D50000,fill:none\n    linkStyle 1 stroke:#00C853,fill:none\n    linkStyle 2 stroke:#2962FF,fill:none\n    linkStyle 4 stroke:#D50000,fill:none\n    linkStyle 5 stroke:#00C853,fill:none\n    linkStyle 6 stroke:#2962FF,fill:none\n    linkStyle 7 stroke:#D50000,fill:none\n\n\n\n\n\n\nNo exemplo anterior, quando houve a colis√£o da chave 81 com 21, a posi√ß√£o 1 iria apontar para uma lista ligada com dois componentes.\n\n\n\n\n\n\nflowchart TD\n subgraph s1[\"Array\"]\n        A0[\"‚ùå\"]\n        A1[\"prt_1\"]\n        A2[\"prt_2\"]\n        A3[\"prt_3\"]\n        A4[\"‚ùå\"]\n        A5[\"‚ùå\"]\n        A6[\"‚ùå\"]\n        A7[\"‚ùå\"]\n        A8[\"‚ùå\"]\n        A9[\"prt_9\"]\n  end\n    A1 -.-&gt; B1[\"21\"]\n    B1 --&gt; B2[\"81\"]\n    A2 -.-&gt; B3[\"42\"]\n    A3 -.-&gt; B4[\"63\"]\n    A9 -.-&gt; B5[\"69\"]\n    B2 --&gt; n1[\"Filled Circle\"]\n    B3 --&gt; n2[\"Filled Circle\"]\n    B4 --&gt; n3[\"Filled Circle\"]\n    B5 --&gt; n4[\"Filled Circle\"]\n\n    n1@{ shape: f-circ}\n    n2@{ shape: f-circ}\n    n3@{ shape: f-circ}\n    n4@{ shape: f-circ}\n    style A1 fill:#fff\n    style A2 fill:#fff\n    style A3 fill:#fff\n    style A9 fill:#fff\n    style B1 fill:#fff\n    style B2 fill:#fff\n    style B3 fill:#fff\n    style B4 fill:#fff\n    style B5 fill:#fff\n\n\n\n\nFigure¬†1: Ilustra√ß√£o de tratamento de colis√£o usando listas ligadas. Cada slot aponta para a cabe√ßa de uma lista.\nQuando uma colis√£o ocorre, o elemento √© adicionado √† lista correspondente.\n\n\n\n\n\n\n\n\n\n\n\nNoteExerc√≠cio\n\n\n\nUse a abordagem de encadeamento separado para criar uma tabela hash com as chaves \\[k = \\{15, 22, 7, 13, 25, 14, 1, 8, 2, 9, 3, 10, 4, 11, 5, 6, 20, 21, 28\\}.\\] Considere a fun√ß√£o de hash \\(h(k)=k\\bmod m\\), onde \\(m=7\\) √© o tamanho do vetor.\n\n\n\n\n\n\n\n\n\n\n\nTipSolu√ß√£o (clique para ver)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nprt_0\n\n\n\n\n\n\n\nprt_1\n\n\n\n\n\n\n\nprt_2\n\n\n\n\n\n\n\nprt_3\n\n\n\n\n\n\n\nprt_4\n\n\n\n\n\n\n\nprt_5\n\n\n\n\n\n\n\nprt_6\n\n\n\n\n\n\n\n07\n\n\n\n\n\n\n\n14\n\n\n\n\n\n\n\n21\n\n\n\n\n\n\n\n28\n\n\n\n\n\n\n\n15\n\n\n\n\n\n\n\n22\n\n\n\n\n\n\n\n01\n\n\n\n\n\n\n\n08\n\n\n\n\n\n\n\n02\n\n\n\n\n\n\n\n09\n\n\n\n\n\n\n\n03\n\n\n\n\n\n\n\n10\n\n\n\n\n\n\n\n25\n\n\n\n\n\n\n\n04\n\n\n\n\n\n\n\n11\n\n\n\n\n\n\n\n05\n\n\n\n\n\n\n\n13\n\n\n\n\n\n\n\n06\n\n\n\n\n\n\n\n20\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNesta unidade, voc√™ aprendeu\n‚úÖ a identificar quando uma colis√£o ocorre\n‚úÖ os principais met√≥dos para tratar colis√µes\n\n\n# Quando ocorre uma colis√£o em uma tabela hash?\n\n&gt; Pense no resultado da fun√ß√£o hash para chaves diferentes.\n\n1. [ ] Quando duas chaves s√£o id√™nticas.  \n1. [x] Quando duas chaves diferentes produzem o mesmo valor hash.  \n1. [ ] Quando o vetor est√° totalmente vazio.  \n1. [ ] Quando a fun√ß√£o hash retorna sempre zero.  \n\n\n# Quais s√£o as principais t√©cnicas para tratamento de colis√µes?\n\n&gt; Existem duas abordagens gerais descritas no texto.\n\n- [x] Endere√ßamento aberto  \n- [x] Encadeamento separado  \n- [ ] Sondagem aleat√≥ria  \n- [ ] Redimensionamento din√¢mico  \n\n\n# Complete a ordem correta das sondagens no endere√ßamento aberto!\n\n&gt; Considere o modo como o algoritmo busca novas posi√ß√µes vazias.\n\n1. Sondagem linear  \n2. Sondagem quadr√°tica  \n3. Duplo hash  \n\n# Como funciona a sondagem linear?\n\n&gt; Veja a f√≥rmula $h(k,i) = (h'(k) + i) \\bmod m$.\n\n1. [ ] Utiliza duas fun√ß√µes hash diferentes.  \n1. [x] Incrementa o √≠ndice em uma unidade at√© encontrar posi√ß√£o vazia.  \n1. [ ] Usa pot√™ncias de $i$ para procurar posi√ß√µes.  \n1. [ ] Usa listas encadeadas para armazenar colis√µes.  \n\n# Na sondagem quadr√°tica, a fun√ß√£o hash usa quais termos?\n\n&gt; Observe a f√≥rmula $h(k,i) = (h'(k) + c_1 i + c_2 i^2) \\bmod m$.\n\n- [x] Um termo linear ($c_1 i$)  \n- [x] Um termo quadr√°tico ($c_2 i^2$)  \n- [ ] Um termo c√∫bico ($c_3 i^3$)  \n- [ ] Um termo logar√≠tmico ($\\log i$)  \n\n# No duplo hash, o c√°lculo depende de duas fun√ß√µes hash. Quais delas s√£o usadas?\n\n&gt; Elas aparecem como $h_1(k)$ e $h_2(k)$.\n\n- [x] $h_1(k)$  \n- [x] $h_2(k)$  \n- [ ] $h_3(k)$  \n- [ ] Nenhuma, √© uma sondagem linear disfar√ßada  \n\n# Coloque em ordem os tr√™s m√©todos de endere√ßamento aberto apresentados!\n\n&gt; Do mais simples ao mais sofisticado.\n\n1. Sondagem linear  \n2. Sondagem quadr√°tica  \n3. Duplo hash  \n\n# Qual √© a ideia principal do encadeamento separado?\n\n&gt; Considere o uso de ponteiros e listas encadeadas.\n\n1. [ ] Procurar um slot vazio no vetor.  \n1. [ ] Remover elementos duplicados automaticamente.  \n1. [x] Manter listas encadeadas separadas para cada posi√ß√£o da tabela.  \n1. [ ] Usar fun√ß√µes hash aleat√≥rias para evitar colis√µes.",
    "crumbs": [
      "Tratamento de Colis√µes"
    ]
  },
  {
    "objectID": "disciplinas/aed2/academic/unidade2/1-ponteiros.html",
    "href": "disciplinas/aed2/academic/unidade2/1-ponteiros.html",
    "title": "Ponteiros (Revis√£o)",
    "section": "",
    "text": "Por muito tempo, construir estruturas de dados, como listas e √°rvores, exigia que os desenvolvedores as reescrevessem para cada tipo de dado. Era uma batalha constante: uma lista para n√∫meros inteiros, outra para textos, outra para dados de usu√°rios, e assim por diante. Essa repeti√ß√£o n√£o apenas consumia tempo, mas tamb√©m abria portas para erros e inconsist√™ncias.\nA ideia de estruturas gen√©ricas √© poder construir estruturas universais que podem ser aplicadas em qualquer projeto. Embora a linguagem C n√£o tenha suporte nativo a ‚Äúgen√©ricos‚Äù, como C++ ou Java, a solu√ß√£o tradicional e elegante √© usar ponteiros void* e fun√ß√µes de callback.\nAntes de explorarmos essas estruturas, √© fundamental revisar e aprofundar dois conceitos cruciais: ponteiros e ponteiros de fun√ß√£o.\nComo voc√™ deve ter visto em Algoritmos e Estruturas de Dados 1, um ponteiro √© uma vari√°vel que armazena o endere√ßo de mem√≥ria de outra vari√°vel. Essa capacidade √© a base para criar estruturas de dados com tamanho din√¢mico (que crescem ou diminuem em tempo de execu√ß√£o).",
    "crumbs": [
      "Ponteiros (Revis√£o)"
    ]
  },
  {
    "objectID": "disciplinas/aed2/academic/unidade2/1-ponteiros.html#sec-dec",
    "href": "disciplinas/aed2/academic/unidade2/1-ponteiros.html#sec-dec",
    "title": "Ponteiros (Revis√£o)",
    "section": "Declara√ß√£o",
    "text": "Declara√ß√£o\nQuando declaramos uma vari√°vel e atribu√≠mos um valor, esse valor √© armazenado em um endere√ßo de mem√≥ria. Quando escrevemos int x = 10;, ocorrem dois passos conceituais:\n\nDeclara√ß√£o: o programa reserva um espa√ßo na mem√≥ria para armazenar um inteiro.\nAtribui√ß√£o: o valor 10 √© gravado nesse espa√ßo de mem√≥ria, que possui um endere√ßo.\n\nA vari√°vel x √© apenas um r√≥tulo usado pelo programador.\n\n\nIlustra√ß√£o da mem√≥ria para uma vari√°vel do tipo int\n\n\nVari√°vel\nEndere√ßo\nConte√∫do\n\n\n\n\nx\n0x75\n10\n\n\n\n\n\n\nSe liga! A mem√≥ria em si √© ilustrada pelo endere√ßo e conte√∫do armazenado. A vari√°vel √© apenas um r√≥tulo que representa este par.\nO princ√≠pio b√°sico de um ponteiro √© a compatibilidade de tipo, ou seja, um ponteiro deve ser do mesmo tipo do dado que ele aponta.\ndouble meta = 7.5;\ndouble *meta_ptr = &meta; // O operador & retorna o endere√ßo na mem√≥ria\nNa linha 2, meta_ptr guarda o endere√ßo da vari√°vel meta.\nO quadro abaixo ilustra a mem√≥ria depois das declara√ß√µes do trecho de c√≥digo anterior.\n\n\nIlustra√ß√£o da mem√≥ria para um ponteiro\n\n\nVari√°vel\nEndere√ßo\nConte√∫do\n\n\n\n\nmeta\n0x55\n7.5\n\n\nmeta_ptr\n0x58\n0x55\n\n\n\n\nEstamos usando endere√ßos fict√≠cios. Note que meta_ptr guarda o endere√ßo de meta. Neste caso, dizemos que meta_ptr aponta para meta.\nVamos explorar outro exemplo usando um diagrama que ilustra uma mem√≥ria.\n\n\n\n\n\nflowchart RL\n    %% N√≥s de vari√°veis e ponteiros\n    X[\"üì¶ &lt;b&gt;x&lt;/b&gt;&lt;br/&gt;Endere√ßo: &lt;code&gt;0x100&lt;/code&gt;&lt;br/&gt;Conte√∫do: &lt;b&gt;42&lt;/b&gt;\"]\n    Y[\"üì¶ &lt;b&gt;y&lt;/b&gt;&lt;br/&gt;Endere√ßo: &lt;code&gt;0x200&lt;/code&gt;&lt;br/&gt;Conte√∫do: &lt;b&gt;137&lt;/b&gt;\"]\n    P[\"üéØ &lt;b&gt;p&lt;/b&gt;&lt;br/&gt;Endere√ßo: &lt;code&gt;0x300&lt;/code&gt;&lt;br/&gt;Conte√∫do: &lt;code&gt;0x100&lt;/code&gt;\"]\n    PP[\"üéØ &lt;b&gt;pp&lt;/b&gt;&lt;br/&gt;Endere√ßo: &lt;code&gt;0x400&lt;/code&gt;&lt;br/&gt;Conte√∫do: &lt;code&gt;0x300&lt;/code&gt;\"]\n\n    %% Conex√µes\n    PP --&gt;|\"aponta para\"| P\n    P --&gt;|\"aponta para\"| X\n    P ~~~ Y\n    Y ~~~ X\n\n    %% Estilos de formata√ß√£o\n    classDef var fill:#A8E6CF,stroke:#2E7D32,color:#000,stroke-width:1px;\n    classDef ptr fill:#FFD3B6,stroke:#E65100,color:#000,stroke-width:1px;\n    class X,Y var\n    class P,PP ptr\n\n\n\n\n\n\n\n\nSe liga! Cada quadro √© um bloco de mem√≥ria que possui um endere√ßo e um valor. Os ponteiros est√£o em laranja.\nAs vari√°veis x e y carregam dados que est√£o armazenados nos endere√ßos 0x100 e 0x200, respectivamente. A vari√°vel p √© um ponteiro cujo conte√∫do √© 0x100, portanto aponta para x. A vari√°vel pp √© outro ponteiro, mas com conte√∫do 0x300, ou seja, aponta para o local com endere√ßo 0x300, que seria p. Isso mesmo que voc√™ pensou, um ponteiro de ponteiro. O c√≥digo que representa esse diagrama pode ser o seguinte.\nint x = 42;\nint y = 137;\nint *p = &x;\nint **pp = &p;\nResumindo\n\nx ‚Üí cont√©m 42 e est√° no endere√ßo 0x100;\ny ‚Üí cont√©m 137 e est√° no endere√ßo 0x200;\np ‚Üí cont√©m 0x100 (o endere√ßo de x);\npp ‚Üí cont√©m 0x300 (o endere√ßo de p).\n\nVale salientar que h√° tr√™s declara√ß√µes de ponteiros ligeiramente diferentes:\ndouble *meta_ptr = &meta;\ndouble* meta_ptr = &meta;\ndouble * meta_ptr = &meta;\n\n\nSe liga! Essas declara√ß√µes dizem respeito ao local do s√≠mbolo *.\nNo entanto, a primeira √© mais recomendada: tipo *ponteiro = &variavel.",
    "crumbs": [
      "Ponteiros (Revis√£o)"
    ]
  },
  {
    "objectID": "disciplinas/aed2/academic/unidade2/1-ponteiros.html#sec-des",
    "href": "disciplinas/aed2/academic/unidade2/1-ponteiros.html#sec-des",
    "title": "Ponteiros (Revis√£o)",
    "section": "Desreferencia√ß√£o",
    "text": "Desreferencia√ß√£o\nUma opera√ß√£o importante com ponteiros √© a desreferencia√ß√£o (ou dereferencing). Ela ocorre quando acessamos o conte√∫do armazenado no endere√ßo que o ponteiro aponta. Por exemplo,\ndouble meta = 7.5;\ndouble *meta_ptr = &meta; // O operador & retorna o endere√ßo na mem√≥ria\nprintf(\"*meta_ptr: %.2f\\n\", *meta_ptr); // *meta_ptr: 7.50\nNa segunda linha, criamos um ponteiro que aponta para meta. Na linha 3, o operador * serve para desreferenciar, ou seja, ao usar *meta_ptr na impress√£o, o C acessa o valor armazenado no endere√ßo que meta_ptr aponta (7.5).\n\n\n\n\n\n\nDica\n\n\n\nO * tem dupla fun√ß√£o:\n\nDeclarar um ponteiro (double *p)\nDesreferenciar um ponteiro (*p)\n\n\n\n\n\nSe liga! Os operadores * e & se anulam, ou seja, *&p ou &*p √© o mesmo que p.\n√â v√°lido mencionar que, em uma vari√°vel que guarda um dado, podemos acessar o dado e o endere√ßo. J√° em um ponteiro, podemos acessar seu endere√ßo, o conte√∫do (outro endere√ßo) e o dado armazenado pela vari√°vel que ele aponta:\nint idade = 12;\nint *idade_ptr = &idade;\n\nprintf(\"idade: %d\\n\", idade);\nprintf(\"&idade: %x\\n\", &idade);\n\nprintf(\"&idade_ptr: %x\\n\", &idade_ptr); // Endere√ßo do ponteiro\nprintf(\"idade_ptr: %x\\n\", idade_ptr);   // Endere√ßo de idade\nprintf(\"*idade_ptr: %d\\n\", *idade_ptr); // Conte√∫do de idade\nPara fixa√ß√£o, observe o diagrama de sequ√™ncia que ilustra os processos de decla√ß√£o e desreferencia√ß√£o.\nint x = 10;\nint *ptr = &x;\nint y = *ptr;  // desreferencia√ß√£o\n\n\n\n\n\nsequenceDiagram\n    participant Stack as Mem√≥ria (Stack)\n    participant X as Vari√°vel x\n    participant Ptr as Ponteiro ptr\n    participant CPU as CPU/Programa\n\n    Note over CPU,Stack: Declara√ß√£o e atribui√ß√£o inicial\n    CPU-&gt;&gt;Stack: Aloca espa√ßo para x = 10\n    Stack-&gt;&gt;X: Cria x (valor=10, endere√ßo=0x1000)\n\n    Note over CPU,Ptr: Ponteiro recebe o endere√ßo de x\n    CPU-&gt;&gt;Ptr: ptr = &x\n    Ptr-&gt;&gt;Stack: Guarda endere√ßo 0x1000\n\n    Note over CPU,Stack: Desreferencia√ß√£o\n    CPU-&gt;&gt;Ptr: l√™ conte√∫do de ptr\n    Ptr--&gt;&gt;Stack: endere√ßo 0x1000\n    Stack--&gt;&gt;CPU: retorna valor armazenado (10)\n    CPU-&gt;&gt;Stack: y = 10\n\n    Note right of CPU: *ptr l√™ o valor armazenado em x\n\n\n\n\n\n\nAl√©m de ler o conte√∫do de uma vari√°vel, tamb√©m podemos modific√°-lo indiretamente usando ponteiros:\ndouble meta = 7.5;\ndouble *meta_ptr = &meta; \n\n*meta_ptr = 10;\nprintf(\"meta: %.2f\\n\", meta); // meta: 10.00\nMudamos o valor de meta sem acess√°-la diretamente. Isso √© o poder dos ponteiros!\n\n\n\n\n\n\nNotaüéØ Desafio de C√≥digo\n\n\n\n\nCrie um ponteiro p que aponte para uma vari√°vel x = 5.\nUse o ponteiro para alterar x para 42.\nDepois, exiba o valor e o endere√ßo de x no console.\n\n\n\n\n\n\n\n\n\nDicaSolu√ß√£o (clique para ver)\n\n\n\n\n\n#include &lt;stdio.h&gt; \n\nint main(){\n    int x = 5;   \n    int *p = &x; // Ponteiro apontando para x (ambos do mesmo tipo)\n    *p = 42;     // Modifica√ß√£o indireta\n\n    printf(\"x: %d\\n\", x);\n    printf(\"&x: %p\\n\", &x);\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\nNotaüéØ Desafio de C√≥digo\n\n\n\n\nPasso 1: Declare um ponteiro ponteiro_chave que aponte para a chave_secreta.\nPasso 2: Mude o valor da chave_secreta para 99 usando o ponteiro.\nPasso 3: Imprima o valor da chave secreta.\n\n#include &lt;stdio.h&gt;\n\nint main() {\n    int chave_secreta = 10;\n    // SEU C√ìDIGO\n\n    return 0;\n}\n\n\n\n\n\n\n\n\nDicaSolu√ß√£o (clique para ver)\n\n\n\n\n\n#include &lt;stdio.h&gt; \n\nint main() {\n    int chave_secreta = 10;\n    int *ponteiro_chave = &chave_secreta;\n    *ponteiro_chave = 99;\n\n    printf(\"chave_secreta: %d\\n\", chave_secreta);\n    return 0;\n}",
    "crumbs": [
      "Ponteiros (Revis√£o)"
    ]
  },
  {
    "objectID": "disciplinas/aed2/academic/unidade2/1-ponteiros.html#sec-par",
    "href": "disciplinas/aed2/academic/unidade2/1-ponteiros.html#sec-par",
    "title": "Ponteiros (Revis√£o)",
    "section": "Ponteiros como par√¢metros",
    "text": "Ponteiros como par√¢metros\nEm C, os par√¢metros s√£o passados por valor. Portanto, a fun√ß√£o recebe uma c√≥pia do argumento.\nvoid dobrar_meta (double meta){ \n    meta = 2*meta; \n}\nNa main:\ndouble meta = 7.5;\nprintf(\"meta: %.2f\\n\", meta);\ndobrar_meta(meta);\nprintf(\"meta: %.2f\\n\", meta);\nSa√≠da:\nmeta: 7.50\nmeta: 7.50\nEsperav√°mos que no exemplo acima, o valor de meta tivesse sido dobrado, mas nada mudou. A raz√£o √© que a fun√ß√£o alterou apenas a c√≥pia local. A vari√°vel meta na fun√ß√£o main √© global, j√° na fun√ß√£o dobrar_meta √© local. Significa que quando esta fun√ß√£o termina, as vari√°veis s√£o descartadas.1\n1¬†Se voc√™ declarar uma vari√°vel local com o mesmo nome de uma vari√°vel global, a vari√°vel local prevalece dentro do seu escopo, ocultando temporariamente a global.Imprimindo os endere√ßos, vamos constatar que trata-se de vari√°veis diferentes.\nvoid dobrar_meta (double meta){ \n    printf(\"local &meta: %x\\n\", &meta);\n    meta = 2*meta; \n}\nNa main:\ndouble meta = 7.5;\nprintf(\"main &meta: %x\\n\", &meta);\ndobrar_meta(meta);\nSa√≠da:\nmain &meta: 0xe8\nlocal &meta: 0xc0\nOs endere√ßos s√£o diferentes. Logo, n√£o s√£o as mesmas vari√°veis que estamos manipulando\nA vari√°vel interna em dobrar_meta √© criada em outra regi√£o de mem√≥ria e recebe uma c√≥pia do valor passado como argumento. Esse valor √© dobrado em seguida, mas n√£o reflete na vari√°vel da fun√ß√£o main, pois ela est√° alocada em outra posi√ß√£o.\n\n\n\n\n\nflowchart LR\n subgraph s1[\" \"]\n        X[\"üì¶ &lt;b&gt;meta&lt;/b&gt;&lt;br&gt;Endere√ßo: &lt;code&gt;0xe8&lt;/code&gt;&lt;br&gt;Conte√∫do: &lt;b&gt;7.5&lt;/b&gt;\"]\n        Y[\"üì¶ &lt;b&gt;meta&lt;/b&gt;&lt;br&gt;Endere√ßo: &lt;code&gt;0xc0&lt;/code&gt;&lt;br&gt;Conte√∫do: &lt;b&gt;7.5&lt;/b&gt;\"]\n  end\n\n subgraph s2[\" \"]\n        A[\"üì¶ &lt;b&gt;meta&lt;/b&gt;&lt;br&gt;Endere√ßo: &lt;code&gt;0xe8&lt;/code&gt;&lt;br&gt;Conte√∫do: &lt;b&gt;7.5&lt;/b&gt;\"]\n        B[\"üì¶ &lt;b&gt;meta&lt;/b&gt;&lt;br&gt;Endere√ßo: &lt;code&gt;0xc0&lt;/code&gt;&lt;br&gt;Conte√∫do: &lt;b&gt;15&lt;/b&gt;\"]\n  end\n\n    s1 --dobrar_meta--&gt; s2\n    \n     X:::var\n     Y:::var\n     A:::var\n     B:::var\n    classDef var fill:#A8E6CF,stroke:#2E7D32,color:#000,stroke-width:1px\n    style s1 fill:transparent\n    style s2 fill:transparent\n\n\n\n\n\n\n\nPara solucionar isso, ao inv√©s de passarmos o conte√∫do armazenado, podemos passar o endere√ßo. Isso √© conhecido como passagem por refer√™ncia. Na verdade, ainda ser√° feita uma c√≥pia do valor passado, mas como esse valor copiado √© um endere√ßo (o ponteiro), esse artif√≠cio ser√° suficiente para manipularmos os dados originais.\n#include &lt;stdio.h&gt;\n\nvoid dobrar_meta (double *meta){ \n    *meta = 2*(*meta); // Desreferencia√ß√£o \n}\n\nint main (){\n    double meta = 7.5;\n    \n    printf(\"meta: %.2f\\n\", meta);\n    dobrar_meta(&meta); // Passando o endere√ßo\n    printf(\"meta: %.2f\\n\", meta);\n\n    return 0;\n}\nSa√≠da:\nmeta: 7.50\nmeta: 15.00\nDessa vez, a fun√ß√£o modificou a vari√°vel original, pois passamos a refer√™ncia. Vamos ilustrar como isso aconteceu.\n\n\n\n\nVari√°vel\nEndere√ßo\nConte√∫do\n\n\n\n\nmain meta\n0xe8\n7.5\n\n\nlocal meta\n0xc0\n0xe8\n\n\n\n\nDentro da fun√ß√£o, quando fazemos *meta, o C faz a desreferencia√ß√£o, ou seja, retorna o conte√∫do do local cujo o endere√ßo √© 0xe8. Neste local, a opera√ß√£o de dobrar √© efetuada.\n\n\n\n\nVari√°vel\nEndere√ßo\nConte√∫do\n\n\n\n\nmain meta\n0xe8\n15\n\n\nlocal meta\n0xc0\n0xe8\n\n\n\n\nAo finalizar, a vari√°vel meta da fun√ß√£o main sofreu a altera√ß√£o.\n\n\n\n\n\nflowchart LR\n subgraph s1[\" \"]\n        X[\"üì¶ &lt;b&gt;meta&lt;/b&gt;&lt;br&gt;Endere√ßo: &lt;code&gt;0xe8&lt;/code&gt;&lt;br&gt;Conte√∫do: &lt;b&gt;7.5&lt;/b&gt;\"]\n        Y[\"üéØ &lt;b&gt;meta&lt;/b&gt;&lt;br&gt;Endere√ßo: &lt;code&gt;0xc0&lt;/code&gt;&lt;br&gt;Conte√∫do: &lt;b&gt;0xe8&lt;/b&gt;\"]\n  end\n subgraph s2[\" \"]\n        A[\"üì¶ &lt;b&gt;meta&lt;/b&gt;&lt;br&gt;Endere√ßo: &lt;code&gt;0xe8&lt;/code&gt;&lt;br&gt;Conte√∫do: &lt;b&gt;15&lt;/b&gt;\"]\n        B[\"üéØ &lt;b&gt;meta&lt;/b&gt;&lt;br&gt;Endere√ßo: &lt;code&gt;0xc0&lt;/code&gt;&lt;br&gt;Conte√∫do: &lt;b&gt;0xe8&lt;/b&gt;\"]\n  end\n    s1 -- dobrar_meta --&gt; s2\n\n     X:::var\n     Y:::ptr\n     A:::var\n     B:::ptr\n    classDef var fill:#A8E6CF,stroke:#2E7D32,color:#000,stroke-width:1px\n    classDef ptr fill:#FFD3B6,stroke:#E65100,color:#000,stroke-width:1px;\n    style s1 fill:transparent\n    style s2 fill:transparent\n\n\n\n\n\n\n\n\n\n\n\n\nImportante\n\n\n\nQuando passamos o endere√ßo (&meta) para a fun√ß√£o dobrar_meta, a vari√°vel meta interna vai armazenar em seu conte√∫do um endere√ßo de mem√≥ria. Ou seja, ela √© um ponteiro e, portanto, podemos desreferenciar. Por exemplo, considere as seguintes assinaturas de fun√ß√µes:\nvoid foo(int a);\nvoid bar(int* a);\nQuando fazemos foo(x), internamente √© feita uma c√≥pia do valor de x, ou seja, √© criado int a = x. Do mesmo modo, quando fazemos bar(&x), ent√£o √© criado int *a = &x. Se usarmos os mesmos nomes, o C consegue diferenciar a vari√°vel da fun√ß√£o da que vem como argumento.\n\n\n\n\n\n\n\n\nNotaüéØ Desafio de C√≥digo\n\n\n\nImplemente uma fun√ß√£o swap que troque os valores de duas vari√°veis. Teste na main com:\nint x = 10, y = 20;\nswap(&x, &y);\nprintf(\"x = %d, y = %d\\n\", x, y);\nSa√≠da esperada: x = 20, y = 10\n\n\n\n\n\n\n\n\nDicaSolu√ß√£o (clique para ver)\n\n\n\n\n\n#include &lt;stdio.h&gt; \n\nvoid swap(int *a, int *b){\n    int aux = *a;\n    a* = *b;\n    b* = aux;\n}\n\nint main(){\n    int x = 10, y = 20;\n    swap(&x, &y);\n    printf(\"x = %d, y = %d\\n\", x, y);\n\n    return 0;\n}\n\n\n\n\nNesta unidade, voc√™ aprendeu\n‚úÖ a declarar e desreferenciar ponteiros\n‚úÖ a modificar valores via ponteiros\n‚úÖ a passar vari√°veis por refer√™ncia\n\n\n\n\n\n\nDica\n\n\n\nSe voc√™ quiser aprofundar mais seu conhecimento sobre ponteiros, revise materiais sobre ponteiros para structs, aritm√©tica de ponteiros, ponteiros para strings e a rela√ß√£o entre arrays e ponteiros.\n\n\n\n\n# O que melhor descreve um ponteiro em C?\n\n1. [ ] Uma vari√°vel que armazena o valor de outra vari√°vel.  \n1. [x] Uma vari√°vel que armazena o endere√ßo de mem√≥ria de outra vari√°vel.  \n1. [ ] Uma fun√ß√£o que manipula endere√ßos de mem√≥ria.  \n1. [ ] Um tipo especial usado apenas para arrays.  \n\n# Por que um ponteiro deve ser do mesmo tipo da vari√°vel para a qual aponta?\n\n1. [x] Para garantir a interpreta√ß√£o correta dos dados armazenados na mem√≥ria.  \n1. [ ] Para permitir convers√£o impl√≠cita de tipos.  \n1. [ ] Porque o C faz o casting autom√°tico de ponteiros.  \n1. [ ] N√£o √© necess√°rio; qualquer ponteiro pode apontar para qualquer tipo de dado com seguran√ßa.  \n\n\n# O que acontece ao usar o operador `*` sobre um ponteiro?\n\n1. [ ] Ele recupera o endere√ßo de mem√≥ria armazenado no ponteiro.  \n1. [x] Ele acessa o valor armazenado no endere√ßo de mem√≥ria apontado pelo ponteiro.  \n1. [ ] Ele declara uma nova vari√°vel ponteiro.  \n1. [ ] Ele libera a mem√≥ria associada ao ponteiro.  \n\n\n# Quais das declara√ß√µes abaixo s√£o **equivalentes e v√°lidas** em C?\n\n- [x] `double *meta_ptr = &meta;`  \n- [x] `double* meta_ptr = &meta;` \n- [ ] `double meta_ptr* = &meta;`  \n- [x] `double * meta_ptr = &meta;` \n\n\n# Por que a fun√ß√£o `dobrar_meta(double meta)` n√£o altera o valor da vari√°vel `meta` na fun√ß√£o `main`?\n\n1. [x] Porque o C passa argumentos por valor, criando uma c√≥pia da vari√°vel.  \n1. [ ] Porque vari√°veis do tipo `double` s√£o imut√°veis.  \n1. [ ] Porque a fun√ß√£o n√£o tem retorno (`void`).  \n1. [ ] Porque a vari√°vel `meta` √© constante.  \n\n\n# O que faz a express√£o `*meta = 2 * (*meta);`?\n\n1. [ ] Declara um novo ponteiro.  \n1. [x] Dobra o valor armazenado na vari√°vel original, desreferenciando o endere√ßo recebido.  \n1. [ ] Altera o endere√ßo armazenado no ponteiro.  \n1. [ ] Cria uma c√≥pia do ponteiro.  \n\n\n# Marque as afirmativas verdadeiras sobre o exemplo `swap(&x, &y)`.\n\n- [x] S√£o passados os endere√ßos das vari√°veis `x` e `y`.  \n- [x] Os valores de `x` e `y` s√£o modificados diretamente.  \n- [ ] A fun√ß√£o troca apenas c√≥pias das vari√°veis.  \n- [ ] A fun√ß√£o utiliza passagem por valor.",
    "crumbs": [
      "Ponteiros (Revis√£o)"
    ]
  },
  {
    "objectID": "disciplinas/aed2/academic/unidade2/6-introhash.html",
    "href": "disciplinas/aed2/academic/unidade2/6-introhash.html",
    "title": "Tabela de Dispers√£o",
    "section": "",
    "text": "Nesta unidade do curso, iremos estudar as tabelas de dispers√£o (hash table). Pense em uma busca que n√£o demora, que n√£o precisa de caminhadas longas por uma lista ou descidas por uma √°rvore. Imagine que voc√™ pode encontrar qualquer dado em um instante, de forma quase m√°gica. Essa √© a promessa de uma tabela de dispers√£o.\nVamos explorar o conceito de fun√ß√£o de hash, que √© o cora√ß√£o dessa estrutura, e aprenderemos a lidar com as colis√µes. Ao final, voc√™ ter√° em m√£os uma das ferramentas mais r√°pidas e eficientes para a manipula√ß√£o de grandes volumes de dados desde dicion√°rios de programa√ß√£o at√© caches de navegador e bancos de dados.",
    "crumbs": [
      "Tabela de Dispers√£o"
    ]
  },
  {
    "objectID": "disciplinas/aed2/academic/unidade2/6-introhash.html#problematiza√ß√£o",
    "href": "disciplinas/aed2/academic/unidade2/6-introhash.html#problematiza√ß√£o",
    "title": "Tabela de Dispers√£o",
    "section": "Problematiza√ß√£o",
    "text": "Problematiza√ß√£o\nVoc√™ est√° desenvolvendo um RPG retr√¥ com restri√ß√µes severas de mem√≥ria, limitando seu cat√°logo mestre de itens a um array de apenas 10 slots (√≠ndices de 0 a 9).\nNo entanto, o jogo tem muito mais do que 10 itens no total, e cada um tem um ID inteiro √∫nico (a chave).\n\n\nCole√ß√£o de itens coletados no jogo\n\n\nItem\nID (chave)\n\n\n\n\nPo√ß√£o de Vida\n12\n\n\nAmuleto Raro\n18\n\n\nEspada Longa\n21\n\n\nArmadura de Bronze\n3\n\n\nArmadura de Ouro\n15\n\n\n\n\nO desafio √© como mapear IDs maiores que 9 (12, 22, 13) para um array com slots numerados de 0 a 9, e ainda assim conseguir encontr√°-los rapidamente?",
    "crumbs": [
      "Tabela de Dispers√£o"
    ]
  },
  {
    "objectID": "disciplinas/aed2/academic/unidade2/6-introhash.html#proposta-de-solu√ß√£o",
    "href": "disciplinas/aed2/academic/unidade2/6-introhash.html#proposta-de-solu√ß√£o",
    "title": "Tabela de Dispers√£o",
    "section": "Proposta de solu√ß√£o",
    "text": "Proposta de solu√ß√£o\nA ideia √© usar uma fun√ß√£o que transforma qualquer ID em um n√∫mero entre 0 e 9, reaproveitando o mesmo espa√ßo de forma controlada.\n\n\nSe liga! O resto da divis√£o de qualquer inteiro pelo inteiro \\(m\\) est√° no intervalo \\([0,m-1]\\).\nEssa fun√ß√£o √© o m√≥dulo (resto da divis√£o):\n\\[h(id) = id\\bmod 10\\]\nComo o divisor √© \\(10\\), os √∫nicos valores de resto poss√≠veis s√£o os n√∫meros de 0 a 9, como desejamos.\nAplicando a fun√ß√£o aos nossos itens:\n\n\\(h(12) = 12 \\bmod 10 = 2\\)\n\\(h(18) = 18 \\bmod 10 = 8\\)\n\\(h(21) = 21 \\bmod 10 = 1\\)\n\\(h(3)\\,\\,\\,= 3\\,\\,\\,\\bmod 10 = 3\\)\n\\(h(15) = 15 \\bmod 10 = 5\\)\n\nDessa maneira, nosso vetor resultante seria:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n\n‚ùå\nEspada Longa\nPo√ß√£o de Vida\nArmadura de Bronze\n‚ùå\nArmadura de Ouro\n‚ùå\n‚ùå\nAmuleto Raro\n‚ùå\n\n\n\nAgora, para verificar se o jogador possui o Amuleto Raro, basta aplicar novamente a mesma fun√ß√£o: \\(h(18) = 18 \\bmod 10 = 8\\).\nSem precisar percorrer todo o array, o jogo j√° sabe que o item (se existir) estar√° na posi√ß√£o \\(8\\).\n\n\nSe liga! Essa t√©cnica permite economizar mem√≥ria e acessar elementos em tempo constante, O(1).\nUm questionamento comum acontece quando a fun√ß√£o retorna o mesmo valor para duas chaves distintas. Por exemplo, com uma chave \\(25\\), teremos \\(f(25)=25\\bmod 10=5\\), mas a posi√ß√£o \\(5\\) j√° est√° ocupada e o vetor n√£o est√° totalmente preenchido. Nesse caso, dizemos que ocorreu uma colis√£o.\nColis√µes s√£o indesej√°veis! Precisamos de fun√ß√µes bem definidas para evitar esse tipo de problema.\n\n\nSe liga! A fun√ß√£o que escolhemos anteriormente √© chamada de fun√ß√£o de hash. Existem v√°rias vers√µes, mas a que mostramos √© uma das mais simples.\n\nNesta unidade, voc√™ aprendeu\n‚úÖ o que √© uma tabela de dispers√£o\n‚úÖ onde uma tabela de dispers√£o √© usada\n‚úÖ como √© controlada a entrada na tabela de dispers√£o\n\n\n# O que √© uma tabela de dispers√£o ?\n\n&gt; Pense na principal caracter√≠stica que a torna eficiente.\n\n1. [ ] Uma estrutura que armazena elementos de forma sequencial.\n1. [x] Uma estrutura que mapeia chaves a posi√ß√µes em um vetor usando uma fun√ß√£o de hash.\n1. [ ] Um tipo especial de √°rvore bin√°ria balanceada.\n1. [ ] Um vetor ordenado que permite busca bin√°ria.\n\n\n# Qual √© a principal fun√ß√£o da fun√ß√£o de hash em uma tabela de dispers√£o?\n\n&gt; Ela define como os elementos s√£o distribu√≠dos.\n\n1. [ ] Ordenar as chaves em ordem crescente.\n1. [x] Converter uma chave em um √≠ndice v√°lido da tabela.\n1. [ ] Calcular o n√∫mero total de colis√µes.\n1. [ ] Garantir que n√£o haja duplicatas.\n\n\n# O que o operador m√≥dulo faz no c√°lculo do hash?\n\n&gt; Ele define o intervalo poss√≠vel de posi√ß√µes.\n\n1. [x] Retorna o resto da divis√£o da chave por um n√∫mero fixo.\n1. [ ] Retorna o quociente da divis√£o inteira.\n1. [ ] Multiplica a chave pelo tamanho do vetor.\n1. [ ] Subtrai a chave de 10.\n\n\n# Dado o hash $h(k) = k \\bmod 9$, qual √© o valor de $h(21)$? \n\n&gt; Basta aplicar a opera√ß√£o de m√≥dulo.\n\n1. [ ] 0\n1. [x] 3\n1. [ ] 2\n1. [ ] 9\n\n\n# O que caracteriza uma colis√£o em uma tabela de dispers√£o? \n\n&gt; √â quando duas chaves competem pelo mesmo espa√ßo.\n\n1. [ ] Quando duas chaves possuem o mesmo endere√ßo.\n1. [x] Quando duas chaves diferentes s√£o mapeadas para o mesmo √≠ndice.\n1. [ ] Quando uma chave √© removida da tabela.\n1. [ ] Quando o vetor est√° completamente vazio.\n\n\n# Quais s√£o consequ√™ncias de uma fun√ß√£o de hash mal projetada?\n\n&gt; Pense nos efeitos diretos sobre desempenho e armazenamento.\n\n- [x] Aumento do n√∫mero de colis√µes.\n- [x] Desempenho pior nas buscas.\n- [ ] Redu√ß√£o autom√°tica do tamanho da tabela.\n- [ ] Melhoria na aleatoriedade das chaves.\n\n\n# Qual √© a complexidade m√©dia de acesso a um elemento em uma tabela de dispers√£o bem implementada?\n\n&gt; A efici√™ncia √© o principal atrativo dessa estrutura.\n\n1. [x] O(1)\n1. [ ] O(log n)\n1. [ ] O(n)\n1. [ ] O(n log n)\n\n\n# Qual das op√ß√µes descreve melhor uma fun√ß√£o de hash simples?\n\n&gt; Baseie-se no exemplo do texto.\n\n1. [ ] Uma fun√ß√£o que ordena as chaves antes de armazen√°-las.\n1. [ ] Uma fun√ß√£o que soma todos os d√≠gitos da chave.\n1. [x] Uma fun√ß√£o que calcula o resto da divis√£o da chave pelo tamanho do vetor.\n1. [ ] Uma fun√ß√£o que gera um n√∫mero aleat√≥rio.\n\n\n# Quais aplica√ß√µes reais fazem uso de tabelas de dispers√£o?\n\n&gt; Elas aparecem em v√°rios contextos computacionais.\n\n- [x] Dicion√°rios em linguagens de programa√ß√£o.\n- [x] Caches de navegadores.\n- [x] √çndices de bancos de dados.\n- [ ] √Årvores de decis√£o para IA.",
    "crumbs": [
      "Tabela de Dispers√£o"
    ]
  },
  {
    "objectID": "disciplinas/aed2/slides/hash.html#√°rvores",
    "href": "disciplinas/aed2/slides/hash.html#√°rvores",
    "title": "√Årvores",
    "section": "√Årvores",
    "text": "√Årvores\n\n\nAs √°rvores s√£o, sem d√∫vida, uma das estruturas de dados mais fascinantes e poderosas da computa√ß√£o.\nEmbora, √† primeira vista, possam parecer complexas, elas est√£o no cora√ß√£o de in√∫meros sistemas que usamos todos os dias.\n\n\n\n\nI‚Äôm Groot"
  },
  {
    "objectID": "disciplinas/aed2/slides/hash.html#√°rvores-1",
    "href": "disciplinas/aed2/slides/hash.html#√°rvores-1",
    "title": "√Årvores",
    "section": "√Årvores",
    "text": "√Årvores\n\n\nPense em como o sistema de arquivos do seu computador organiza pastas e arquivos, ou como os bancos de dados otimizam a busca por informa√ß√µes, ou at√© mesmo como os compiladores de c√≥digo processam as linguagens de programa√ß√£o. Em todos esses cen√°rios, a estrutura por tr√°s √© uma √°rvore."
  },
  {
    "objectID": "disciplinas/aed2/slides/hash.html#√°rvores-2",
    "href": "disciplinas/aed2/slides/hash.html#√°rvores-2",
    "title": "√Årvores",
    "section": "√Årvores",
    "text": "√Årvores\n\n\nNeste primeira unidade do curso, vamos mergulhar no mundo das √°rvores para entender como elas funcionam e por que s√£o t√£o eficientes.\nO objetivo √© compreender a l√≥gica por tr√°s de sua estrutura hier√°rquica e como essa hierarquia nos permite resolver problemas de forma muito mais elegante e r√°pida do que com estruturas lineares, como listas e vetores, vistas em Estrutuas I."
  },
  {
    "objectID": "disciplinas/aed2/slides/hash.html#√°rvores-3",
    "href": "disciplinas/aed2/slides/hash.html#√°rvores-3",
    "title": "√Årvores",
    "section": "√Årvores",
    "text": "√Årvores\nPrepare-se para explorar conceitos como n√≥, ra√≠z, folha e as diferentes formas de travessia que nos permitem visitar cada elemento de uma √°rvore.\nAo final, voc√™ n√£o apenas ter√° uma nova ferramenta em seu arsenal de programa√ß√£o, mas tamb√©m uma nova perspectiva sobre a organiza√ß√£o e a busca de dados. Vamos come√ßar nossa jornada pela base dessas estruturas e construir nosso conhecimento, n√≥ por n√≥.\n\nbg fit right:30%"
  },
  {
    "objectID": "disciplinas/aed2/slides/hash.html#defini√ß√£o",
    "href": "disciplinas/aed2/slides/hash.html#defini√ß√£o",
    "title": "√Årvores",
    "section": "Defini√ß√£o",
    "text": "Defini√ß√£o\nA √°rvore √© uma estrutura de dados hierarquizada, geralmente n√£o linear. √â composta por uma cole√ß√£o de n√≥s conectados por arestas. Cada n√≥ pode possuir uma chave que o identifica.\nVamos ver uma exemplo!"
  },
  {
    "objectID": "disciplinas/aed2/slides/hash.html#representa√ß√£o",
    "href": "disciplinas/aed2/slides/hash.html#representa√ß√£o",
    "title": "√Årvores",
    "section": "Representa√ß√£o",
    "text": "Representa√ß√£o\nSe um n√≥ X est√° conectado com um n√≥ Y (h√° uma aresta no sentido de X para Y), dizemos que X √© um n√≥ pai e Y um n√≥ filho.\nSe dois n√≥s possuem o mesmo pai, eles s√£o ditos irm√£os. Um n√≥ s√≥ pode ter no m√°ximo um pai."
  },
  {
    "objectID": "disciplinas/aed2/slides/hash.html#representa√ß√£o-1",
    "href": "disciplinas/aed2/slides/hash.html#representa√ß√£o-1",
    "title": "√Årvores",
    "section": "Representa√ß√£o",
    "text": "Representa√ß√£o\nNo exemplo ao lado, o n√≥ com chave C √© pai do n√≥ com chave H. Al√©m disso, os n√≥s com chaves I e J s√£o irm√£os. O n√≥ raiz, cuja chave √© A, n√£o possui pai.\n\nbg fit right"
  },
  {
    "objectID": "disciplinas/aed2/slides/hash.html#exemplo",
    "href": "disciplinas/aed2/slides/hash.html#exemplo",
    "title": "√Årvores",
    "section": "Exemplo",
    "text": "Exemplo\nO DOM (Document Object Model) √© um dos melhores exemplos de uma estrutura de √°rvore em programa√ß√£o, especificamente no desenvolvimento web. Ele √© a representa√ß√£o em forma de √°rvore de um documento HTML (ou XML) que √© criada pelo navegador.\nEssa representa√ß√£o em √°rvore permite que linguagens de programa√ß√£o, principalmente o Javascript, interajam com o conte√∫do de uma p√°gina web. √â como se o Javascript usasse o DOM como um mapa detalhado da p√°gina para encontrar e manipular qualquer elemento."
  },
  {
    "objectID": "disciplinas/aed2/slides/hash.html#exemplo-1",
    "href": "disciplinas/aed2/slides/hash.html#exemplo-1",
    "title": "√Årvores",
    "section": "Exemplo",
    "text": "Exemplo\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;&lt;/head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;Ol√°, Mundo!&lt;/h1&gt;\n    &lt;p id=\"pgrafo\"&gt;Este √© um par√°grafo.&lt;/p&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\nDessa forma, voc√™ pode usar Javascript para mudar o texto do par√°grafo, adicionar ou remover um elemento √† p√°gina. Tudo isso de forma din√¢mica, sem precisar recarregar a p√°gina inteira.\n\nbg 60% fit right:40%"
  },
  {
    "objectID": "disciplinas/aed2/slides/hash.html#lembrete",
    "href": "disciplinas/aed2/slides/hash.html#lembrete",
    "title": "√Årvores",
    "section": "Lembrete",
    "text": "Lembrete\n\nbg 50% right:20%\nA raiz √© o n√≥ que n√£o possui pai. Ela √© √∫nica.\nAs folhas, ou n√≥s terminais, n√£o possem filhos.\nOs demais n√≥s s√£o chamados de intermedi√°rios ou internos"
  },
  {
    "objectID": "disciplinas/aed2/slides/hash.html#falsas-√°rvores",
    "href": "disciplinas/aed2/slides/hash.html#falsas-√°rvores",
    "title": "√Årvores",
    "section": "Falsas √Årvores",
    "text": "Falsas √Årvores\nExemplo 1\n\n\n\n\n\n\nNota-se que o n√≥ com chave C possui dois pais (A e D) e isso n√£o √© permitido."
  },
  {
    "objectID": "disciplinas/aed2/slides/hash.html#falsas-√°rvores-1",
    "href": "disciplinas/aed2/slides/hash.html#falsas-√°rvores-1",
    "title": "√Årvores",
    "section": "Falsas √Årvores",
    "text": "Falsas √Årvores\nExemplo 2\n\n\n\n\n\n\nNeste exemplo, temos mesmo problema de dois pais (n√≥ com chave C). Mas tamb√©m temos duas ra√≠zes (A e G)."
  },
  {
    "objectID": "disciplinas/aed2/slides/hash.html#falsas-√°rvores-2",
    "href": "disciplinas/aed2/slides/hash.html#falsas-√°rvores-2",
    "title": "√Årvores",
    "section": "Falsas √Årvores",
    "text": "Falsas √Årvores\nExemplo 3\n\n\n\n\n\n\nEste caso √© interessante, pois todos os n√≥s possuem um pai. Ou seja, n√£o existe raiz e isso n√£o √© permitido. A √∫nica √°rvore sem raiz √© a √°rvore vazia que indicaremos com um c√≠rculo tracejado."
  },
  {
    "objectID": "disciplinas/aed2/slides/hash.html#defini√ß√µes-super-importantes",
    "href": "disciplinas/aed2/slides/hash.html#defini√ß√µes-super-importantes",
    "title": "√Årvores",
    "section": "Defini√ß√µes (Super) Importantes",
    "text": "Defini√ß√µes (Super) Importantes"
  },
  {
    "objectID": "disciplinas/aed2/slides/hash.html#√°rvore-t",
    "href": "disciplinas/aed2/slides/hash.html#√°rvore-t",
    "title": "√Årvores",
    "section": "√Årvore T",
    "text": "√Årvore T"
  },
  {
    "objectID": "disciplinas/aed2/slides/hash.html#sub√°rvore",
    "href": "disciplinas/aed2/slides/hash.html#sub√°rvore",
    "title": "√Årvores",
    "section": "Sub√°rvore",
    "text": "Sub√°rvore\n\n\nDefini√ß√£o\n\n\nUma sub√°rvore consiste em uma por√ß√£o interconectada da √°rvore. Qualquer n√≥ juntamente com seus descendentes constituem uma sub√°rvore.\n\n\nOs n√≥s destacados em T (B, D e E) formam um sub√°rvore de T. Trata-se de uma mini√°rvore dentro da √°rvore original. A sub√°rvore possui sua pr√≥pria raiz, folhas e n√≥s internos.\nNote que uma √°rvore pode ser considerada uma sub√°rvore de si mesma."
  },
  {
    "objectID": "disciplinas/aed2/slides/hash.html#tamanho",
    "href": "disciplinas/aed2/slides/hash.html#tamanho",
    "title": "√Årvores",
    "section": "Tamanho",
    "text": "Tamanho\n\n\nDefini√ß√£o\n\n\nO tamanho da √°rvore √© definido como o n√∫mero total de n√≥s.\n\n\nO tamanho de T √© 15, pois possui 15 n√≥s: - Uma raiz (A), - Seis folhas (F, K, L, M, N e O) e - Oito n√≥s internos (B, C, D, E, G, H, I e J) ."
  },
  {
    "objectID": "disciplinas/aed2/slides/hash.html#altura",
    "href": "disciplinas/aed2/slides/hash.html#altura",
    "title": "√Årvores",
    "section": "Altura",
    "text": "Altura\n\n\nDefini√ß√£o\n\n\nA altura da √°rvore √© o comprimento do caminho mais longo da raiz at√© as folhas.\n\n\nA altura de T √© 4. O comprimento pode ser calculado como o n√∫mero de arestas da raiz at√© a folha mais distante. H√° quatro arestas de A at√© K, por exemplo.\nA altura pode ser calculada para qualquer n√≥, j√° que ele e todos os descendentes s√£o considerados uma (sub)√°rvore. Geralmente se considera a altura de uma √°rvore vazia como zero."
  },
  {
    "objectID": "disciplinas/aed2/slides/hash.html#profundidade",
    "href": "disciplinas/aed2/slides/hash.html#profundidade",
    "title": "√Årvores",
    "section": "Profundidade",
    "text": "Profundidade\n\n\nDefini√ß√£o\n\n\nA profundidade de um n√≥ √© o n√∫mero de arestas no caminho da raiz at√© esse n√≥.\n\n\nA profundidade do n√≥ J √© 3, pois h√° tr√™s arestas da raiz at√© J. Note que a profundidade da folha mais baixa √© igual a altura da √°rvore.\nA profundidade de um n√≥ indica qual n√≠vel da √°rvore ele pertence. A raiz possui n√≠vel 0, o filhos da raiz n√≠vel 1, os netos da raiz n√≠vel 2 e assim sucessivamente. √â f√°cil concluir que a altura est√° relacionada ao n√∫mero de n√≠veis."
  },
  {
    "objectID": "disciplinas/aed2/slides/hash.html#altura-x-profundidade",
    "href": "disciplinas/aed2/slides/hash.html#altura-x-profundidade",
    "title": "√Årvores",
    "section": "Altura x Profundidade",
    "text": "Altura x Profundidade\n\n\nwidth:400pxConsiderando o n√≥ com chave G, sua altura √© a dist√¢ncia at√© a folha mais baixa (arestas verdes). J√° sua profundidade, √© a dist√¢ncia da raiz at√© G (arestas azuis)."
  },
  {
    "objectID": "disciplinas/aed2/slides/hash.html#grau",
    "href": "disciplinas/aed2/slides/hash.html#grau",
    "title": "√Årvores",
    "section": "Grau",
    "text": "Grau\n\n\nDefini√ß√£o\n\n\nO grau de um n√≥ √© o n√∫mero de filhos que ele possui.\n\n\nNa √°rvore T, o n√≥ B tem grau 2. J√° os n√≥s H e F possuem grau 1 e 0, respectivamente."
  },
  {
    "objectID": "disciplinas/aed2/slides/hash.html#nomenclatura",
    "href": "disciplinas/aed2/slides/hash.html#nomenclatura",
    "title": "√Årvores",
    "section": "Nomenclatura",
    "text": "Nomenclatura\nQuanto ao n√∫mero de filhos, uma √°rvore onde todos os n√≥s possuem somente um filho se comporta como uma lista. Se os n√≥s possuem no m√°ximo dois filhos, a √°rvore √© chamada de bin√°ria. Se tr√™s filhos, chama-se tern√°ria e assim por diante. Uma √°rvore em que os n√≥s possuem no m√°ximo \\(n\\) filhos √© chamada de \\(n\\)-√°ria."
  },
  {
    "objectID": "disciplinas/aed2/slides/hash.html#revis√£o-e-considera√ß√µes",
    "href": "disciplinas/aed2/slides/hash.html#revis√£o-e-considera√ß√µes",
    "title": "√Årvores",
    "section": "Revis√£o e Considera√ß√µes",
    "text": "Revis√£o e Considera√ß√µes"
  },
  {
    "objectID": "disciplinas/aed2/slides/hash.html#resumo",
    "href": "disciplinas/aed2/slides/hash.html#resumo",
    "title": "√Årvores",
    "section": "Resumo",
    "text": "Resumo\nNesta se√ß√£o, estudamos a estrutura de dados √°rvore do forma generalizada. Em particular, estudamos:\n\n\n\nO que √© uma √°rvore e seus componentes (raiz, n√≥, folha etc);\nAltura;\nProfundidade;\nTamanho;\nGrau;\nSub√°rvore."
  },
  {
    "objectID": "disciplinas/aed2/slides/hash.html#considera√ß√µes",
    "href": "disciplinas/aed2/slides/hash.html#considera√ß√µes",
    "title": "√Årvores",
    "section": "Considera√ß√µes",
    "text": "Considera√ß√µes\n\nbg 50% right:20%Todos esses conceitos s√£o fundamentais e, portanto, devemos estar bem familiarizados com eles. No estudo das √°rvores como estruturas de dados, √© imprescind√≠vel dominar as defini√ß√µes de altura, profundidade, sub√°rvore, grau e tamanho.\nNo pr√≥ximo cap√≠tulo da nossa jornada, iremos estudar um tipo especial de √°rvore chamada bin√°ria."
  },
  {
    "objectID": "disciplinas/aed2/slides/hash.html#obrigado",
    "href": "disciplinas/aed2/slides/hash.html#obrigado",
    "title": "√Årvores",
    "section": "Obrigado",
    "text": "Obrigado\nProf.¬†Dr.¬†Bruno Xavier\nCentro Multidisciplinar de Pau dos Ferros Departamento de Engenharias e Tecnologia Algoritmos e Estruturas de Dados 2"
  },
  {
    "objectID": "disciplinas/algoritmos/index.html",
    "href": "disciplinas/algoritmos/index.html",
    "title": "Algoritmos",
    "section": "",
    "text": "Bem-vindo ao portal de REA sobre Algoritmos. Aqui voc√™ encontrar√° informa√ß√µes sobre a bibliografia, aulas ministradas e muito mais.\nEM CONSTRU√á√ÇO\n\n\n\n De volta ao topo"
  },
  {
    "objectID": "disciplinas/aed1/index.html",
    "href": "disciplinas/aed1/index.html",
    "title": "Algoritmos e Estruturas de Dados 1",
    "section": "",
    "text": "Bem-vindo ao portal de REA sobre Algoritmos e Estruturas de Dados 1. Aqui voc√™ encontrar√° informa√ß√µes sobre a bibliografia, aulas ministradas e muito mais.\nEM CONSTRU√á√ÇO\n\n\n\n De volta ao topo"
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "REAComp Blog",
    "section": "",
    "text": "LValues e RValues\n\n\n\nalgoritmo\n\n\n\nEntendendo o que s√£o lvalue e rvalue em C\n\n\n\n18 de out. de 2025\n\n\n\n\n\n\n\n\n\n\n\nFor e While\n\n\n\nalgoritmo\n\n\n\nTutorial de como transformar um la√ßo for em while\n\n\n\n15 de out. de 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\nCompilar Programas em C - Linux\n\n\n\ncompila√ß√£o\n\nlinux\n\nmake\n\n\n\nTutorial de compila√ß√£o de programas em C no Linux\n\n\n\n14 de out. de 2025\n\n\n\n\n\n\nNenhum item correspondente\n De volta ao topo"
  },
  {
    "objectID": "posts/lrvalues.html",
    "href": "posts/lrvalues.html",
    "title": "LValues e RValues",
    "section": "",
    "text": "Se voc√™ j√° levou uma bronca do compilador com uma mensagem parecida com esta:\nerror: lvalue required as left operand of assignment\n‚Ä¶ ent√£o parab√©ns üòÖ voc√™ acabou de esbarrar em um dos conceitos fundamentais da linguagem C: lvalue e rvalue.\nEsses dois nomes parecem sa√≠dos de um feiti√ßo do Harry Potter, mas s√£o bem mais simples do que parecem. Eles est√£o ligados a como o C enxerga o que pode ou n√£o receber um valor.\n\n\nA palavra lvalue vem de ‚Äúleft value‚Äù, ou ‚Äúvalor que pode estar √† esquerda‚Äù, do sinal de igual (=). Em outras palavras, um lvalue √© algo que tem um endere√ßo na mem√≥ria e pode armazenar um valor.\nPense no lvalue como uma caixinha com nome, onde o programa guarda um dado.\nint x = 10;  // x √© um lvalue\nx = 20;      // tudo certo, estamos mudando o valor de x\nAqui, x √© um lvalue. Ele existe em algum lugar da mem√≥ria e pode receber outro valor quando quisermos.\n\n\n\nO rvalue, por outro lado, vem de ‚Äúright value‚Äù, ou ‚Äúvalor que fica √† direita‚Äù do sinal de igual. Ele √© o valor em si, n√£o um local da mem√≥ria.\nint x = 10;\nint y = x + 5; // x + 5 √© um rvalue\nA express√£o x + 5 √© um rvalue. Ela √© apenas o resultado de uma conta, um n√∫mero tempor√°rio que ‚Äúnasce e morre‚Äù dentro dessa linha. Ele n√£o mora em lugar nenhum, ent√£o n√£o d√° pra armazenar nada nele.\n\n\n\nEm toda atribui√ß√£o, temos a mesma estrutura:\n\nlvalue = rvalue;\nO lvalue est√° √† esquerda e precisa ser algo que possa receber um valor.\nO rvalue est√° √† direita e √© o valor que ser√° guardado.\n\n‚úÖ Exemplo certo:\nint a, b;\na = b + 2;\n(a √© lvalue, b + 2 √© rvalue)\n‚ùå Exemplo errado:\nint a, b;\na + b = 2;\nO compilador vai dizer:\nerror: lvalue required as left operand of assignment\nPorque a + b n√£o √© um ‚Äúlugar‚Äù da mem√≥ria, mas apenas o resultado de uma soma.\nüß† Mais exemplos r√°pidos\n\n\n\nC√≥digo\nPode compilar?\nPor qu√™\n\n\n\n\nx = 5;\n‚úÖ\nx √© lvalue, 5 √© rvalue\n\n\n5 = x;\n‚ùå\nLiteral 5 n√£o pode receber valor\n\n\n*ptr = 10;\n‚úÖ\n*ptr √© um lvalue (aponta pra um endere√ßo)\n\n\nptr + 1 = x;\n‚ùå\nResultado de ptr + 1 √© tempor√°rio\n\n\n++x;\n‚úÖ\nx tem endere√ßo, pode ser alterado\n\n\n++(x + 1);\n‚ùå\nx + 1 √© rvalue, n√£o existe na mem√≥ria\n\n\n\nResumindo\n\n\n\nTipo\nPode estar √† esquerda do =?\nTem endere√ßo?\n\n\n\n\nlvalue\n‚úÖ Sim\n‚úÖ Sim\n\n\nrvalue\n‚ùå N√£o\n‚ö†Ô∏è N√£o acess√≠vel\n\n\n\n\nNesta tutorial, voc√™ aprendeu\n‚úÖ os conceitos de lvalue e rvalue\n‚úÖ a evitar erros de compila√ß√£o envolvendo lvalue\n‚úÖ como o C pensa internamente"
  },
  {
    "objectID": "posts/lrvalues.html#o-que-√©-um-lvalue",
    "href": "posts/lrvalues.html#o-que-√©-um-lvalue",
    "title": "LValues e RValues",
    "section": "",
    "text": "A palavra lvalue vem de ‚Äúleft value‚Äù, ou ‚Äúvalor que pode estar √† esquerda‚Äù, do sinal de igual (=). Em outras palavras, um lvalue √© algo que tem um endere√ßo na mem√≥ria e pode armazenar um valor.\nPense no lvalue como uma caixinha com nome, onde o programa guarda um dado.\nint x = 10;  // x √© um lvalue\nx = 20;      // tudo certo, estamos mudando o valor de x\nAqui, x √© um lvalue. Ele existe em algum lugar da mem√≥ria e pode receber outro valor quando quisermos."
  },
  {
    "objectID": "posts/lrvalues.html#e-o-rvalue",
    "href": "posts/lrvalues.html#e-o-rvalue",
    "title": "LValues e RValues",
    "section": "",
    "text": "O rvalue, por outro lado, vem de ‚Äúright value‚Äù, ou ‚Äúvalor que fica √† direita‚Äù do sinal de igual. Ele √© o valor em si, n√£o um local da mem√≥ria.\nint x = 10;\nint y = x + 5; // x + 5 √© um rvalue\nA express√£o x + 5 √© um rvalue. Ela √© apenas o resultado de uma conta, um n√∫mero tempor√°rio que ‚Äúnasce e morre‚Äù dentro dessa linha. Ele n√£o mora em lugar nenhum, ent√£o n√£o d√° pra armazenar nada nele."
  },
  {
    "objectID": "posts/lrvalues.html#ligando-os-pontos",
    "href": "posts/lrvalues.html#ligando-os-pontos",
    "title": "LValues e RValues",
    "section": "",
    "text": "Em toda atribui√ß√£o, temos a mesma estrutura:\n\nlvalue = rvalue;\nO lvalue est√° √† esquerda e precisa ser algo que possa receber um valor.\nO rvalue est√° √† direita e √© o valor que ser√° guardado.\n\n‚úÖ Exemplo certo:\nint a, b;\na = b + 2;\n(a √© lvalue, b + 2 √© rvalue)\n‚ùå Exemplo errado:\nint a, b;\na + b = 2;\nO compilador vai dizer:\nerror: lvalue required as left operand of assignment\nPorque a + b n√£o √© um ‚Äúlugar‚Äù da mem√≥ria, mas apenas o resultado de uma soma.\nüß† Mais exemplos r√°pidos\n\n\n\nC√≥digo\nPode compilar?\nPor qu√™\n\n\n\n\nx = 5;\n‚úÖ\nx √© lvalue, 5 √© rvalue\n\n\n5 = x;\n‚ùå\nLiteral 5 n√£o pode receber valor\n\n\n*ptr = 10;\n‚úÖ\n*ptr √© um lvalue (aponta pra um endere√ßo)\n\n\nptr + 1 = x;\n‚ùå\nResultado de ptr + 1 √© tempor√°rio\n\n\n++x;\n‚úÖ\nx tem endere√ßo, pode ser alterado\n\n\n++(x + 1);\n‚ùå\nx + 1 √© rvalue, n√£o existe na mem√≥ria\n\n\n\nResumindo\n\n\n\nTipo\nPode estar √† esquerda do =?\nTem endere√ßo?\n\n\n\n\nlvalue\n‚úÖ Sim\n‚úÖ Sim\n\n\nrvalue\n‚ùå N√£o\n‚ö†Ô∏è N√£o acess√≠vel\n\n\n\n\nNesta tutorial, voc√™ aprendeu\n‚úÖ os conceitos de lvalue e rvalue\n‚úÖ a evitar erros de compila√ß√£o envolvendo lvalue\n‚úÖ como o C pensa internamente"
  },
  {
    "objectID": "contribuicao.html",
    "href": "contribuicao.html",
    "title": "Participe",
    "section": "",
    "text": "Nosso projeto de Recursos Educacionais Abertos (REA) √© colaborativo e est√° sempre aberto √† participa√ß√£o da comunidade. Se voc√™ √© estudante, docente ou profissional da √°rea de Computa√ß√£o e deseja contribuir com melhorias nos materiais ‚Äî como corre√ß√µes, atualiza√ß√µes, novos exemplos ou conte√∫dos complementares ‚Äî sua colabora√ß√£o ser√° muito bem-vinda!\nTodo o c√≥digo-fonte e os materiais deste portal est√£o dispon√≠veis em um reposit√≥rio p√∫blico no GitHub. Para contribuir, siga os passos abaixo:\nSe voc√™ identificar erros ou quiser apenas deixar sugest√µes, tamb√©m pode abrir uma issue diretamente no reposit√≥rio."
  },
  {
    "objectID": "contribuicao.html#como-posso-contribuir",
    "href": "contribuicao.html#como-posso-contribuir",
    "title": "Participe",
    "section": "Como posso contribuir?",
    "text": "Como posso contribuir?\n\nCorrigindo erros nos materiais (ortografia, l√≥gica, c√≥digo, etc.);\nSugerindo novos exerc√≠cios ou conte√∫dos;\nAdicionando recursos complementares (v√≠deos, slides, links √∫teis);\nSinalizando pontos que precisam de mais clareza ou revis√£o.\n\n\nTodo o conte√∫do aceito ser√° publicado sob uma licen√ßa aberta (Creative Commons), garantindo a reutiliza√ß√£o e o compartilhamento livre, com os devidos cr√©ditos √†s contribui√ß√µes.\nJunte-se a n√≥s nessa constru√ß√£o coletiva de conhecimento!"
  },
  {
    "objectID": "disciplinas.html",
    "href": "disciplinas.html",
    "title": "Recursos Dispon√≠veis",
    "section": "",
    "text": "Explore nossos materiais sobre Algoritmos, Programa√ß√£o em C e Estruturas de Dados.\n\n\n\n\nAlgoritmos\n\n\n\n\n\nPrograma√ß√£o em C\n\n\n\n\n\nEstruturas de Dados I\n\n\n\n\n\nEstruturas de Dados II\n\n\n\n\nClique em uma op√ß√£o para come√ßar!\n\n\n\n Back to top"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Sobre",
    "section": "",
    "text": "Este portal re√∫ne Recursos Educacionais Abertos (REA) desenvolvidos para apoiar o ensino e a aprendizagem em Computa√ß√£o no campus da UFERSA em Pau dos Ferros. A iniciativa tem como foco tr√™s √°reas fundamentais da forma√ß√£o em Computa√ß√£o: Algoritmos, Programa√ß√£o e Estruturas de Dados.\nTodo o conte√∫do disponibilizado aqui √© aberto, gratuito e pode ser reutilizado, adaptado e compartilhado conforme as necessidades de estudantes, docentes e demais interessados. O objetivo √© promover o acesso democr√°tico ao conhecimento, estimular a autonomia no aprendizado e fortalecer a educa√ß√£o p√∫blica de qualidade.\nEste projeto faz parte do compromisso da UFERSA com a inova√ß√£o pedag√≥gica, a inclus√£o digital e a promo√ß√£o da ci√™ncia aberta.\n\n\n\n De volta ao topo"
  },
  {
    "objectID": "posts/fortowhile.html",
    "href": "posts/fortowhile.html",
    "title": "For e While",
    "section": "",
    "text": "Introdu√ß√£o\nOs la√ßos de repeti√ß√£o s√£o ferramentas fundamentais em qualquer linguagem de programa√ß√£o. Eles permitem executar blocos de c√≥digo v√°rias vezes sem precisar reescrev√™-los. Em C, os dois tipos mais comuns s√£o o for e o while.\nMuitos programadores t√™m prefer√™ncia por um ou outro, mas ambos t√™m seu papel. O la√ßo for √© mais usado quando sabemos quantas vezes o c√≥digo deve ser repetido, enquanto o while √© ideal para situa√ß√µes em que a repeti√ß√£o depende de uma condi√ß√£o.\nEmbora possamos criar loops infinitos com o for, o while geralmente √© a melhor escolha quando n√£o sabemos o n√∫mero exato de repeti√ß√µes.\n\n\nSintaxe B√°sica\nA estrutura de um for pode ser escrita assim:\nfor (inicializa√ß√£o; condi√ß√£o; incremento){\n    // c√≥digo que ser√° executado repeditamente\n}\nJ√° o mesmo comportamento pode ser obtido com um while:\ninicializa√ß√£o\nwhile (condi√ß√£o){\n    // c√≥digo que ser√° executado repeditamente\n    incremento\n}\nüí° Exemplo pr√°tico\nA seguir, veja um exemplo simples que imprime uma frase 42 vezes usando for:\nfor (int i = 0; i &lt; 42; i++){\n    puts(\"Volta o c√£o arrependido, \n          com orelhas fartas, seu osso roido \n          e o rabo entre as patas\");\n}\nO mesmo comportamento pode ser obtido com while:\nint i = 0;\nwhile (i &lt; 42){\n    puts(\"Volta o c√£o arrependido, \n          com orelhas fartas, seu osso roido \n          e o rabo entre as patas\");\n    i++;      \n}\nAssim, transformar um for em while √© apenas uma quest√£o de reposicionar as tr√™s partes: inicializa√ß√£o, condi√ß√£o e incremento.\n\n\nLa√ßos infinitos\nUm la√ßo infinito √© aquele que nunca termina, o programa fica preso executando o mesmo bloco de c√≥digo repetidamente, at√© que algo o interrompa (por exemplo, com break, return, ou encerrando o programa manualmente).\nLa√ßos infinitos podem parecer um erro de programa√ß√£o, mas eles t√™m usos pr√°ticos, como em:\n\nprogramas que ficam ‚Äúrodando para sempre‚Äù, como servidores, jogos ou sistemas embarcados;\nloops de espera, que ficam verificando uma condi√ß√£o at√© que algo aconte√ßa.\n\nüîÅ Exemplo com while\nA forma mais comum de criar um la√ßo infinito em C √© com while:\nwhile (1) {\n    printf(\"Executando para sempre...\\n\");\n}\nAqui, a condi√ß√£o √© sempre verdadeira (1 significa true), ent√£o o loop nunca termina.\nüîÅ Exemplo com for\nTamb√©m podemos criar um la√ßo infinito com for, deixando os tr√™s argumentos vazios:\nfor (;;) {\n    printf(\"Executando para sempre...\\n\");\n}\nEsse √© o equivalente exato ao while(1). O compilador entende que n√£o h√° inicializa√ß√£o, nem condi√ß√£o de parada, nem incremento, ent√£o o loop continua indefinidamente.\n‚ö†Ô∏è Cuidados importantes\nCuidado com loops sem sa√≠da, pois se n√£o houver um break ou uma condi√ß√£o de parada dentro do loop, o programa pode travar ou consumir muito processamento.\nUse break para encerrar o loop quando uma condi√ß√£o interna for atendida:\nwhile (1) {\n    int opcao;\n    printf(\"Digite 0 para sair: \");\n    scanf(\"%d\", &opcao);\n    if (opcao == 0)\n        break; // encerra o la√ßo\n}\nEvite loops infinitos acidentais, especialmente ao converter for para while. Se esquecer de atualizar a vari√°vel de controle (i++, por exemplo), o programa pode nunca sair do loop.\nüí° Dica de pr√°tica\nTente modificar o exemplo anterior do ‚ÄúC√£o arrependido‚Äù para rodar infinitamente, e depois adicione uma condi√ß√£o de sa√≠da com break. Assim voc√™ entende bem como o controle de fluxo funciona.\n\nNesta tutorial, voc√™ aprendeu\n‚úÖ a transformar um la√ßo for em while e vice-versa\n‚úÖ como criar la√ß√µes infinitos\n\n\n\n\n De volta ao topo"
  },
  {
    "objectID": "posts/compilation-clinux.html",
    "href": "posts/compilation-clinux.html",
    "title": "Compilar Programas em C - Linux",
    "section": "",
    "text": "Instala√ß√£o do Compilador\nVamos instalar o compilador em sistemas baseados no Ubuntu. Primeiro, atualize o reposit√≥rio de pacotes:\n$ sudo apt update\nEm seguida, instale o pacote build-essential\n$ sudo apt install build-essential\nEste pacote inclui o compilador GCC e outras ferramentas de desenvolvimento necess√°rias.\nPara a verificar a instala√ß√£o, fa√ßa:\n$ gcc --version\n\n\nCompila√ß√£o Simples\nPara compilar um programa em C, use o comando\n$ gcc file.c -o file\nOnde file.c √© o nome do seu arquivo de c√≥digo fonte. Voc√™ pode escolher qualquer nome para o terceiro argumento. No caso acima, escolhemos file. Para executar o programa, fa√ßa:\n$ ./file\n\n\nCompila√ß√£o M√∫ltipla\nNesta abordagem, estamos tratando de um projeto com mais de um arquivo .c. Vamos exemplificar dessa maneira:\nPrimeiro o arquivo de cabe√ßalho contendo a interface das fun√ß√µes e outras defini√ß√µes:\n\n\ninterface.h\n\n#ifndef INTERFACE_H\n#define INTERFACE_H\n\n// Includes necess√°rios\n// Declara√ß√µes\n\n#endif\n\nEsse arquivo √© apenas um prototipagem, n√£o h√° c√≥digo execut√°vel.\nEm seguida, o arquivo com as implementa√ß√µes reais:\n\n\ninterface.c\n\n// Includes\n#include \"interface.h\"\n// Implementa√ß√£o das fun√ß√µes declaradas em interface.h\n\nTodas as fun√ß√µes aqui que foram declaradas no .h, ent√£o est√£o vis√≠veis para outros arquivos que inclu√≠rem interface.h. Caso criemos fun√ß√µes auxiliares n√£o declaradas no .h, ent√£o elas ficam privadas a este m√≥dulo (invis√≠veis fora dele).\nFinalmente, o arquivo principal (cont√©m a main) que usar√° a implementa√ß√£o dos arquivos anteriores.\n\n\nprograma.c\n\n// Includes\n#include \"interface.h\"\n// Uso\n\nObserve que programa.c n√£o precisa incluir interface.c, apenas o cabe√ßalho.\nPara compilar esse projeto, use o comando\n$ gcc interface.c programa.c -o programa\nPara executar o programa, fa√ßa:\n$ ./programa\nTamb√©m podemos compilar em duas etapas (√∫til em projetos maiores):\n$ gcc -c interface.c -o interface.o\n$ gcc -c programa.c -o programa.o\n$ gcc interface.o programa.o -o programa\nA flag -c indica para o gcc que compile o c√≥digo-fonte (.c) em c√≥digo objeto (.o). Ele n√£o faz o linking, ou seja, n√£o gera o execut√°vel final ainda. No √∫ltimo comando, o compilador faz o linking para gerar o execut√°vel. Nessa abordagem, se algum arquivo for modificado, s√≥ ser√° necess√°rio recompilar ele e n√£o todo o projeto.\n\n\nAutomatiza√ß√£o\nUm dos utilit√°rios que o pacote build-essential traz √© o make. O make evita recompilar manualmente tudo. Al√©m de ser um processo automatizado, ele recompila apenas o que mudou, mantendo o nosso projeto organizado e escal√°vel. Para essa abordagem √© necess√°rio criar um arquivo na pasta do nosso projeto chamado Makefile (sem extens√£o).\n\n\n\n\n\ngraph TD\n    A[\"Projeto/\"]:::folder\n    A --&gt; B[\"interface.h\"]:::file\n    A --&gt; C[\"interface.c\"]:::file\n    A --&gt; D[\"programa.c\"]:::file\n    A --&gt; E[\"Makefile\"]:::file\n\n    classDef folder fill:#e6f7ff,stroke:#0077b6,stroke-width:2px,color:#023e8a,font-weight:bold;\n    classDef file fill:#fff,stroke:#999,stroke-width:1px,color:#333;\n\n\n\n\n\n\nUm exemplo de arquivo Makefile seria esse:\n\n\nMakefile\n\n# Nome do execut√°vel final\nPROG = programa\n\n# Compilador\nCC = gcc\n\n# Arquivos fonte e objetos\nSRC = interface.c programa.c\nOBJ = $(SRC:.c=.o)\n\n# Regra padr√£o (executada quando voc√™ roda apenas `make`)\nall: $(PROG)\n\n# Regra para gerar o execut√°vel\n$(PROG): $(OBJ)\n    $(CC) $(OBJ) -o $(PROG)\n\n# Regra gen√©rica para compilar cada .c em .o\n%.o: %.c\n    $(CC) -c $&lt; -o $@\n\n# Limpeza dos arquivos tempor√°rios\nclean:\n    rm -f $(OBJ) $(PROG)\n\nAo executar o comando make no terminal, vamos obter a sa√≠da:\n$ make\ngcc -c interface.c -o interface.o\ngcc -c programa.c -o programa.o\ngcc interface.o programa.o -o programa\nAgora imagine que programa.c foi modificado. Ent√£o somente ele ser√° recompilado e tudo ser√° ‚Äúlinkado‚Äù novamente no final.\n$ make\ngcc -c programa.c -o programa.o\ngcc interface.o programa.o -o programa\nO comando make clean ir√° apagar o arquivo bin√°rio e os arquivos objeto.\n$ make clean\nrm -f interface.o programa.o programa\n\nNesta tutorial, voc√™ aprendeu\n‚úÖ a instalar o compilador GCC\n‚úÖ a compilar um programa em C\n‚úÖ a compilar um projeto em C usando um ou m√∫ltiplos comandos\n‚úÖ a usar o utilit√°rio make para automatizar o processo de compila√ß√£o\nTudo isso em um sistema operacional baseado no Ubuntu.\n\n\n\n\n De volta ao topo"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Recursos Educacionais Abertos",
    "section": "",
    "text": "O movimento de Recursos Educacionais Abertos (REA) √© impulsionado pela internet e plataformas digitais, buscando tornar o conhecimento mais acess√≠vel. Eles permitem que terceiros os utilizem, adaptem e distribuam livremente, promovendo o acesso universal √† educa√ß√£o.\nA Universidade Federal Rural do Semi-√Årido (Ufersa) oferece REA atrav√©s da sua Biblioteca Digital de Recursos Educacionais Abertos (BDREA), um reposit√≥rio que disponibiliza materiais did√°ticos sob licen√ßas abertas e em dom√≠nio p√∫blico para uso e adapta√ß√£o por terceiros. Estes materiais incluem textos, imagens e outras ferramentas que visam promover o acesso gratuito e apropria√ß√£o do conhecimento.\nEste portal oferece REA na √°rea da computa√ß√£o e serve como recurso extra no processo de ensino-aprendizagem em algoritmos, programa√ß√£o e estruturas de dados.\nPara come√ßar a estudar pelo nosso material, clique no menu Recursos .\n\n\n\n De volta ao topo"
  },
  {
    "objectID": "disciplinas/programacaoc/index.html",
    "href": "disciplinas/programacaoc/index.html",
    "title": "Programa√ß√£o em C",
    "section": "",
    "text": "Bem-vindo ao portal de REA sobre Programa√ß√£o em C. Aqui voc√™ encontrar√° informa√ß√µes sobre a bibliografia, aulas ministradas e muito mais.\nEM CONSTRU√á√ÇO\n\n\n\n De volta ao topo"
  },
  {
    "objectID": "disciplinas/aed2/slides/mermaid-ex.html",
    "href": "disciplinas/aed2/slides/mermaid-ex.html",
    "title": "Mermaid",
    "section": "",
    "text": "BST\n\n\n\n\n\nflowchart TD\n    A((\"8\")) --&gt; B((\"3\")) & C((\"10\"))\n    B --&gt; D((\"1\")) & E((\"6\"))\n    C --&gt; F((\"9\")) & G((\"14\"))\n    E --&gt; H((\"4\")) & I((\"7\"))\n\n    style A fill:#C8E6C9\n    style B fill:#BBDEFB\n    style C fill:#FFCDD2\n    style D fill:#BBDEFB\n    style E fill:#BBDEFB\n    style F fill:#FFCDD2\n    style G fill:#FFCDD2\n    style H fill:#BBDEFB\n    style I fill:#BBDEFB\n\n\n\n\n\n\nAdd1\n\n\n\n\n\nflowchart TD\n    A((\"15\"))\n\n\n\n\n\n\nAdd2\n\n\n\n\n\nflowchart TD\n    A((\"15\")) L_A_B_0@--&gt; B((\"10\"))\n    A ~~~ N((\" \"))\n\n    style N stroke:none,fill:transparent\n\n    L_A_B_0@{ animation: slow } \n\n\n\n\n\n\nAdd3\n\n\n\n\n\nflowchart TD\n    A((\"15\")) --&gt; B((\"10\"))\n    A L_A_N_0@--&gt; N((\"20\"))\n\n    L_A_N_0@{ animation: slow } \n\n\n\n\n\n\nAdd4\n\n\n\n\n\nflowchart TD\n    A((\"15\")) L_A_B_0@--&gt; B((\"10\"))\n    A --&gt; C((\"20\"))\n    B L_B_D_0@--&gt; D((\"8\"))\n    B ~~~ N((\" \"))\n\n    style N stroke:none,fill:transparent\n\n    L_A_B_0@{ animation: slow }\n    L_B_D_0@{ animation: slow } \n\n\n\n\n\n\nAdd5\n\n\n\n\n\nflowchart TD\n    A((\"15\")) L_A_B_0@--&gt; B((\"10\"))\n    A --&gt; C((\"20\"))\n    B --&gt; D((\"8\"))\n    B L_B_E_0@--&gt; E((\"12\"))\n\n \n    L_A_B_0@{ animation: slow }\n    L_B_E_0@{ animation: slow } \n\n\n\n\n\n\nAdd6\n\n\n\n\n\nflowchart TD\n    A((\"15\")) --&gt; B((\"10\"))\n    A --&gt; C((\"20\"))\n    B --&gt; D((\"8\"))\n    B --&gt; E((\"12\"))\n    C --&gt; F((\"17\"))\n    C ~~~ N((\" \"))\n \n    style N stroke:none,fill:transparent\n\n    L_A_C_0@{ animation: slow }\n    L_C_F_0@{ animation: slow } \n\n\n\n\n\n\nAdd7\n\n\n\n\n\nflowchart TD\n    A((\"15\")) --&gt; B((\"10\"))\n    A --&gt; C((\"20\"))\n    B --&gt; D((\"8\"))\n    B --&gt; E((\"12\"))\n    C --&gt; F((\"17\"))\n    C --&gt; G((\"25\"))\n \n    L_A_C_0@{ animation: slow }\n    L_C_G_0@{ animation: slow } \n\n\n\n\n\n\nAltura e Profundidade\n\n\n\n\n\nflowchart TD\n    A((\"A\")) --- B((\"B\"))\n    A === C((\"C\"))\n    B --- D((\"D\")) & E((\"E\"))\n    C --- F((\"F\"))\n    C === G((\"G\"))\n    G === H((\"H\"))\n    G --- I((\"I\"))\n    H === J((\"J\"))\n    H --- K((\"K\"))\n\n    style A fill:#BBDEFB\n    style C fill:#BBDEFB\n    style G fill:#FFE0B2\n    style H fill:#C8E6C9\n    style J fill:#C8E6C9\n    linkStyle 1 stroke:#2962FF,fill:none\n    linkStyle 5 stroke:#2962FF,fill:none\n    linkStyle 6 stroke:#00C853,fill:none\n    linkStyle 8 stroke:#00C853\n\n\n\n\n\n\nAVLEx\n\n\n\n\n\n---\nconfig:\n  layout: elk\n---\nflowchart TD\n    A((\"30\")) --&gt; B((\"20\")) & C((\"40\"))\n    A -.-&gt; FB_A[\"fb=0\"]\n    B -.-&gt; FB_B[\"fb=+1\"]\n    C -.-&gt; FB_C[\"fb=-1\"]\n     FB_A:::fb\n     FB_B:::fb\n     FB_C:::fb\n    classDef fb fill:#ffd,stroke:#333,stroke-dasharray:2 2,font-size:10px\n\n\n\n\n\n\n\n\n\n\n\nflowchart TD\n    A[\"12&lt;br/&gt;+1\"] --- B[\"8&lt;br/&gt;+1\"] & C[\"18&lt;br/&gt;+1\"]\n    B --- D[\"5&lt;br/&gt;+1\"] & E[\"11&lt;br/&gt;0\"]\n    C --- F[\"17&lt;br/&gt;0\"]\n    C ~~~ G[\" \"]\n    D --- H[\"4&lt;br/&gt;0\"]\n    D ~~~ I[\" \"]\n    \n    classDef circleish rx:50,ry:50;\n    A:::circleish\n    B:::circleish\n    C:::circleish\n    D:::circleish\n    E:::circleish\n    F:::circleish \n    H:::circleish\n\n    style G fill:transparent,stroke:none\n    style I fill:transparent,stroke:none\n    style D min-height: 50px, padding: 5px 10px\n    A:::largeNode\n    B:::largeNode"
  },
  {
    "objectID": "disciplinas/aed2/slides/mermaid-ex.html#√°rvores",
    "href": "disciplinas/aed2/slides/mermaid-ex.html#√°rvores",
    "title": "Mermaid",
    "section": "",
    "text": "BST\n\n\n\n\n\nflowchart TD\n    A((\"8\")) --&gt; B((\"3\")) & C((\"10\"))\n    B --&gt; D((\"1\")) & E((\"6\"))\n    C --&gt; F((\"9\")) & G((\"14\"))\n    E --&gt; H((\"4\")) & I((\"7\"))\n\n    style A fill:#C8E6C9\n    style B fill:#BBDEFB\n    style C fill:#FFCDD2\n    style D fill:#BBDEFB\n    style E fill:#BBDEFB\n    style F fill:#FFCDD2\n    style G fill:#FFCDD2\n    style H fill:#BBDEFB\n    style I fill:#BBDEFB\n\n\n\n\n\n\nAdd1\n\n\n\n\n\nflowchart TD\n    A((\"15\"))\n\n\n\n\n\n\nAdd2\n\n\n\n\n\nflowchart TD\n    A((\"15\")) L_A_B_0@--&gt; B((\"10\"))\n    A ~~~ N((\" \"))\n\n    style N stroke:none,fill:transparent\n\n    L_A_B_0@{ animation: slow } \n\n\n\n\n\n\nAdd3\n\n\n\n\n\nflowchart TD\n    A((\"15\")) --&gt; B((\"10\"))\n    A L_A_N_0@--&gt; N((\"20\"))\n\n    L_A_N_0@{ animation: slow } \n\n\n\n\n\n\nAdd4\n\n\n\n\n\nflowchart TD\n    A((\"15\")) L_A_B_0@--&gt; B((\"10\"))\n    A --&gt; C((\"20\"))\n    B L_B_D_0@--&gt; D((\"8\"))\n    B ~~~ N((\" \"))\n\n    style N stroke:none,fill:transparent\n\n    L_A_B_0@{ animation: slow }\n    L_B_D_0@{ animation: slow } \n\n\n\n\n\n\nAdd5\n\n\n\n\n\nflowchart TD\n    A((\"15\")) L_A_B_0@--&gt; B((\"10\"))\n    A --&gt; C((\"20\"))\n    B --&gt; D((\"8\"))\n    B L_B_E_0@--&gt; E((\"12\"))\n\n \n    L_A_B_0@{ animation: slow }\n    L_B_E_0@{ animation: slow } \n\n\n\n\n\n\nAdd6\n\n\n\n\n\nflowchart TD\n    A((\"15\")) --&gt; B((\"10\"))\n    A --&gt; C((\"20\"))\n    B --&gt; D((\"8\"))\n    B --&gt; E((\"12\"))\n    C --&gt; F((\"17\"))\n    C ~~~ N((\" \"))\n \n    style N stroke:none,fill:transparent\n\n    L_A_C_0@{ animation: slow }\n    L_C_F_0@{ animation: slow } \n\n\n\n\n\n\nAdd7\n\n\n\n\n\nflowchart TD\n    A((\"15\")) --&gt; B((\"10\"))\n    A --&gt; C((\"20\"))\n    B --&gt; D((\"8\"))\n    B --&gt; E((\"12\"))\n    C --&gt; F((\"17\"))\n    C --&gt; G((\"25\"))\n \n    L_A_C_0@{ animation: slow }\n    L_C_G_0@{ animation: slow } \n\n\n\n\n\n\nAltura e Profundidade\n\n\n\n\n\nflowchart TD\n    A((\"A\")) --- B((\"B\"))\n    A === C((\"C\"))\n    B --- D((\"D\")) & E((\"E\"))\n    C --- F((\"F\"))\n    C === G((\"G\"))\n    G === H((\"H\"))\n    G --- I((\"I\"))\n    H === J((\"J\"))\n    H --- K((\"K\"))\n\n    style A fill:#BBDEFB\n    style C fill:#BBDEFB\n    style G fill:#FFE0B2\n    style H fill:#C8E6C9\n    style J fill:#C8E6C9\n    linkStyle 1 stroke:#2962FF,fill:none\n    linkStyle 5 stroke:#2962FF,fill:none\n    linkStyle 6 stroke:#00C853,fill:none\n    linkStyle 8 stroke:#00C853\n\n\n\n\n\n\nAVLEx\n\n\n\n\n\n---\nconfig:\n  layout: elk\n---\nflowchart TD\n    A((\"30\")) --&gt; B((\"20\")) & C((\"40\"))\n    A -.-&gt; FB_A[\"fb=0\"]\n    B -.-&gt; FB_B[\"fb=+1\"]\n    C -.-&gt; FB_C[\"fb=-1\"]\n     FB_A:::fb\n     FB_B:::fb\n     FB_C:::fb\n    classDef fb fill:#ffd,stroke:#333,stroke-dasharray:2 2,font-size:10px\n\n\n\n\n\n\n\n\n\n\n\nflowchart TD\n    A[\"12&lt;br/&gt;+1\"] --- B[\"8&lt;br/&gt;+1\"] & C[\"18&lt;br/&gt;+1\"]\n    B --- D[\"5&lt;br/&gt;+1\"] & E[\"11&lt;br/&gt;0\"]\n    C --- F[\"17&lt;br/&gt;0\"]\n    C ~~~ G[\" \"]\n    D --- H[\"4&lt;br/&gt;0\"]\n    D ~~~ I[\" \"]\n    \n    classDef circleish rx:50,ry:50;\n    A:::circleish\n    B:::circleish\n    C:::circleish\n    D:::circleish\n    E:::circleish\n    F:::circleish \n    H:::circleish\n\n    style G fill:transparent,stroke:none\n    style I fill:transparent,stroke:none\n    style D min-height: 50px, padding: 5px 10px\n    A:::largeNode\n    B:::largeNode"
  },
  {
    "objectID": "disciplinas/aed2/slides/mermaid-ex.html#ponteiros",
    "href": "disciplinas/aed2/slides/mermaid-ex.html#ponteiros",
    "title": "Mermaid",
    "section": "Ponteiros",
    "text": "Ponteiros\n\n\n\n\n\nflowchart RL\n    %% N√≥s de vari√°veis e ponteiros\n    X[\"üì¶ &lt;b&gt;x&lt;/b&gt;&lt;br/&gt;Endere√ßo: &lt;code&gt;0x100&lt;/code&gt;&lt;br/&gt;Conte√∫do: &lt;b&gt;42&lt;/b&gt;\"]\n    Y[\"üì¶ &lt;b&gt;y&lt;/b&gt;&lt;br/&gt;Endere√ßo: &lt;code&gt;0x200&lt;/code&gt;&lt;br/&gt;Conte√∫do: &lt;b&gt;137&lt;/b&gt;\"]\n    P[\"üéØ &lt;b&gt;p&lt;/b&gt;&lt;br/&gt;Endere√ßo: &lt;code&gt;0x300&lt;/code&gt;&lt;br/&gt;Conte√∫do: &lt;code&gt;0x100&lt;/code&gt;\"]\n    PP[\"üéØ &lt;b&gt;pp&lt;/b&gt;&lt;br/&gt;Endere√ßo: &lt;code&gt;0x400&lt;/code&gt;&lt;br/&gt;Conte√∫do: &lt;code&gt;0x300&lt;/code&gt;\"]\n\n    %% Conex√µes\n    PP --&gt;|\"aponta para\"| P\n    P --&gt;|\"aponta para\"| X\n    P ~~~ Y\n    Y ~~~ X\n\n    %% Estilos de formata√ß√£o\n    classDef var fill:#A8E6CF,stroke:#2E7D32,color:#000,stroke-width:1px;\n    classDef ptr fill:#FFD3B6,stroke:#E65100,color:#000,stroke-width:1px;\n    class X,Y var\n    class P,PP ptr\n\n\n\n\n\n\n\n\n\n\n\nflowchart LR\n subgraph s1[\" \"]\n        X[\"üì¶ &lt;b&gt;meta&lt;/b&gt;&lt;br&gt;Endere√ßo: &lt;code&gt;0xe8&lt;/code&gt;&lt;br&gt;Conte√∫do: &lt;b&gt;7.5&lt;/b&gt;\"]\n        Y[\"üì¶ &lt;b&gt;meta&lt;/b&gt;&lt;br&gt;Endere√ßo: &lt;code&gt;0xc0&lt;/code&gt;&lt;br&gt;Conte√∫do: &lt;b&gt;7.5&lt;/b&gt;\"]\n  end\n\n subgraph s2[\" \"]\n        A[\"üì¶ &lt;b&gt;meta&lt;/b&gt;&lt;br&gt;Endere√ßo: &lt;code&gt;0xe8&lt;/code&gt;&lt;br&gt;Conte√∫do: &lt;b&gt;7.5&lt;/b&gt;\"]\n        B[\"üì¶ &lt;b&gt;meta&lt;/b&gt;&lt;br&gt;Endere√ßo: &lt;code&gt;0xc0&lt;/code&gt;&lt;br&gt;Conte√∫do: &lt;b&gt;15&lt;/b&gt;\"]\n  end\n\n    s1 --dobrar_meta--&gt; s2\n    \n     X:::var\n     Y:::var\n     A:::var\n     B:::var\n    classDef var fill:#A8E6CF,stroke:#2E7D32,color:#000,stroke-width:1px\n    style s1 fill:transparent\n    style s2 fill:transparent\n\n\n\n\n\n\n\n\n\n\n\n\nflowchart LR\n subgraph s1[\" \"]\n        X[\"üì¶ &lt;b&gt;meta&lt;/b&gt;&lt;br&gt;Endere√ßo: &lt;code&gt;0xe8&lt;/code&gt;&lt;br&gt;Conte√∫do: &lt;b&gt;7.5&lt;/b&gt;\"]\n        Y[\"üéØ &lt;b&gt;meta&lt;/b&gt;&lt;br&gt;Endere√ßo: &lt;code&gt;0xc0&lt;/code&gt;&lt;br&gt;Conte√∫do: &lt;b&gt;0xe8&lt;/b&gt;\"]\n  end\n subgraph s2[\" \"]\n        A[\"üì¶ &lt;b&gt;meta&lt;/b&gt;&lt;br&gt;Endere√ßo: &lt;code&gt;0xe8&lt;/code&gt;&lt;br&gt;Conte√∫do: &lt;b&gt;15&lt;/b&gt;\"]\n        B[\"üéØ &lt;b&gt;meta&lt;/b&gt;&lt;br&gt;Endere√ßo: &lt;code&gt;0xc0&lt;/code&gt;&lt;br&gt;Conte√∫do: &lt;b&gt;0xe8&lt;/b&gt;\"]\n  end\n    s1 -- dobrar_meta --&gt; s2\n\n     X:::var\n     Y:::ptr\n     A:::var\n     B:::ptr\n    classDef var fill:#A8E6CF,stroke:#2E7D32,color:#000,stroke-width:1px\n    classDef ptr fill:#FFD3B6,stroke:#E65100,color:#000,stroke-width:1px;\n    style s1 fill:transparent\n    style s2 fill:transparent\n\n\n\n\n\n\nint x = 10;\nint *ptr = &x;\nint y = *ptr;  // desreferencia√ß√£o\n\n\n\n\n\nsequenceDiagram\n    participant Stack as Mem√≥ria (Stack)\n    participant X as Vari√°vel x\n    participant Ptr as Ponteiro ptr\n    participant CPU as CPU/Programa\n\n    Note over CPU,Stack: Declara√ß√£o e atribui√ß√£o inicial\n    CPU-&gt;&gt;Stack: Aloca espa√ßo para x = 10\n    Stack-&gt;&gt;X: Cria x (valor=10, endere√ßo=0x1000)\n\n    Note over CPU,Ptr: Ponteiro recebe o endere√ßo de x\n    CPU-&gt;&gt;Ptr: ptr = &x\n    Ptr-&gt;&gt;Stack: Guarda endere√ßo 0x1000\n\n    Note over CPU,Stack: Desreferencia√ß√£o\n    CPU-&gt;&gt;Ptr: l√™ conte√∫do de ptr\n    Ptr--&gt;&gt;Stack: endere√ßo 0x1000\n    Stack--&gt;&gt;CPU: retorna valor armazenado (10)\n    CPU-&gt;&gt;Stack: y = 10\n\n    Note right of CPU: *ptr l√™ o valor armazenado em x\n\n\n\n\n\n\nint *ptr = &x;\n\n\n\n\n\nsequenceDiagram\n    participant CPU as CPU / Programa\n    participant Stack as Mem√≥ria (Stack)\n    participant X as Vari√°vel x\n    participant Ptr as Ponteiro ptr\n\n    Note over CPU,Stack: Declara√ß√£o e atribui√ß√£o de ponteiro\n    CPU-&gt;&gt;Stack: Aloca vari√°vel x = 10 (endere√ßo 0x1000)\n    Stack-&gt;&gt;X: Cria x (valor = 10)\n\n    CPU-&gt;&gt;Stack: Aloca vari√°vel ponteiro ptr\n    CPU-&gt;&gt;Ptr: ptr = &x\n    Ptr-&gt;&gt;Stack: Guarda o endere√ßo de x (0x1000)\n\n    Note right of Ptr: ptr aponta para o endere√ßo de x\n\n\n\n\n\n\nint y = *ptr;\n\n\n\n\n\nsequenceDiagram\n    participant CPU as CPU / Programa\n    participant Ptr as Ponteiro ptr\n    participant Stack as Mem√≥ria (Stack)\n    participant X as Vari√°vel x\n\n    Note over CPU,Ptr: Desreferencia√ß√£o (*ptr)\n    CPU-&gt;&gt;Ptr: Solicita conte√∫do apontado por ptr\n    Ptr--&gt;&gt;Stack: Envia endere√ßo armazenado (0x1000)\n    Stack--&gt;&gt;X: Acessa a c√©lula de mem√≥ria de x\n    X--&gt;&gt;Stack: Retorna valor = 10\n    Stack--&gt;&gt;CPU: Retorna 10 (valor apontado por ptr)\n    CPU-&gt;&gt;Stack: Atribui y = 10\n\n    Note right of CPU: *ptr l√™ o valor armazenado em x"
  },
  {
    "objectID": "disciplinas/aed2/slides/mermaid-ex.html#tabela-hash",
    "href": "disciplinas/aed2/slides/mermaid-ex.html#tabela-hash",
    "title": "Mermaid",
    "section": "Tabela Hash",
    "text": "Tabela Hash\n\n\n\n\n\nflowchart LR\n subgraph s1[\"üîë Chaves\"]\n        A0[\"'ma√ß√£'\"]\n        B0[\"'uva'\"]\n        C0[\"'laranja'\"]\n        D0[\"'banana'\"]\n  end\n subgraph s2[\"‚öôÔ∏è Fun√ß√£o Hash\"]\n  end\n subgraph s3[\"üìä Tabela Hash\"]\n        A2[\"√çndice 0: ‚ùå      \"]\n        B2[\"√çndice 1: 'laranja'\"]\n        C2[\"√çndice 2: 'uva'\"]\n        D2[\"√çndice 3: 'ma√ß√£'\"]\n        E2[\"√çndice 4: 'banana'\"]\n  end\n    A0 ==&gt; s2\n    B0 ==&gt; s2\n    C0 ==&gt; s2\n    D0 ==&gt; s2\n    s2 ==\"hash('laranja')=1\"==&gt; B2\n    s2 ==\"hash('uva')=2\"==&gt; C2\n    s2 ==\"hash('ma√ß√£')=3\"==&gt; D2\n    s2 ==\"hash('banana')=4\"==&gt; E2\n\n    classDef box fill:#fff,stroke:#000,color:#000,stroke-width:1px;\n    \n    class A0 box\n    class B0 box\n    class C0 box\n    class D0 box\n    class A2 box\n    class B2 box\n    class C2 box\n    class D2 box\n    class E2 box\n    \n    style s2 stroke:none,fill:#BBDEFB\n    style s1 stroke:none,fill:#FFE0B2\n    style s3 stroke:none,fill:#FFE0B2\n    \n    linkStyle 0 stroke:#D50000,fill:none\n    linkStyle 1 stroke:#00C853,fill:none\n    linkStyle 2 stroke:#2962FF,fill:none\n    linkStyle 4 stroke:#2962FF\n    linkStyle 5 stroke:#00C853,fill:none\n    linkStyle 6 stroke:#D50000,fill:none\n\n\n\n\n\n\n\n\n\n\n\nflowchart TD\n subgraph s1[\" \"]\n        n1[\"Filled Circle\"]\n        C0@{ label: \"'laranja'\" }\n        B0@{ label: \"'uva'\" }\n        n2[\"Filled Circle\"]\n        n3[\"Filled Circle\"]\n        A0@{ label: \"'ma√ß√£'\" }\n        E0@{ label: \"'morango'\" }\n        n4[\"Filled Circle\"]\n        D0@{ label: \"'banana'\" }\n        n5[\"Filled Circle\"]\n  end\n subgraph s3[\"Tabela Hash\"]\n        A2[\"√çndice 0\"]\n        B2[\"√çndice 1\"]\n        C2[\"√çndice 2\"]\n        D2[\"√çndice 3\"]\n        E2[\"√çndice 4\"]\nend\n    A2 ==&gt; n1\n    B2 ==&gt; C0\n    C0 ==&gt; B0\n    B0 ==&gt; n2\n    C2 ==&gt; n3\n    D2 ==&gt; A0\n    A0 ==&gt; E0\n    E0 ==&gt; n4\n    E2 ==&gt; D0\n    D0 ==&gt; n5\n    A0@{ shape: rect}\n    B0@{ shape: rect}\n    C0@{ shape: rect}\n    D0@{ shape: rect}\n    n1@{ shape: f-circ}\n    n2@{ shape: f-circ}\n    n3@{ shape: f-circ}\n    n4@{ shape: f-circ}\n    n5@{ shape: f-circ}\n    \n    classDef box fill:#fff,stroke:#000,color:#000,stroke-width:1px;\n    \n    class A0 box\n    class B0 box\n    class C0 box\n    class D0 box\n    class E0 box\n    class A2 box\n    class B2 box\n    class C2 box\n    class D2 box\n    class E2 box\n    \n    style s1 stroke:none,fill:transparent\n    style s3 stroke:none,fill:#FFE0B2\n\n\n\n\n\n\n\n\n\n\n\nflowchart LR\n subgraph s1[\"üîë Chaves\"]\n        A0@{ label: \"'ma√ß√£'\" }\n        B0@{ label: \"'uva'\" }\n        C0@{ label: \"'laranja'\" }\n        D0@{ label: \"'banana'\" }\n        E0@{ label: \"'morango'\" }\n  end\n subgraph s2[\"‚öôÔ∏è Fun√ß√£o Hash\"]\n  end\n subgraph s3[\"üìä Tabela Hash\"]\n        A2[\"√çndice 0: ‚ùå\"]\n        B2[\"√çndice 1: üîó\"]\n        C2[\"√çndice 2: üîó\"]\n        D2[\"√çndice 3: üîó\"]\n        E2[\"√çndice 4: üîó\"]\n  end\n subgraph s4[\" \"]\n        C1@{ label: \"üéØ 'uva'\" }\n        B1@{ label: \"üéØ 'laranja'\" }\n        A1@{ label: \"üéØ 'ma√ß√£'\" }\n        D1@{ label: \"üéØ 'banana'\" }\n        E1@{ label: \"üéØ 'morango'\" }\n        n1[\"NULL\"]\n        n2[\"NULL\"]\n        n3[\"NULL\"]\n        n4[\"NULL\"]\n  end\n    A0 ==&gt; s2\n    B0 ==&gt; s2\n    C0 ==&gt; s2\n    D0 ==&gt; s2\n    E0 ==&gt; s2\n    s2 ==&gt; B2 & C2 & D2 & E2\n    B2 -.- C1\n    C2 -.- B1\n    D2 -.- A1\n    E2 -.- D1\n    A1 --&gt; E1\n    C1 --&gt; n1\n    B1 --&gt; n2\n    E1 --&gt; n3\n    D1 --&gt; n4\n\n    A0@{ shape: rect}\n    B0@{ shape: rect}\n    C0@{ shape: rect}\n    D0@{ shape: rect}\n    E0@{ shape: rect}\n    B2@{ shape: rect}\n    C2@{ shape: rect}\n    D2@{ shape: rect}\n    E2@{ shape: rect}\n    C1@{ shape: subproc}\n    B1@{ shape: subproc}\n    A1@{ shape: subproc}\n    D1@{ shape: subproc}\n    E1@{ shape: subproc}\n    n1@{ shape: subproc}\n    n2@{ shape: subproc}\n    n3@{ shape: subproc}\n    n4@{ shape: subproc}\n     A0:::box\n     B0:::box\n     C0:::box\n     D0:::box\n     E0:::box\n     A2:::box\n     B2:::box\n     C2:::box\n     D2:::box\n     E2:::box\n     n1:::NULL_NODE\n     n2:::NULL_NODE\n     n3:::NULL_NODE\n     n4:::NULL_NODE\n    classDef box fill:#fff,stroke:#000,color:#000,stroke-width:1px\n    classDef NULL_NODE fill:#F5F5F5, stroke:#BDBDBD, color:#757575, stroke-dasharray: 5 5\n    style s2 stroke:none,fill:#BBDEFB\n    style s1 stroke:none,fill:#FFE0B2\n    style s3 stroke:none,fill:#FFE0B2\n    style s4 stroke:none,fill:transparent\n    linkStyle 0 stroke:#D50000,fill:none\n    linkStyle 1 stroke:#00C853,fill:none\n    linkStyle 2 stroke:#2962FF,fill:none\n    linkStyle 4 stroke:#D50000,fill:none\n    linkStyle 5 stroke:#00C853,fill:none\n    linkStyle 6 stroke:#2962FF,fill:none\n    linkStyle 7 stroke:#D50000,fill:none"
  },
  {
    "objectID": "disciplinas/aed2/academic/index.html",
    "href": "disciplinas/aed2/academic/index.html",
    "title": "Algoritmos e Estruturas de Dados 2",
    "section": "",
    "text": "Bem-vindo(a) ao curso de Algoritmos e Estruturas de Dados 2!\n\nEste m√≥dulo est√° dividido em cinco temas centrais. Clique em qualquer um deles para expandir o conte√∫do e navegar pelos subt√≥picos espec√≠ficos.\n\n\n\n\n\n\n\n\nNota Estruturas Gen√©ricas\n\n\n\n\n\n\n1. Ponteiros (Revis√£o) 2. Callbacks 3. Gerenciamento de Mem√≥ria 4. Calculadora Gen√©rica 5. Lista Gen√©rica\n\n\n\n\n\n\n\n\n\n\nNota Tabela de Dispers√£o\n\n\n\n\n\n\n1. Introdu√ß√£o 2. Fun√ß√£o Hash 3. Tratamento de Colis√µes 4. Tabela de Dispers√£o Din√¢mica\n\n\n\n\n\n\n\n\n De volta ao topo"
  },
  {
    "objectID": "disciplinas/aed2/academic/unidade2/5-lista.html",
    "href": "disciplinas/aed2/academic/unidade2/5-lista.html",
    "title": "Lista Gen√©rica",
    "section": "",
    "text": "Nesta unidade, iremos implementar uma lista gen√©rica. As fun√ß√µes de callback ser√£o armazenadas no construtor da lista, dando um toque mais profissional para nosso programa.",
    "crumbs": [
      "Lista Gen√©rica"
    ]
  },
  {
    "objectID": "disciplinas/aed2/academic/unidade2/5-lista.html#interface",
    "href": "disciplinas/aed2/academic/unidade2/5-lista.html#interface",
    "title": "Lista Gen√©rica",
    "section": "Interface",
    "text": "Interface\n\n\nlist.h\n\n#include &lt;stdbool.h&gt;\n#include &lt;stddef.h&gt;\n\ntypedef void(*cb_free)(void *);\ntypedef int(*cb_compare)(void *a, void *b);\n\ntypedef struct node {\n    void* data;          // Ponteiro gen√©rico para o dado\n    struct node* next;\n} Node;\n\ntypedef struct {\n    site_t data_size;\n    Node *head; \n    // Fun√ß√µes de callback para o tipo de dado\n    cb_free free_data;\n    cb_compare compare_data;\n} List;\n\n\nList* list_create (size_t data_size, cb_free free_data, cb_compare compare_data);\nvoid list_destroy (List *list);\nvoid list_add (List *list, void *data);\nbool list_contains (List *list, void *data);\n\nNossa lista √© bastante simples. Cada n√≥ possui um dado e um ponteiro para o pr√≥ximo n√≥. J√° a estrutura lista √© composta pelo tamanho do dado, um ponteiro para a cabe√ßa da lista e duas fun√ß√µes de callback. As fun√ß√µes declaradas ser√£o usadas para criar uma lista, liberar a mem√≥ria da lista, adicionar um novo n√≥ e determinar se um n√≥ pertence a uma lista.",
    "crumbs": [
      "Lista Gen√©rica"
    ]
  },
  {
    "objectID": "disciplinas/aed2/academic/unidade2/5-lista.html#implementa√ß√£o",
    "href": "disciplinas/aed2/academic/unidade2/5-lista.html#implementa√ß√£o",
    "title": "Lista Gen√©rica",
    "section": "Implementa√ß√£o",
    "text": "Implementa√ß√£o\nImportando as bibliotecas.\n\n\nlist.c\n\n#include \"list.h\"\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;assert.h&gt;\n\n\nCriar Lista\nA primeira fun√ß√£o que iremos implementar √© o construtor da lista, list_create. O primeiro param√™tro √© o tamanho em bytes do dado que iremos armazenar na lista. Depois as fun√ß√µes de callback para liberar a mem√≥ria desse dado e como comparar dois dados.\n\n\nlist.c\n\nList *list_create(size_t data_size, cb_free free_data, cb_compare compare_data) {\n    assert(data_size &gt; 0);  \n\n    List *list = malloc(sizeof(List));\n    list-&gt;data_size = data_size;\n    list-&gt;head = NULL;\n    list-&gt;free_data = free_data;\n    list-&gt;compare_data = compare_data;\n    return list;\n}\n\nComo a lista inicia vazia, logo a cabe√ßa da lista ser√° NULL.\n\n\nAdicionar Elementos\nAp√≥s criar a lista, temos de adicionar n√≥s a ela. A fun√ß√£o list_add aloca mem√≥ria duas vezes, uma para o n√≥ e outra para o dado. N√£o podemos fazer um simples atribui√ß√£o com = para passar o dado para o campo data do n√≥. Portanto, usamos a fun√ß√£o memcpy que estudamos na se√ß√£o sobre gerenciamento de mem√≥ria.\n\n\nlist.c\n\nvoid list_add(List *list, void *data) {\n    assert(list != NULL);\n    assert(data != NULL);\n\n    Node *newNode = calloc(1, sizeof(Node));\n    newNode-&gt;data = malloc(list-&gt;data_size);\n    memcpy(newNode-&gt;data, data, list-&gt;data_size);\n\n    newNode-&gt;next = list-&gt;head;\n    list-&gt;head = newNode;\n}\n\nEssa fun√ß√£o adiciona elementos na cabe√ßa da lista: o novo n√≥ aponta para a cabe√ßa da lista (linha 9) e depois a cabe√ßa da lista √© atualizada para o novo n√≥ (linha 10).\n\n\nApagar Lista\nPrecisamos criar o destrutor da lista. Mas antes temos de implementar a free_node_data. Ela serve para liberar a mem√≥ria alocada para o dado que √© armazenado na lista. Esse dado pode ser mais complexo do que pensamos (algum struct com aloca√ß√£o interna). Por isso, passamos um fun√ß√£o callback para tratar esses casos. Por outro lado, para uma lista de inteiros ou outro tipo simples, um free √© suficiente.\n\n\nlist.c\n\nstatic void free_node_data(cb_free free_data, void *data) { \n    if (free_data != NULL) \n        free_data(data); \n    else \n        free(data); \n}\n\nMote que essa fun√ß√£o n√£o foi declarada no arquivo .h e isso significa que ela √© privada. O modificador static indica isso para n√≥s.\nA l√≥gica do destrutor √© simples. Ap√≥s a verifica√ß√£o de seguran√ßa do assert, criamos um n√≥ que aponta para a cabe√ßa da lista. Em seguida, caminhamos na lista em dire√ß√£o a cauda. Nesse percurso, liberamos a mem√≥ria do dado e depois do n√≥. Quando acabamos o percurso, liberaramos a estrutura lista.\n\n\nlist.c\n\nvoid list_destroy(List *list){\n    assert(list != NULL);\n    \n    Node *node = list-&gt;head;\n        \n    while (node != NULL){\n        Node *next = node-&gt;next; // guarda o pr√≥ximo antes de liberar\n        free_node_data(list-&gt;free_data, node-&gt;data);\n        free(node);\n        node = next;\n    }\n\n    free(list);\n}\n\nNote que usamos tr√™s libera√ß√µes de mem√≥ria. Uma para o dado (linha 8), uma para o n√≥ (linha 9) e outra para a lista (linha 13). Isso porque usamos a aloca√ß√£o de mem√≥ria tr√™s vezes, uma em list_create e duas em list_add. Lembre-se do que estudamos, para cada aloca√ß√£o deve haver um libera√ß√£o correspondente.\n\n\nProcurar Elementos\nUma das fun√ß√µes que declaramos em nossa interface foi list_contains. Ela ser√° usada para saber se algum elemento existe dentro da lista. Ela s√≥ retorna sim ou n√£o.\n\n\nlist.c\n\nbool list_contains(List *list, void *data) {\n    assert(list-&gt;compare_data != NULL);\n    \n    Node *node = list-&gt;head;\n    while (node != NULL)    {\n        if (list-&gt;compare_data(node-&gt;data, data) == 0)\n            return true;        \n        node = node-&gt;next;\n    }\n    return false;\n}\n\n\n\nSe liga! √â uma boa pr√°tica implementar a fun√ß√£o de compara√ß√£o da seguinte forma:\n\nSe a &lt; b, retorne um n√∫mero negativo\nSe a = b, retorne zero\nSe a &gt; b, retorne um n√∫mero positivo\n\nNote que para tipos primitivos, como inteiros, a igualdade √© simples (a == b). Contudo, nossa lista armazena dados de forma gen√©rica (void *data), o que significa que o operador == s√≥ compararia os endere√ßos de mem√≥ria dos dados, e n√£o o seu conte√∫do l√≥gico. Por isso, o callback compare_data √© essencial: ele permite que o usu√°rio defina a l√≥gica de compara√ß√£o correta para tipos complexos, como um struct de aluno (onde a igualdade pode depender, por exemplo, do ID ou Matr√≠cula).",
    "crumbs": [
      "Lista Gen√©rica"
    ]
  },
  {
    "objectID": "disciplinas/aed2/academic/unidade2/5-lista.html#exemplo-de-uso",
    "href": "disciplinas/aed2/academic/unidade2/5-lista.html#exemplo-de-uso",
    "title": "Lista Gen√©rica",
    "section": "Exemplo de Uso",
    "text": "Exemplo de Uso\nImportando as bibliotecas e API da lista que criamos.\n\n\nint_list.c\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;stdbool.h&gt;\n#include \"list.h\" \n\nFun√ß√£o de callback para comparar dois inteiros.\n\n\nint_list.c\n\n// Callback para comparar dois inteiros\nint compare_int(void *a, void *b) {\n    int x = *(int*)a;\n    int y = *(int*)b;\n    return x - y;\n}\n\n\n\nSe liga! N√£o vamos precisar de um fun√ß√£o callback para liberar um inteiro, pois nossa fun√ß√£o free_node_data j√° trata esse caso se passarmos NULL como argumento para list_create.\nLembre-se, o padr√£o √© que retorne zero se ambos s√£o iguais.\nFun√ß√£o principal:\n\n\nint_list.c\n\nint main() {\n\n    // Criar uma lista de inteiros\n    List *list = list_create(sizeof(int), NULL, compare_int);\n    int item[5] = {2, 5, 3, 8, 9};\n \n    // Adicionar elementos\n    for (int i = 0; i &lt; 5; i++) {\n        int *data = malloc(sizeof(int));\n        *data = item[i];\n        list_add(list, data);\n        free(data);\n    }\n\n    // Verificar se um valor est√° na lista\n    int search_key = 8;\n    \n    printf(\"Procurando n√≥ com chave: %d...\\n\", search_key);\n    \n    if (list_contains(list, &search_key))\n        printf(\"-&gt; Sucesso: Chave %d encontrada!\\n\", search_key);\n    else \n        printf(\"-&gt; Falha: Chave %d n√£o encontrada.\\n\", search_key);\n    \n    printf(\"----------------------------------------\\n\");\n\n    \n    // Destruir a lista    \n    list_destroy(list);\n    list = NULL;\n\n    return 0;\n}\n\nPara demonstrar o poder da nossa lista gen√©rica, vamos criar uma lista de anulos, onde cada aluno √© uma struct.\n\n\nstudent_list.c\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;stdbool.h&gt;\n#include &lt;string.h&gt;\n#include \"list.h\" \n\ntypedef struct student {\n    char* name;\n    int id;\n} Student;\n\nint compare_student(void *a, void *b) {\n    Student *student_a = (Student *)a;\n    Student *student_b = (Student *)b;\n\n    return student_a-&gt;id - student_b-&gt;id;\n}\n\nvoid free_student(void *data) {\n    Student *student_ptr = (Student *)data;\n    \n    if (student_ptr == NULL) \n        return; \n    \n    if (student_ptr-&gt;name != NULL) \n        free(student_ptr-&gt;name); \n    \n    free(student_ptr);\n}\n\nFun√ß√£o auxiliar para criar um aluno.\n\n\nstudent_list.c\n\nStudent *create_student(const char *name, int id) {\n    Student *new_student = (Student *)malloc(sizeof(Student));\n    if (new_student == NULL) {\n        fprintf(stderr, \"Erro ao alocar Student\\n\");\n        return 1; \n    }\n\n    new_student-&gt;id = id;\n    \n    // strdup faz o malloc interno e a c√≥pia.\n    new_student-&gt;name = strdup(name); \n    if (new_student-&gt;name == NULL) {\n        free(new_student); // Limpeza em caso de falha de aloca√ß√£o do nome\n        fprintf(stderr, \"Erro ao alocar nome\\n\");\n        return 1; \n    }\n\n    return new_student;\n}\n\n\n\nSe liga! Internamente, strdup faz:\n\nchar *new_name = malloc(strlen(name) + 1);\nstrcpy(new_name, name);\n\nNote que o free correspondente ao malloc de strdup est√° no callback free_student, no segundo if.\nAgora estamos prontos para simular uma lista de alunos.\n\n\nstudent_list.c\n\nint main() {\n\n    // Criar um  lista de alunos\n    List *list = list_create(sizeof(Student), free_student, compare_student);\n\n    // Nomes e IDs\n    const char *names[] = {\"Alice\", \"Bob\", \"Charlie\", \"Diana\"};\n    int ids[] = {101, 205, 303, 408};\n\n    // Adicionar elementos\n    for (int i = 0; i &lt; 4; i++) {\n        Student *s = create_student(names[i], ids[i]);\n        list_add(list, s); \n    }\n   \n    // Verificar se um aluno est√° na lista\n    Student search_key = {.name = NULL, .id = 303}; \n    \n    printf(\"Procurando aluno com ID: %d...\\n\", search_key.id);\n    \n    if (list_contains(list, &search_key)) \n        printf(\"-&gt; Sucesso: Aluno ID %d encontrado!\\n\", search_key.id);\n    else\n        printf(\"-&gt; Falha: Aluno ID %d n√£o encontrado.\\n\", search_key.id);\n    \n    printf(\"----------------------------------------\\n\");\n\n    // Destruir a lista\n    list_destroy(list); \n    list = NULL;\n\n    return 0;\n}\n\nA implementa√ß√£o desta lista gen√©rica garante alta modularidade. Gra√ßas ao design baseado em fun√ß√µes callback, evitamos a reimplementa√ß√£o de fun√ß√µes centrais (como cria√ß√£o, adi√ß√£o ou destrui√ß√£o). Para adaptar a lista a qualquer novo tipo de dado, basta fornecer os callbacks espec√≠ficos para a compara√ß√£o e libera√ß√£o de mem√≥ria daquele tipo.\n\n\n\n\n\n\nNotaüéØ Desafio de C√≥digo\n\n\n\nDefina uma nova assinatura para um fun√ß√£o callback chamada cb_iterate e adicione a declara√ß√£o da fun√ß√£o list_iterate no arquivo de cabe√ßalho (list.h).\ntypedef bool(*cb_iterate)(int index, void *data);\nvoid list_iterate(LinkedList *list, cb_iterate iterate_callback);\nDepois, na implementa√ß√£o (list.c) escreva a o c√≥digo para essa fun√ß√£o.\nvoid list_iterate(LinkedList *list, cb_iterate iterate_callback) {\n    assert(list != NULL);\n    assert(iterate_callback != NULL);\n\n    Node *current = list-&gt;head;  \n    int index = 0;               \n\n    // Enquanto ainda houver n√≥s para visitar\n    while (current != NULL) {\n        // Chamamos a fun√ß√£o de callback para o n√≥ atual.\n        bool continuar = iterate_callback(index, current-&gt;data);\n\n        // Se a fun√ß√£o de callback retornar 'false', paramos a itera√ß√£o\n        if (!continuar) break;\n\n        // Avan√ßamos para o pr√≥ximo n√≥\n        current = current-&gt;next;\n        index++;\n    }\n}\nImplemente uma fun√ßao callback para imprimir a lista de inteiros. Ela deve ter a mesma assinatura de cb_iterate:\nbool print_int(int index, void *data);\nExemplo de uso:\nprintf(\"Conte√∫do da lista:\\n\");\nlist_iterate(list, print_int);\n\n\n\n\n\n\n\n\nDicaSolu√ß√£o (clique para ver)\n\n\n\n\n\n// Callback para iterar e imprimir\nbool print_int(int index, void *data) {\n    int value = *(int*)data;\n    printf(\"[%d]: %d\\n\", index, value);\n    return true; // continuar a itera√ß√£o\n}",
    "crumbs": [
      "Lista Gen√©rica"
    ]
  },
  {
    "objectID": "disciplinas/aed2/academic/unidade2/5-lista.html#conclus√£o",
    "href": "disciplinas/aed2/academic/unidade2/5-lista.html#conclus√£o",
    "title": "Lista Gen√©rica",
    "section": "Conclus√£o",
    "text": "Conclus√£o\nCom a lista gen√©rica implementada, conclu√≠mos com sucesso a explora√ß√£o de um dos temas mais poderosos em programa√ß√£o C: o design de estruturas de dados independentes de tipo.\nO verdadeiro valor deste exerc√≠cio n√£o est√° apenas no c√≥digo da lista, mas nos conceitos transfer√≠veis que voc√™ aprendeu. A utiliza√ß√£o estrat√©gica de ponteiros para fun√ß√µes (callbacks) e a rigorosa gest√£o da mem√≥ria via Heap s√£o os pilares que sustentam a cria√ß√£o de qualquer estrutura avan√ßada. Voc√™ agora tem o conhecimento necess√°rio para replicar essa arquitetura em pilhas, filas, √°rvores gen√©ricas e al√©m.\nEste trabalho estabelece a base para o desenvolvimento profissional, alinhando seu c√≥digo com os padr√µes utilizados nas bibliotecas de software de c√≥digo aberto mais robustas. Voc√™ n√£o apenas criou uma lista; voc√™ adquiriu um modelo de design para resolver problemas complexos com eleg√¢ncia.\n\nNesta unidade, voc√™ aprendeu\n‚úÖ a criar uma lista ligada gen√©rica simples\n\n# Qual √© o principal objetivo da estrutura `List` apresentada?\n\n&gt; Pense na abstra√ß√£o que ela representa.\n\n1. [ ] Armazenar apenas inteiros de forma sequencial.\n1. [x] Permitir o armazenamento de dados gen√©ricos com callbacks para opera√ß√µes espec√≠ficas.\n1. [ ] Substituir arrays fixos por vetores din√¢micos.\n1. [ ] Gerenciar automaticamente a mem√≥ria da heap sem interven√ß√£o do usu√°rio.\n\n\n# Qual √© a fun√ß√£o do campo `data_size` dentro da estrutura `List`?\n\n&gt; Ele √© essencial para manipular dados gen√©ricos.\n\n1. [x] Indicar o tamanho em bytes do tipo de dado armazenado.\n1. [ ] Controlar o n√∫mero total de n√≥s da lista.\n1. [ ] Identificar o tipo de dado armazenado (inteiro, float etc.).\n1. [ ] Servir como √≠ndice de posi√ß√£o atual na lista.\n\n\n# Qual √© a principal diferen√ßa entre o campo `free_data` e a fun√ß√£o `free` padr√£o?\n\n&gt; Observe o papel do callback no gerenciamento de mem√≥ria.\n\n1. [x] `free_data` permite liberar dados complexos com l√≥gica personalizada.\n1. [ ] `free_data` √© usada apenas para liberar a estrutura `List`.\n1. [ ] `free_data` substitui a fun√ß√£o `malloc`.\n1. [ ] N√£o h√° diferen√ßa ‚Äî ambas fazem exatamente a mesma coisa.\n\n\n# No contexto da fun√ß√£o `list_add`, por que √© necess√°rio usar `memcpy`?\n\n&gt; Lembre-se de que `data` √© um ponteiro gen√©rico.\n\n1. [x] Para copiar o conte√∫do do dado em vez do endere√ßo.\n1. [ ] Para liberar a mem√≥ria de origem ap√≥s a c√≥pia.\n1. [ ] Porque `malloc` n√£o inicializa a mem√≥ria corretamente.\n1. [ ] Para evitar que o ponteiro `data` fique nulo.\n\n\n# Quais afirma√ß√µes sobre a fun√ß√£o `list_create` est√£o corretas?\n\n&gt; Considere os par√¢metros e suas fun√ß√µes.\n\n- [x] Recebe o tamanho do dado a ser armazenado.\n- [x] Recebe ponteiros de fun√ß√£o para liberar e comparar dados.\n- [ ] Aloca apenas o n√≥ inicial da lista.\n- [ ] Cria automaticamente um primeiro elemento.\n\n\n# Quais s√£o os tr√™s tipos de aloca√ß√£o de mem√≥ria usados ao longo da implementa√ß√£o?\n\n&gt; Pense no ciclo completo da lista.\n\n- [x] Aloca√ß√£o para a estrutura `List`.\n- [x] Aloca√ß√£o para cada `Node`.\n- [x] Aloca√ß√£o para o campo `data` em cada n√≥.\n- [ ] Aloca√ß√£o para cada chamada de compara√ß√£o.\n\n\n# Coloque em ordem as etapas da fun√ß√£o `list_destroy`.\n\n&gt; Ela percorre e libera a lista corretamente.\n\n1. Criar um ponteiro auxiliar para o n√≥ inicial.\n2. Guardar o pr√≥ximo n√≥ antes de liberar o atual.\n3. Liberar o dado interno com `free_node_data`.\n4. Liberar o n√≥ atual.\n5. Repetir at√© o final e liberar a estrutura `List`.\n\n\n# Por que `compare_data` √© necess√°rio em uma lista gen√©rica?\n\n&gt; Ele garante a compara√ß√£o l√≥gica correta dos dados.\n\n1. [x] Porque `==` apenas compara endere√ßos de mem√≥ria.\n1. [ ] Porque ele substitui o operador `sizeof`.\n1. [ ] Porque o compilador n√£o aceita compara√ß√£o de `void *`.\n1. [ ] Porque ele √© obrigat√≥rio para listas de inteiros.\n\n\n# Em rela√ß√£o ao uso de `assert`, assinale as op√ß√µes verdadeiras.\n\n&gt; Elas s√£o fundamentais para seguran√ßa em C.\n\n- [x] Garante que ponteiros n√£o sejam nulos antes do uso.\n- [x] √â usada para detectar falhas de pr√©-condi√ß√£o em tempo de execu√ß√£o.\n- [ ] √â um comando que substitui `if`.\n- [ ] Impede o programa de compilar se a condi√ß√£o for falsa.\n\n\n# Quais pr√°ticas s√£o adequadas ao manipular listas gen√©ricas?\n\n&gt; Pense em modularidade e seguran√ßa.\n\n- [x] Passar callbacks apropriados para cada tipo de dado.\n- [x] Liberar todos os recursos com `list_destroy` ap√≥s o uso.\n- [ ] Usar o operador `==` diretamente em ponteiros `void *`.\n- [ ] Atribuir dados com `=` sem `memcpy`.\n\n\n# Coloque na ordem correta as etapas executadas pela fun√ß√£o `list_add`.\n\n&gt; Ela insere o elemento na cabe√ßa da lista.\n\n1. Criar um novo n√≥ com `calloc`.\n2. Alocar mem√≥ria para o campo `data`.\n3. Copiar o conte√∫do do dado com `memcpy`.\n4. Fazer o novo n√≥ apontar para a cabe√ßa atual.\n5. Atualizar a cabe√ßa da lista para o novo n√≥.\n\n\n# Sobre o uso de `strdup` na cria√ß√£o de um aluno, marque as op√ß√µes corretas.\n\n&gt; Lembre-se que `strdup` tamb√©m faz aloca√ß√£o.\n\n- [x] Ela aloca mem√≥ria e copia a string de origem.\n- [x] O `free` correspondente ocorre em `free_student`.\n- [ ] √â equivalente a `strcpy`.\n- [ ] N√£o precisa de tratamento de erro ap√≥s chamada.\n\n\n# Qual problema ocorreria se esquec√™ssemos de liberar `student-&gt;name` em `free_student`?\n\n&gt; Ocorre com dados compostos alocados internamente.\n\n1. [ ] *Segmentation fault*\n1. [ ] *Double free*\n1. [x] *Memory leak*\n1. [ ] *Buffer overflow*\n\n\n# Quais vantagens o uso de callbacks traz para a implementa√ß√£o da lista?\n\n&gt; Pense em reuso e generaliza√ß√£o.\n\n- [x] Permite adaptar a lista a diferentes tipos de dados.\n- [x] Evita duplica√ß√£o de c√≥digo em diferentes listas.\n- [ ] Aumenta a velocidade de execu√ß√£o do programa.\n- [ ] Impede a ocorr√™ncia de erros de aloca√ß√£o.\n\n\n# Coloque em ordem as etapas da fun√ß√£o `list_contains`.\n\n&gt; Ela percorre e compara os dados.\n\n1. Inicia em `head`.\n2. Compara o dado do n√≥ com o elemento buscado usando `compare_data`.\n3. Retorna `true` se a compara√ß√£o for igual a zero.\n4. Avan√ßa para o pr√≥ximo n√≥.\n5. Retorna `false` se atingir o final sem encontrar.\n\n\n# Quais s√£o os par√¢metros da fun√ß√£o `list_iterate` no desafio proposto?\n\n&gt; Eles controlam o fluxo da itera√ß√£o.\n\n- [x] Um ponteiro para a lista.\n- [x] Um ponteiro para fun√ß√£o `cb_iterate`.\n- [ ] O n√∫mero de n√≥s da lista.\n- [ ] Um vetor de ponteiros para dados.\n\n\n# O que ocorre se o callback em `list_iterate` retornar `false`?\n\n&gt; Veja o controle de fluxo dentro da fun√ß√£o.\n\n1. [x] A itera√ß√£o √© interrompida imediatamente.\n1. [ ] A itera√ß√£o reinicia do in√≠cio.\n1. [ ] O n√≥ atual √© removido.\n1. [ ] O programa encerra a execu√ß√£o.\n\n\n# Quais boas pr√°ticas s√£o aplicadas na fun√ß√£o `create_student`?\n\n&gt; Observe o tratamento de erros e aloca√ß√µes.\n\n- [x] Verificar se o `malloc` retornou `NULL`.\n- [x] Liberar mem√≥ria parcialmente alocada em caso de falha.\n- [ ] Ignorar erros de aloca√ß√£o.\n- [ ] Retornar `1` para indicar sucesso na aloca√ß√£o.\n\n\n# Coloque em ordem o ciclo de vida completo de um elemento na lista de alunos.\n\n&gt; Do in√≠cio at√© a libera√ß√£o final.\n\n1. Criar `Student` com `malloc` e `strdup`.\n2. Adicionar √† lista com `list_add`.\n3. Buscar elemento com `list_contains`.\n4. Destruir lista com `list_destroy`.\n5. Liberar mem√≥ria de cada aluno via `free_student`.\n\n\n# Quais conceitos fundamentais da linguagem C s√£o consolidados nesta unidade?\n\n&gt; Eles formam a base para estruturas gen√©ricas.\n\n- [x] Ponteiros para fun√ß√µes (*callbacks*).\n- [x] Manipula√ß√£o de mem√≥ria din√¢mica.\n- [x] Estruturas gen√©ricas com `void *`.\n- [ ] Recursividade em tempo de compila√ß√£o.",
    "crumbs": [
      "Lista Gen√©rica"
    ]
  },
  {
    "objectID": "disciplinas/aed2/academic/unidade2/3-memoria.html",
    "href": "disciplinas/aed2/academic/unidade2/3-memoria.html",
    "title": "Gerenciamento da Mem√≥ria",
    "section": "",
    "text": "At√© aqui, vimos como generalizar dados e comportamentos em C usando ponteiros e callbacks. No entanto, toda essa flexibilidade traz a responsabilidade de gerenciar manualmente a mem√≥ria.\nNesta se√ß√£o, vamos entender como a linguagem C lida com a aloca√ß√£o din√¢mica, isto √©, a capacidade de reservar e liberar mem√≥ria em tempo de execu√ß√£o. Mais importante, veremos como evitar os erros de mem√≥ria mais comuns que podem comprometer a estabilidade e a seguran√ßa de um programa.",
    "crumbs": [
      "Gerenciamento da Mem√≥ria"
    ]
  },
  {
    "objectID": "disciplinas/aed2/academic/unidade2/3-memoria.html#sec-alo",
    "href": "disciplinas/aed2/academic/unidade2/3-memoria.html#sec-alo",
    "title": "Gerenciamento da Mem√≥ria",
    "section": "Aloca√ß√£o e libera√ß√£o din√¢mica",
    "text": "Aloca√ß√£o e libera√ß√£o din√¢mica\nQuando trabalhamos com arrays ou estruturas em C, geralmente definimos seus tamanhos em tempo de compila√ß√£o. Eles ficam armazenados em uma √°rea de mem√≥ria chamada stack.\nNo entanto, h√° muitos casos em que o tamanho dos dados n√£o √© conhecido antecipadamente. Para esses casos, o C fornece fun√ß√µes de aloca√ß√£o din√¢mica de mem√≥ria, que permitem reservar e liberar espa√ßo em tempo de execu√ß√£o. Esses blocos de mem√≥ria s√£o criados em uma regi√£o especial chamada heap.\nDizemos que a mem√≥ria stack √© est√°tica, enquanto que a heap √© din√¢mica. Na stack, quando a fun√ß√£o termina, a vari√°vel √© destru√≠da. J√° na heap, o programador decide quando alocar e liberar.\nA aloca√ß√£o din√¢mica oferece flexibilidade, mas tamb√©m exige disciplina. O princ√≠pio fundamental √©: quem aloca, deve liberar.\n\nAloca√ß√£o simples\nA fun√ß√£o malloc (de memory allocation) reserva um bloco cont√≠guo de mem√≥ria de tamanho especificado em bytes.\nint *v = malloc(5 * sizeof(int));\nO argumento √© o n√∫mero total de bytes a serem alocados. No trecho acima, estamos alocando o espa√ßo suficiente para cinco inteiros. O retorno √© um ponteiro gen√©rico (void*) para o in√≠cio do bloco. Caso a aloca√ß√£o falhe, malloc retorna NULL.\n\n\nSe liga! Em C, ao contr√°rio de C++, n√£o h√° necessidade de fazer o cast do ponteiro gen√©rico neste caso.\nComo n√£o temos garantia que a mem√≥ria foi alocada, precisamos tratar quando malloc falha. Isso √© geramente feito com um bloco if.\nint *v = malloc(5 * sizeof(int));\n    \nif (v == NULL) {\n    fprintf(stderr, \"Erro: sem mem√≥ria suficiente!\\n\");\n    return 1;\n}       \nNo trecho acima, poder√≠amos ter usado printf ao inv√©s de fprintf. A escolha, por fprintf se d√° por ser o padr√£o para erros. Ele permite especificar exatamente para onde a sa√≠da deve ir. Ao usarmos stderr (de standard error), estamos dizendo ao sistema que esta mensagem √© um erro e deve ser tratada como tal.\n\n\nSe liga! A fun√ß√£o perror imprime uma mensagem de erro em stderr tamb√©m e √© muito usada para depura√ß√£o.\nQuando usamos printf a sa√≠da √© armazenada em buffer, portanto a mensagem de erro poderia ficar presa e nunca ser exibida antes do programa abortar. J√° quando optamos por fprintf, a sa√≠da √© unbuffered, ou seja, √© exibida imediatamente no terminal.\nResumindo, use fprinf mensagens de erro, diagn√≥stico e logs cr√≠ticos e use printf para mensagens de sucesso, resultado da aplica√ß√£o e sa√≠da esperada.\nO return 1 informa ao sistema operacional que algo deu errado .\n\n\nAloca√ß√£o e inicializa√ß√£o\nA fun√ß√£o calloc (de contiguous allocation) funciona como malloc, mas com duas diferen√ßas:\n\nRecebe dois par√¢metros, n√∫mero de elementos e tamanho de cada um;\nInicializa o bloco com zeros.\n\nint *v = calloc(5, sizeof(int));\nAssim, todo as posi√ß√µes come√ßam zeradas, o que evita leituras de lixo de mem√≥ria.\n\n\nRedimensionamento de bloco\nA fun√ß√£o realloc permite ajustar o tamanho de um bloco de mem√≥ria j√° alocado.\nint *v = calloc(5, sizeof(int));\nint *novo = realloc(v, 10 * sizeof(int));\nSe houver espa√ßo cont√≠guo suficiente, o bloco √© expandido no mesmo local. Caso contr√°rio, um novo bloco √© alocado e o conte√∫do antigo √© copiado automaticamente. Em caso de falha, retorna NULL e n√£o desaloca o bloco de mem√≥ria original. Por isso, √© recomendado sempre usar um ponteiro tempor√°rio:\nint *v = calloc(5, sizeof(int));\nint *temp = realloc(v, 10 * sizeof(int));\nif (temp == NULL) {\n    fprintf(stderr, \"Erro ao realocar mem√≥ria!\\n\");\n    return 1;\n}\nv = temp; // Atualiza o ponteiro com seguran√ßa\n\n\nLibera√ß√£o de mem√≥ria\nA fun√ß√£o free libera um bloco previamente alocado com malloc, calloc ou realloc. Ela devolve o espa√ßo ao sistema operacional, mas n√£o zera o ponteiro.\nfree(v);\nv = NULL; // Boa pr√°tica\n\n\n\n\n\n\nImportante\n\n\n\nAp√≥s liberar, o ponteiro ainda guarda o endere√ßo antigo, agora inv√°lido. Atribuir NULL ajuda a evitar o uso acidental, um erro cl√°ssico conhecido como dangling pointer.\n\n\nEste ciclo √© a base de toda manipula√ß√£o segura de mem√≥ria din√¢mica em C:\n\n\n\n\n\nflowchart LR\n    A(\"Alocar\") --&gt; B(\"Usar\")\n    B --&gt; C(\"Liberar\")  \n    C --&gt; D(\"Invalidar\")\n    D --&gt; A\n\n\n\n\n\n\n\nAlocar (malloc, calloc ou realloc)\nUsar (ler e escrever por meio do ponteiro)\nLiberar (free)\nInvalidar o ponteiro (ptr = NULL)\n\nCom essas fun√ß√µes, temos total controle sobre a vida √∫til de cada dado em mem√≥ria. No entanto, esse poder vem acompanhado de riscos. Podemos citar os acessos indevidos, vazamentos e corrup√ß√£o de mem√≥ria como erros comuns quando o ciclo de aloca√ß√£o n√£o √© seguido corretamente.\nNa pr√≥xima se√ß√£o, vamos explorar as fun√ß√µes de manipula√ß√£o de blocos de mem√≥ria e entender como oper√°-las com seguran√ßa antes de mergulhar nos erros cl√°ssicos de mem√≥ria.",
    "crumbs": [
      "Gerenciamento da Mem√≥ria"
    ]
  },
  {
    "objectID": "disciplinas/aed2/academic/unidade2/3-memoria.html#sec-man",
    "href": "disciplinas/aed2/academic/unidade2/3-memoria.html#sec-man",
    "title": "Gerenciamento da Mem√≥ria",
    "section": "Manipula√ß√£o de blocos de mem√≥ria",
    "text": "Manipula√ß√£o de blocos de mem√≥ria\nQuando trabalhamos com aloca√ß√£o din√¢mica, frequentemente precisamos copiar dados de uma regi√£o de mem√≥ria para outra. O C oferece um conjunto de fun√ß√µes na biblioteca &lt;string.h&gt; para manipular blocos de mem√≥ria de forma gen√©rica, usando ponteiros do tipo void *.\nEssas fun√ß√µes operam diretamente em bytes, e n√£o conhecem o tipo de dado armazenado. Por isso, exigem aten√ß√£o com o tamanho dos blocos manipulados (geralmente expresso com size_t).\nAs tr√™s fun√ß√µes principais para manipula√ß√£o de blocos de mem√≥ria s√£o:\n\nmemcpy: copia bytes de uma origem para um destino\nmemmove: copia bytes com seguran√ßa mesmo se houver sobreposi√ß√£o\nmemset: preenche uma √°rea de mem√≥ria com um valor constante\n\n\nCopiando blocos de mem√≥ria\nA fun√ß√£o memcpy copia \\(n\\) bytes do bloco apontado por src (origem) para o bloco apontado por dest (destino).\nvoid *memcpy(void *dest, const void *src, size_t n);\nExemplo pr√°tico:\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main() {\n    int origem[5] = {1, 2, 3, 4, 5};\n    int destino[5];\n\n    memcpy(destino, origem, 5 * sizeof(int));\n\n    for (int i = 0; i &lt; 5; i++)\n        printf(\"%d \", destino[i]);\n    \n    return 0;\n}\nSa√≠da:\n1 2 3 4 5\n\n\n\n\n\n\nImportante\n\n\n\nA fun√ß√£o memcpy n√£o deve ser usada quando as regi√µes de origem e destino se sobrep√µem. O comportamento √© indefinido, podendo corromper os dados.\n\n\n\n\nC√≥pia segura com sobreposi√ß√£o\nA fun√ß√£o memmove √© semelhante a memcpy, mas trata corretamente casos de sobreposi√ß√£o. Se o bloco de destino estiver dentro da √°rea de origem (ou vice-versa), ela ajusta a dire√ß√£o da c√≥pia automaticamente.\nvoid *memmove(void *dest, const void *src, size_t n);\nExemplo:\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main() {\n    char texto[20] = \"ABCDEF\";\n\n    // Copiando parte sobreposta\n    memmove(texto + 2, texto, 4);\n    texto[6] = '\\0'; // Caracter de fim de string\n\n    printf(\"%s\\n\", texto); // Resultado: \"ABABCD\"\n    return 0;\n}\nSe tiv√©ssemos usado memcpy nesse exemplo, o conte√∫do de texto poderia ser corrompido, pois as regi√µes texto e texto + 2 se sobrep√µem.\n\n\nInicializando mem√≥ria\nA fun√ß√£o memset preenche um bloco de mem√≥ria com um valor constante em bytes. Ela √© muito usada para inicializar buffers ou zerar estruturas.\nvoid *memset(void *ptr, int valor, size_t n);\nExemplo:\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main() {\n    int v[5];\n    memset(v, 0, 5 * sizeof(int));\n\n    for (int i = 0; i &lt; 5; i++)\n        printf(\"%d \", v[i]);\n    \n    return 0;\n}\n\n\nSe liga! O valor passado a memset √© interpretado como um byte, e n√£o como um inteiro completo. Por exemplo, memset(v, 1, sizeof(int)*5) preencher√° todos os bytes com 0x01, n√£o com o inteiro 1.\nSa√≠da:\n0 0 0 0 0\n\n\n\n\n\n\nImportante\n\n\n\nOs seguintes cuidados s√£o recomendados quando estamos programando com uso de mem√≥ria din√¢mica.\n\nSempre use sizeof para calcular o n√∫mero correto de bytes.\n\nEvite express√µes m√°gicas como memcpy(dest, src, 20).\nAo inv√©s, use memcpy(dest, src, n * sizeof(T)).\n\nPrefira memmove quando houver d√∫vida sobre sobreposi√ß√£o.\nZere estruturas antes de us√°-las (por exemplo, buffers de strings).\nEvite manipular mem√≥ria de tipos complexos (estruturas com ponteiros internos) com memcpy\n\nIsso pode quebrar o encapsulamento e gerar c√≥pias superficiais perigosas.\n\n\n\n\nCom essas fun√ß√µes, temos ferramentas poderosas para manipular diretamente a mem√≥ria. Isso √© um recurso essencial para implementar estruturas gen√©ricas e opera√ß√µes de baixo n√≠vel. Entretanto, o uso incorreto dessas fun√ß√µes √© uma das principais causas de erros sutis e dif√≠ceis de depurar em C.\nNa pr√≥xima se√ß√£o, estudaremos exatamente esses erros, os erros cl√°ssicos de mem√≥ria, como dangling pointers, buffer overflow e double free, e como evit√°-los com boas pr√°ticas.",
    "crumbs": [
      "Gerenciamento da Mem√≥ria"
    ]
  },
  {
    "objectID": "disciplinas/aed2/academic/unidade2/3-memoria.html#erros-cl√°ssicos",
    "href": "disciplinas/aed2/academic/unidade2/3-memoria.html#erros-cl√°ssicos",
    "title": "Gerenciamento da Mem√≥ria",
    "section": "Erros cl√°ssicos",
    "text": "Erros cl√°ssicos\nGerenciar mem√≥ria manualmente √© uma das maiores responsabilidades (e riscos) ao programar em C. Ao lidar com ponteiros e aloca√ß√£o din√¢mica, pequenos descuidos podem causar comportamentos indefinidos, travamentos ou at√© falhas de seguran√ßa.\nNesta se√ß√£o, veremos os erros mais comuns, seus sintomas e como evit√°-los.\n\nPonteiros n√£o inicializados (wild pointers)\nUm wild pointer √© um ponteiro que n√£o foi inicializado antes do uso. Ele cont√©m um valor de endere√ßo aleat√≥rio, podendo apontar para qualquer lugar da mem√≥ria.\n#include &lt;stdio.h&gt;\n\nint main() {\n    int *p;       // n√£o inicializado!\n    *p = 42;      // ‚ùå comportamento indefinido!\n    printf(\"%d\\n\", *p);\n    return 0;\n}\n\n\n\n\n\n\nCuidado\n\n\n\nEsse c√≥digo pode travar o programa (segmentation fault), corromper dados ou at√© ‚Äúfuncionar‚Äù, mascarando o erro (o pior cen√°rio).\n\n\nComo boa pr√°tica, sempre inicialize ponteiros:\nint *p = NULL;\n\n\nSe liga! Um ponteiro deve sempre apontar para algo v√°lido, ou para NULL. Isso √© chamado de inicializa√ß√£o defensiva.\nEssa pr√°tica evita comportamentos indefinidos quando o ponteiro √© usado antes de ser atribu√≠do. Ela tamb√©m facilita verifica√ß√µes de seguran√ßa:\nif (p != NULL) {\n    *p = 42;\n}\n\n\nPonteiros pendentes (dangling pointers)\nUm dangling pointer ocorre quando o ponteiro ainda referencia uma regi√£o de mem√≥ria j√° liberada.\n#include &lt;stdlib.h&gt;\n\nint main() {\n    int *p = malloc(sizeof(int));\n    *p = 10;\n    free(p);\n    printf(\"%d\\n\", *p); // ‚ùå uso ap√≥s libera√ß√£o\n    return 0;\n}\n\n\n\n\n\n\nCuidado\n\n\n\nO bloco de mem√≥ria foi liberado, mas o ponteiro ainda ‚Äúacha‚Äù que √© v√°lido. Acessar ou modificar essa regi√£o causa comportamento indefinido.\n\n\nComo boa pr√°tica, ap√≥s free(p), defina p = NULL; para evitar acessos acidentais.\n\n\nVazamentos de mem√≥ria (memory leaks)\nUm memory leak acontece quando um programa perde a refer√™ncia para uma regi√£o de mem√≥ria alocada, sem cham√°-la com free.\n#include &lt;stdlib.h&gt;\n\nint main() {\n    int *p = malloc(100 * sizeof(int));\n    p = NULL;  // ‚ùå perdemos a refer√™ncia ‚Äî vazamento!\n    return 0;\n}\n\n\n\n\n\n\nCuidado\n\n\n\nA mem√≥ria continua alocada, mas inacess√≠vel. Em programas longos, isso pode acumular e exaurir a mem√≥ria do sistema.\n\n\nComo boas pr√°tica, sempre emparelhe malloc e free. Pois, cada chamada de aloca√ß√£o din√¢mica deve ter uma contrapartida de libera√ß√£o. Evite fluxos de execu√ß√£o que impe√ßam o free de ser chamado.\nchar *p = malloc(100);\nif (!p) return;  // ‚ùå erro de aloca√ß√£o\n// ...\nfree(p);\n\n\n\n\n\n\nDica\n\n\n\nCentralize libera√ß√µes num √∫nico ponto de sa√≠da, especialmente em fun√ß√µes longas.\n\n\n\n\nLibera√ß√£o duplicada (double free)\nUm double free ocorre quando tentamos liberar o mesmo bloco de mem√≥ria mais de uma vez.\n#include &lt;stdlib.h&gt;\n\nint main() {\n    int *p = malloc(sizeof(int));\n    free(p);\n    free(p); // ‚ùå ERRO: double free\n    return 0;\n}\n\n\n\n\n\n\nCuidado\n\n\n\nIsso causa corrup√ß√£o da estrutura interna do heap e frequentemente resulta em segmentation fault.\n\n\nComo boa pr√°tica, ap√≥s liberar, defina p = NULL.\nEm programas maiores, √© comum que uma fun√ß√£o fa√ßa aloca√ß√£o de mem√≥ria e outra a utilize. Para evitar vazamentos ou libera√ß√µes incorretas, defina quem √© o dono (owner) de cada bloco alocado.\nExemplo:\nchar* criar_mensagem() {\n    char *msg = malloc(50);\n    sprintf(msg, \"Ol√°, mundo!\");\n    return msg;  // a fun√ß√£o devolve a posse\n}\n\nint main() {\n    char *m = criar_mensagem();\n    puts(m);\n    free(m);     // responsabilidade de quem recebeu\n}\n\n\nAcesso fora dos limites (buffer overflow e underrun)\nUm buffer overflow ocorre quando se escreve al√©m do final (ou antes do in√≠cio) de um bloco de mem√≥ria.\n#include &lt;stdio.h&gt;\n\nint main() {\n    int v[3] = {1, 2, 3};\n    v[3] = 99; // √≠ndice inv√°lido ‚Äî overflow\n    printf(\"%d\\n\", v[3]); // ‚ùå comportamento indefinido\n    return 0;\n}\n\n\n\n\n\n\nCuidado\n\n\n\nEsse tipo de erro √© grave: pode corromper vari√°veis adjacentes, causar travamentos ou vulnerabilidades de seguran√ßa.\n\n\nComo boas pr√°tica, sempre verifique limites de vetores. Ao usar malloc, garanta que o tamanho esteja correto com sizeof.\nPodemos resumir os tipos de erros abordados por meio da seguinte tabela.\n\n\n\n\n\n\n\n\n\nTipo de Erro\nCausa\nSintoma\nPreven√ß√£o\n\n\n\n\nWild Pointer\nPonteiro n√£o inicializado\nCrash aleat√≥rio\nInicializar com NULL\n\n\nDangling Pointer\nUso ap√≥s free\nSegmentation fault\np = NULL ap√≥s free\n\n\nMemory Leak\nPerda de refer√™ncia\nAumento de uso de mem√≥ria\nSempre liberar\n\n\nDouble Free\nLibera√ß√£o repetida\nCorrup√ß√£o do heap\nControle de ownership\n\n\nBuffer Overflow\nEscrita fora dos limites\nCorrup√ß√£o de mem√≥ria\nVerificar limites\n\n\n\n\n\nSe liga! Ownership se refere ao propriet√°rio do ponteiro. Se duas regi√µes est√£o liberando o ponteiro (double free), ent√£o est√£o compartilhando a guarda. Evite isso!\nErros de mem√≥ria est√£o entre os mais sutis e perigosos em C. Eles n√£o apenas causam falhas, mas podem introduzir vulnerabilidades de seguran√ßa s√©rias. Com boas pr√°ticas e ferramentas adequadas, √© poss√≠vel evit√°-los e desenvolver sistemas robustos e confi√°veis.",
    "crumbs": [
      "Gerenciamento da Mem√≥ria"
    ]
  },
  {
    "objectID": "disciplinas/aed2/academic/unidade2/3-memoria.html#sec-boa",
    "href": "disciplinas/aed2/academic/unidade2/3-memoria.html#sec-boa",
    "title": "Gerenciamento da Mem√≥ria",
    "section": "Boas pr√°ticas",
    "text": "Boas pr√°ticas\nA seguir, algumas sugest√µes de boas pr√°ticas quando gerenciamos a mem√≥ria em C.\n\nEvite opera√ß√µes parciais\nNunca tente liberar apenas parte de uma estrutura alocada. Sempre opere sobre a mesma refer√™ncia retornada por malloc.\nint *v = malloc(10 * sizeof(int));\nint *p = v + 5;\nfree(p); // ‚ùå comportamento indefinido\nfree(v); // ‚úÖ correto\n\n\nZerar mem√≥ria ap√≥s libera√ß√£o (quando necess√°rio)\nEm sistemas que lidam com dados sens√≠veis (como senhas), vale a pena limpar o conte√∫do antes de liberar.\nmemset(senha, 0, tamanho);\nfree(senha);\nIsso impede que dados fiquem acess√≠veis em regi√µes de mem√≥ria reaproveitadas.\n\n\nMacros e wrappers de seguran√ßa\nEm projetos grandes, √© comum encapsular chamadas de aloca√ß√£o/libera√ß√£o em fun√ß√µes auxiliares. Isso facilita rastrear erros e aplicar verifica√ß√µes centralizadas.\nvoid* safe_malloc(size_t n) {\n    void *p = malloc(n);\n    if (p == NULL) {\n        fprintf(stderr, \"Erro: malloc falhou\\n\");\n        return 1;\n    }\n    return p;\n}\n\n\nSe liga! Com esse padr√£o, voc√™ garante que toda aloca√ß√£o seja verificada.\n\nNesta unidade, voc√™ aprendeu\n‚úÖ a alocar e desalocar a mem√≥ria\n‚úÖ a copiar blocos de mem√≥ria\n‚úÖ a evitar erros cl√°ssicos no gerenciamento de memr√≥ria\n‚úÖ a aplicar boas pr√°ticas em grandes projetos\nGerenciar mem√≥ria em C √© uma arte de equil√≠brio entre controle total e responsabilidade absoluta. Com disciplina e padr√µes bem definidos, √© poss√≠vel construir sistemas robustos, perform√°ticos e seguros.\n\n# Qual √© a principal diferen√ßa entre a mem√≥ria *stack* e a *heap*? \n\n&gt; Pense em quem controla o tempo de vida das vari√°veis.\n\n1. [ ] Ambas s√£o √°reas de mem√≥ria est√°tica.\n1. [ ] A *stack* √© usada para dados din√¢micos e a *heap* para dados locais.\n1. [x] A *stack* √© gerenciada automaticamente, enquanto a *heap* exige libera√ß√£o manual.\n1. [ ] A *heap* √© usada apenas por fun√ß√µes recursivas.\n\n\n# Qual √© o princ√≠pio fundamental da aloca√ß√£o din√¢mica de mem√≥ria em C? \n\n&gt; Ele garante que n√£o haja vazamentos de mem√≥ria.\n\n1. [x] Quem aloca, deve liberar.\n1. [ ] Cada vari√°vel deve ser liberada ao final da fun√ß√£o.\n1. [ ] Sempre usar `free` antes de `malloc`.\n1. [ ] Usar `calloc` e `realloc` em conjunto.\n\n\n# O que acontece se `malloc` falhar ao tentar alocar mem√≥ria? \n\n&gt; Lembre-se do valor de retorno.\n\n1. [ ] Retorna um ponteiro inv√°lido.\n1. [x] Retorna `NULL`.\n1. [ ] Lan√ßa uma exce√ß√£o.\n1. [ ] Finaliza automaticamente o programa.\n\n\n# Qual das seguintes fun√ß√µes inicializa automaticamente a mem√≥ria com zeros? \n\n&gt; Ela recebe dois par√¢metros: n√∫mero de elementos e tamanho de cada um.\n\n1. [ ] `malloc`\n1. [x] `calloc`\n1. [ ] `realloc`\n1. [ ] `memset`\n\n\n# Qual √© o uso correto da fun√ß√£o `realloc` para redimensionar um vetor de inteiros?\n\n&gt; Considere a boa pr√°tica de usar um ponteiro tempor√°rio.\n\n1. [ ] `v = realloc(v, novo_tamanho);`\n1. [ ] `realloc(v, novo_tamanho);`\n1. [x] `temp = realloc(v, novo_tamanho); if (temp != NULL) v = temp;`\n1. [ ] `realloc(&v, novo_tamanho);`\n\n\n# Quais das alternativas abaixo s√£o boas pr√°ticas ao liberar mem√≥ria? \n\n&gt; Lembre-se do ciclo: alocar, usar, liberar, invalidar.\n\n- [x] Sempre liberar com `free` antes de perder a refer√™ncia.\n- [x] Definir o ponteiro como `NULL` ap√≥s liberar.\n- [ ] Usar `delete` para desalocar.\n- [ ] Reutilizar o mesmo ponteiro ap√≥s `free` sem reatribuir.\n\n\n# Coloque na ordem correta as etapas do ciclo de manipula√ß√£o de mem√≥ria din√¢mica.\n\n&gt; Siga o ciclo apresentado no fluxograma da se√ß√£o.\n\n1. Alocar (`malloc`, `calloc` ou `realloc`)\n2. Usar (ler e escrever por meio do ponteiro)\n3. Liberar (`free`)\n4. Invalidar o ponteiro (`ptr = NULL`)\n\n\n# Qual √© a fun√ß√£o adequada para copiar dados entre regi√µes de mem√≥ria que podem se sobrepor? \n\n&gt; Ela √© mais segura que `memcpy` em casos de sobreposi√ß√£o.\n\n1. [ ] `memcpy`\n1. [x] `memmove`\n1. [ ] `memset`\n1. [ ] `strcpy`\n\n\n# Quais s√£o cuidados essenciais ao usar `memcpy`, `memmove` e `memset`?\n\n&gt; Elas trabalham em n√≠vel de bytes.\n\n- [x] Sempre usar `sizeof` para calcular o n√∫mero correto de bytes.\n- [x] Usar `memmove` quando houver d√∫vida sobre sobreposi√ß√£o.\n- [ ] Usar `memcpy` para estruturas com ponteiros internos.\n- [ ] Passar valores inteiros diretamente para `memset` sem convers√£o.\n\n\n# Qual √© o erro que ocorre ao usar um ponteiro n√£o inicializado? \n\n&gt; Ele cont√©m um endere√ßo aleat√≥rio.\n\n1. [x] *Wild pointer*\n1. [ ] *Dangling pointer*\n1. [ ] *Memory leak*\n1. [ ] *Double free*\n\n\n# Quais das situa√ß√µes abaixo podem causar comportamento indefinido?\n\n&gt; Pense em acessos inv√°lidos √† mem√≥ria.\n\n- [x] Usar ponteiro ap√≥s `free`.\n- [x] Escrever fora dos limites de um vetor.\n- [ ] Liberar ponteiro definido como `NULL`.\n- [ ] Atribuir `NULL` a um ponteiro liberado.\n\n\n# O que caracteriza um *memory leak*? \n\n&gt; O programa perde acesso ao bloco de mem√≥ria alocado.\n\n1. [x] Perda da refer√™ncia para uma regi√£o alocada sem `free`.\n1. [ ] Escrita al√©m dos limites do vetor.\n1. [ ] Libera√ß√£o dupla da mesma regi√£o.\n1. [ ] Ponteiro n√£o inicializado.\n\n\n# Como evitar o erro *double free*? \n\n&gt; Lembre-se da pr√°tica ap√≥s `free`.\n\n- [x] Atribuir `NULL` ap√≥s liberar.\n- [x] Controlar claramente quem √© o ‚Äúdono‚Äù da mem√≥ria.\n- [ ] Chamar `free` duas vezes para garantir a libera√ß√£o.\n- [ ] Usar `malloc` e `free` na mesma fun√ß√£o sempre.\n\n\n# Qual pr√°tica ajuda a evitar *buffer overflow*? \n\n&gt; Pense no controle dos √≠ndices.\n\n1. [x] Verificar limites dos vetores antes de acessar.\n1. [ ] Usar `malloc` sempre em vez de arrays.\n1. [ ] Evitar o uso de `sizeof`.\n1. [ ] Usar ponteiros n√£o inicializados.\n\n\n# Quais s√£o boas pr√°ticas de seguran√ßa com mem√≥ria sens√≠vel? \n\n&gt; Por exemplo, quando lidamos com senhas.\n\n- [x] Zerar a mem√≥ria antes de liberar.\n- [x] Encapsular aloca√ß√µes em fun√ß√µes seguras como `safe_malloc`.\n- [ ] Deixar senhas em mem√≥ria ap√≥s uso.\n- [ ] Evitar o uso de `free` para n√£o perder dados.\n\n\n# Coloque na ordem correta as a√ß√µes da fun√ß√£o `safe_malloc` descrita no texto. \n\n&gt; Pense no fluxo interno da fun√ß√£o.\n\n1. Chamar `malloc` com o tamanho desejado.\n2. Verificar se o retorno √© `NULL`.\n3. Imprimir mensagem de erro em `stderr` se necess√°rio.\n4. Retornar o ponteiro v√°lido ao chamador.",
    "crumbs": [
      "Gerenciamento da Mem√≥ria"
    ]
  },
  {
    "objectID": "disciplinas/aed2/academic/unidade2/9-tabeladinamica.html",
    "href": "disciplinas/aed2/academic/unidade2/9-tabeladinamica.html",
    "title": "Tabela de Dispers√£o Din√¢mica",
    "section": "",
    "text": "Imagine que voc√™ possui um pequeno m√≥vel com quatro compartimentos:\nCom o tempo, voc√™ percebe que o m√≥vel est√° ficando cheio e decide comprar um novo m√≥vel com o dobro do tamanho, para ter mais espa√ßo e organiza√ß√£o.\nNo novo m√≥vel, os rel√≥gios podem ficar em posi√ß√µes diferentes, por exemplo, o Ferrari agora pode ser guardado no compartimento 6. Al√©m disso, voc√™ adquire um novo rel√≥gio Rolex e o coloca no compartimento 5.\nMais tarde, voc√™ decide presentear seu melhor amigo com o rel√≥gio Xing-ling e vender o Casio. Para completar, um dos rel√≥gios acaba sendo roubado. Agora, dos oito compartimentos, apenas um est√° ocupado. Um grande desperd√≠cio de espa√ßo.\nDiante disso, voc√™ decide trocar novamente de m√≥vel, voltando a um modelo menor, com quatro compartimentos, mais adequado √† sua nova cole√ß√£o.\nEsse comportamento de aumentar ou diminuir o n√∫mero de compartimentos conforme a quantidade de itens √© exatamente o que ocorre em uma tabela hash din√¢mica.\nEm resumo, ela funciona como um ‚Äúguarda-roupa inteligente‚Äù que se adapta automaticamente:\nEssa capacidade de ajustar dinamicamente o tamanho permite que a tabela hash mantenha alto desempenho e uso eficiente de mem√≥ria, independentemente do n√∫mero de elementos armazenados.",
    "crumbs": [
      "Tabela de Dispers√£o Din√¢mica"
    ]
  },
  {
    "objectID": "disciplinas/aed2/academic/unidade2/9-tabeladinamica.html#fator-de-carga",
    "href": "disciplinas/aed2/academic/unidade2/9-tabeladinamica.html#fator-de-carga",
    "title": "Tabela de Dispers√£o Din√¢mica",
    "section": "Fator de Carga",
    "text": "Fator de Carga\nO fator de carga (load factor) determina quando uma tabela hash deve ser expandida ou contra√≠da. Ele √© definido como a raz√£o entre o n√∫mero de elementos armazenados e o n√∫mero total de buckets (ou posi√ß√µes dispon√≠veis na tabela): \\[\\lambda = \\frac{n}{m}\\] onde \\(n\\) √© o n√∫mero de itens atualmente armazenados e \\(m\\) o tamanho da tabela.\nO desempenho ideal de uma tabela hash depende de duas condi√ß√µes principais:\n\numa fun√ß√£o hash eficiente, que distribua os elementos de forma uniforme;\num fator de carga baixo, que mantenha o n√∫mero de colis√µes sob controle.\n\nSe o fator de carga \\(\\lambda\\) for muito alto, o n√∫mero de colis√µes tende a crescer, e as opera√ß√µes de busca, inser√ß√£o e remo√ß√£o podem degradar de O(1) para O(n). Por outro lado, se \\(\\lambda\\) for muito baixo, haver√° desperd√≠cio de espa√ßo, pois a tabela ficar√° com muitos buckets vazios.\nO cora√ß√£o de uma tabela hash din√¢mica √© justamente o processo de redimensionamento, que ajusta o tamanho da tabela conforme o fator de carga ultrapassa (ou cai abaixo de) determinados limites predefinidos. Por exemplo,\n\nexpans√£o: quando \\(\\lambda&gt;0.7\\) ou \\(\\lambda&gt;0.75\\);\ncontra√ß√£o: quando \\(\\lambda&lt;0.25\\).\n\nO processo de redimensionamento normalmente envolve tr√™s etapas principais:\n1. Cria√ß√£o de uma nova tabela\n\nUma nova tabela √© alocada, geralmente com o dobro (em caso de expans√£o) ou metade (em caso de contra√ß√£o) do tamanho atual.\n\n2. Re-hashing dos elementos\n\nTodos os elementos da tabela antiga s√£o reprocessados por uma nova fun√ß√£o hash e inseridos na nova tabela, agora com √≠ndices recalculados conforme o novo tamanho.\n\n3. Substitui√ß√£o\n\nA tabela antiga √© descartada, e a nova tabela passa a ser usada nas pr√≥ximas opera√ß√µes de inser√ß√£o, busca e remo√ß√£o.\n\nFinalmente, podemos citar como vantagens e desvantagens da tabela hash din√¢mica:\n\nVantagensDesvantagens\n\n\nOtimiza√ß√£o do espa√ßo\nA tabela se ajusta √† quantidade de dados, evitando desperd√≠cio de mem√≥ria quando h√° poucos itens e garantindo espa√ßo suficiente para muitos itens.\nDesempenho consistente\nAjuda a manter o fator de carga em n√≠veis √≥timos, garantindo que as opera√ß√µes de O(1) sejam mantidas na m√©dia.\nFacilidade de uso\nO desenvolvedor n√£o precisa se preocupar em prever o tamanho da tabela, simplificando o desenvolvimento.\n\n\nCusto do redimensionamento\nA opera√ß√£o de redimensionamento pode ser custosa, pois envolve a cria√ß√£o de uma nova tabela e o re-hashing de todos os elementos. Isso pode levar a picos de lat√™ncia inesperados.\nComplexidade de implementa√ß√£o\n√â mais complexa de implementar do que uma tabela hash est√°tica.\nCache ineficiente durante redimensionamento\nDurante o re-hashing, os dados podem se espalhar por novas posi√ß√µes de mem√≥ria, o que pode impactar o desempenho do cache da CPU temporariamente.\n\n\n\n\nNesta unidade, voc√™ aprendeu\n‚úÖ o que √© uma tabela de dispers√£o din√¢mica\n‚úÖ a calcular o fator de carga\n‚úÖ a import√¢ncia do fator de carga no desempenho de uma tabela de dispers√£o\n\n# O que caracteriza uma tabela hash din√¢mica? \n\n&gt; Pense na principal diferen√ßa em rela√ß√£o √† tabela hash est√°tica.\n\n1. [ ] Uma tabela que nunca sofre colis√µes.  \n1. [x] Uma tabela que ajusta automaticamente seu tamanho conforme a quantidade de elementos.  \n1. [ ] Uma tabela que usa m√∫ltiplas fun√ß√µes hash ao mesmo tempo.  \n1. [ ] Uma tabela implementada apenas com encadeamento separado.  \n\n# Quando uma tabela hash deve **expandir** seu tamanho? \n\n&gt; Observe o limite superior do fator de carga.\n\n1. [ ] Quando $\\lambda &lt; 0.25$  \n1. [x] Quando $\\lambda &gt; 0.7$  \n1. [ ] Quando $\\lambda = 0$  \n1. [ ] Quando $\\lambda = 1$  \n\n\n# Quando uma tabela hash deve **contrair** seu tamanho?  \n\n&gt; O texto cita o limite inferior.\n\n1. [x] Quando $\\lambda &lt; 0.25$  \n1. [ ] Quando $\\lambda &gt; 0.7$  \n1. [ ] Quando $\\lambda &gt; 1$  \n1. [ ] Quando $\\lambda = 0.75$  \n\n\n# O que representa o fator de carga $\\lambda$? \n\n&gt; Lembre-se da f√≥rmula apresentada.\n\n1. [x] A raz√£o entre o n√∫mero de elementos armazenados e o tamanho total da tabela.  \n1. [ ] A soma dos √≠ndices ocupados da tabela.  \n1. [ ] O n√∫mero de colis√µes dividido pelo tamanho da tabela.  \n1. [ ] O tempo m√©dio de inser√ß√£o em O(n).  \n\n\n# Quais s√£o as etapas do processo de redimensionamento?   \n\n&gt; Coloque as tr√™s fases na ordem correta.\n\n1. Cria√ß√£o de uma nova tabela.  \n2. Re-hashing dos elementos.  \n3. Substitui√ß√£o da tabela antiga.  \n\n\n# Quais s√£o vantagens da tabela hash din√¢mica? \n\n&gt; Elas est√£o listadas na se√ß√£o de ‚ÄúVantagens‚Äù.\n\n- [x] Otimiza√ß√£o do uso de mem√≥ria.  \n- [x] Manuten√ß√£o do desempenho m√©dio em O(1).  \n- [x] Facilidade de uso para o programador.  \n- [ ] Nenhum custo de redimensionamento.  \n\n\n# Quais s√£o desvantagens da tabela hash din√¢mica?  \n\n&gt; Observe os impactos durante o redimensionamento.\n\n- [x] Custo alto durante o redimensionamento.  \n- [x] Maior complexidade de implementa√ß√£o.  \n- [x] Poss√≠vel perda tempor√°ria de desempenho de cache.  \n- [ ] Impossibilidade de armazenar chaves duplicadas.  \n\n\n# Se uma tabela tem 30 elementos e 50 posi√ß√µes, qual √© o fator de carga $\\lambda$?  \n\n&gt; Use $\\lambda = \\frac{n}{m}$.\n\n1. [ ] 0,25  \n1. [x] 0,6  \n1. [ ] 1,25  \n1. [ ] 0,15  \n\n\n# Qual √© a consequ√™ncia de um fator de carga muito alto? \n\n&gt; Relacione com o n√∫mero de colis√µes.\n\n1. [x] Aumento das colis√µes e degrada√ß√£o do desempenho.  \n1. [ ] Redu√ß√£o do n√∫mero de colis√µes.  \n1. [ ] Melhoria no uso do cache da CPU.  \n1. [ ] Economia de mem√≥ria.  \n\n# Qual analogia do texto representa melhor o comportamento da tabela hash din√¢mica? \n\n&gt; Pense no exemplo do m√≥vel.\n\n1. [ ] Um arm√°rio que s√≥ aumenta e nunca diminui.  \n1. [x] Um m√≥vel que expande e contrai conforme a quantidade de rel√≥gios.  \n1. [ ] Um cofre com compartimentos fixos.  \n1. [ ] Um sistema de arquivos linear.",
    "crumbs": [
      "Tabela de Dispers√£o Din√¢mica"
    ]
  },
  {
    "objectID": "disciplinas/aed2/academic/unidade2/4-calculadora.html",
    "href": "disciplinas/aed2/academic/unidade2/4-calculadora.html",
    "title": "Projeto de Calculadora",
    "section": "",
    "text": "Vamos usar os conhecimentos adquiridos at√© aqui para desenvolver uma calculadora simples. Nosso projeto ser√° composto pelo arquivo de cabe√ßalho (calculator.h), a implementa√ß√£o (calculator.c) e o programa que usa nossa calculadora (main_calculator.c).\nAt√© aqui, usamos muitas palavras em portugu√™s, visto que os ponteiros para fun√ß√£o podem causar confus√£o no in√≠cio. Agora, vamos usar mais o ingl√™s nas implementa√ß√µes, pois o ecossistema de programa√ß√£o C (bibliotecas, documenta√ß√£o, e frameworks) utiliza predominantemente o ingl√™s. Adotar o ingl√™s em nomes de vari√°veis, fun√ß√µes e estruturas √© crucial para aderir √†s boas pr√°ticas da ind√∫stria e facilitar a colabora√ß√£o e a leitura global do c√≥digo.",
    "crumbs": [
      "Projeto de Calculadora"
    ]
  },
  {
    "objectID": "disciplinas/aed2/academic/unidade2/4-calculadora.html#interface-da-api",
    "href": "disciplinas/aed2/academic/unidade2/4-calculadora.html#interface-da-api",
    "title": "Projeto de Calculadora",
    "section": "Interface da API",
    "text": "Interface da API\nA interface da calculadora cont√©m um novo tipo Operation que representa uma fun√ß√£o bin√°ria. Como j√° mencionamos √© um ponteiro para uma fun√ß√£o gen√©rica que recebe dois param√™tros. Definimos a estrtura calculadora que cont√©m os campos data_size para o tamanho em bytes do tipo de dados que iremos trabalhar, n_operations para o n√∫mero de opera√ß√µes que a calculadora suporta e um ponteiro operations que cont√©m as opera√ß√µes da calculadora.\n\n\ncalculator.h\n\n#include &lt;stddef.h&gt; // Necess√°rio para o tipo size_t\n\ntypedef void* (*Operation)(const void*, const void*);\n\ntypedef struct calculator {\n    size_t data_size;\n    size_t n_operations;\n    Operation *operations; \n} Calculator;\n\n\n\nSe liga! A palavra chave const indica que os valores passados para a opera√ß√£o n√£o podem ser modificados internamente.\nEm seguida, temos prot√≥tipos das fun√ß√µes para criar e destruir uma calculadora. A fun√ß√£o evaluation j√° √© conhecida e ela coordenda qual callback usar para calcular. Al√©m dela, temos quatro fun√ß√µes de callback para adicionar e multiplicar inteiros ou n√∫meros em ponto flutuante.\n\n\ncalculator.h\n\nCalculator *calculator_create(size_t data_size, \n                              size_t n_operations, \n                              const Operation *operations);\nvoid calculator_destroy(Calculator *calc);\n\nvoid* evaluation(const void *a, const void *b, Operation operation); \n\nvoid* add_int (const void *a, const void *b);\nvoid* add_double (const void *a, const void *b);\nvoid* multiply_int (const void *a, const void *b);\nvoid* multiply_double (const void *a, const void *b);\n\nOperation select_operation_int();\nOperation select_operation_double();\n\nEm resumo:\n\n\n\n\n\n\n\n\nComponente\nFun√ß√£o\nDesign √© S√≥lido\n\n\n\n\ntypedef Operation\nO contrato bin√°rio de todas as fun√ß√µes de c√°lculo.\nO uso de const void* protege os dados de entrada, garantindo que os callbacks apenas leiam.\n\n\nstruct Calculator\nO cont√™iner para metadados e opera√ß√µes.\nOs campos data_size e n_operations (ambos size_t) tornam a estrutura robusta e configur√°vel para qualquer tipo de dado.\n\n\ncalculator_create/destroy\nGerenciamento de ciclo de vida.\nDefine claramente como a mem√≥ria √© alocada e, mais importante, como deve ser liberada.\n\n\nevaluation\nA fun√ß√£o coordenadora.\nMant√©m o c√≥digo principal limpo, delegando a l√≥gica complexa (o callback).\n\n\nCallbacks\nAs fun√ß√µes de soma e multiplica√ß√£o.\nEst√£o prontas para serem implementadas com a l√≥gica de aloca√ß√£o de mem√≥ria e casting de tipos.\n\n\nselect_operation_int\nFun√ß√£o de f√°brica/sele√ß√£o de callback.\nPermite ao usu√°rio selecionar dinamicamente a opera√ß√£o para inteiros em tempo de execu√ß√£o, desacoplando a escolha da l√≥gica de execu√ß√£o.\n\n\nselect_operation_double\nFun√ß√£o de f√°brica/sele√ß√£o de callback.\nPermite ao usu√°rio selecionar dinamicamente a opera√ß√£o para reais em tempo de execu√ß√£o, desacoplando a escolha da l√≥gica de execu√ß√£o.",
    "crumbs": [
      "Projeto de Calculadora"
    ]
  },
  {
    "objectID": "disciplinas/aed2/academic/unidade2/4-calculadora.html#implementa√ß√£o-da-api",
    "href": "disciplinas/aed2/academic/unidade2/4-calculadora.html#implementa√ß√£o-da-api",
    "title": "Projeto de Calculadora",
    "section": "Implementa√ß√£o da API",
    "text": "Implementa√ß√£o da API\nAgora partiremos para a implementa√ß√£o das fun√ß√µes da nossa interface. Primeiramente, vamos estabelecer quais bibliotecas padr√£o C e quais arquivos de interface precisamos importar.\n\n\ncalculator.c\n\n#include \"calculator.h\"\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;assert.h&gt;\n#include &lt;stdio.h&gt;\n\nNa primeira linha, estamos importando nossa interface calculator.h. Como ela n√£o faz parte da biblioteca padr√£o de C, usamos aspas duplas (\"...\") designando o caminho (basta o nome, pois ela est√° na mesma pasta).\nEm seguida, importamos quatro bibliotecas padr√£o:\n\n&lt;stdlib.h&gt;: Essencial para o gerenciamento de mem√≥ria (malloc e free).\n&lt;string.h&gt;: Necess√°ria para o m√©todo memcpy, que utilizaremos para realizar a c√≥pia segura de dados e dos ponteiros de fun√ß√£o em um contexto gen√©rico.\n&lt;assert.h&gt;: Usada para a macro assert, que insere verifica√ß√µes de seguran√ßa no c√≥digo e garante que as pr√©-condi√ß√µes das fun√ß√µes sejam atendidas.\n&lt;stdio.h&gt;: Usada para imprimir mensagem na tela e receber dados do usu√°rio.\n\nCom as depend√™ncias definidas, podemos come√ßar a implementa√ß√£o das fun√ß√µes, come√ßando pelo construtor calculator_create.\n\n\ncalculator.c\n\nCalculator *calculator_create(size_t data_size, \n                              size_t n_operations, \n                              const Operation *operations) {\n    assert(data_size &gt; 0);\n    assert(n_operations &gt; 0);   \n    assert(operations != NULL); \n    \n    Calculator *calc = (Calculator *)malloc(sizeof(Calculator));\n    calc-&gt;data_size = data_size;\n    calc-&gt;n_operations = n_operations;\n    calc-&gt;operations = (Operation *)malloc(sizeof(Operation) * n_operations);\n\n    if (calc-&gt;operations == NULL) {\n        free(calc);\n        return NULL;\n    }\n\n    memcpy(calc-&gt;operations, operations, sizeof(Operation) * n_operations);\n\n    return calc;\n}\n\nO primeiro ato √© verificar as pr√©-condi√ß√µes com assert. Caso a pr√©-condi√ß√£o seja falsa, o programa √© abortado, especificando qual condi√ß√£o falhou e em qual linha ela se encontra.\n\nassert(data_size &gt; 0): Esta verifica√ß√£o garante que a calculadora tenha recebido um tamanho de dado v√°lido. N√£o faz sentido alocar mem√≥ria para um dado com 0 bytes, o que √© fundamental para a fun√ß√£o memcpy funcionar corretamente.\nassert(n_operations &gt; 0) e assert(operations != NULL): Esses asserts trabalham em conjunto para garantir que a calculadora possa de fato operar. Eles verificam que h√° pelo menos uma fun√ß√£o de callback para a calculadora utilizar e que o ponteiro para o array de callbacks n√£o √© nulo.\n\nO restante da fun√ß√£o executa a aloca√ß√£o para Calculator, inicializa os campos e usa o tratamento de erro (rollback) para liberar corretamente a mem√≥ria se algo falhar na aloca√ß√£o do array de opera√ß√µes. O uso de memcpy finaliza a fun√ß√£o, garantindo que a estrutura Calculator √© dona de sua pr√≥pria tabela de callbacks. Ela copia o array de opera√ß√µes passado de forma segura, byte a byte.\nPara cada construtor, implemente um destrutor (ou, mais precisamente, para cada malloc deve haver um free correspondente). Use esse princ√≠pio para programar em C e evitar vazamentos de mem√≥ria (memory leaks). Uma vez que criamos o construtor da calculadora, vamos criar seu destrutor, calculator_destroy.\nPrimeiro, devemos liberar a mem√≥ria alocada para as opera√ß√µes. Depois, a mem√≥ria alocada para a estrutura principal da calculadora. √â uma boa pr√°tica verificar se o ponteiro √© v√°lido antes de tentar liberar.\n\n\ncalculator.c\n\nvoid calculator_destroy(Calculator *calc) {\n    if (calc == NULL) return;\n\n    // 1. Libera o array de opera√ß√µes (operations).\n    if (calc-&gt;operations != NULL) {\n        free(calc-&gt;operations);\n        calc-&gt;operations = NULL; \n    }\n    \n    // 2. Libera a estrutura Calculator principal.\n    free(calc);\n}\n\nA ordem de libera√ß√£o √© crucial: se a gente liberasse a estrutura principal free(calc) primeiro, o endere√ßo de calc-&gt;operations (que est√° dentro de calc) seria perdido para sempre. Isso resultaria em um vazamento de mem√≥ria (memory leak), pois voc√™ n√£o conseguiria liberar o array de opera√ß√µes.\nDepois de liberar a mem√≥ria, √© uma boa pr√°tica atribuir o valor NULL ao ponteiro a fim de evitar ponteiros pendentes (dangling pointers). No entanto, note que n√£o fazemos isso com o ponteiro calc, porque ele foi passado por valor. A vari√°vel calc dentro desta fun√ß√£o √© apenas uma c√≥pia do endere√ßo; o ponteiro original (por exemplo, calculator_int) no main n√£o √© alterado.\nA fun√ß√£o coordenadora (evaluation) √© a parte mais simples da nossa implementa√ß√£o. Ela n√£o precisa saber qual opera√ß√£o est√° sendo executada, apenas delega a responsabilidade para a fun√ß√£o de callback que foi passada:\n\n\ncalculator.c\n\nvoid* evaluation(const void *a, const void *b, Operation operation){\n  return operation(a, b);\n} \n\nAs fun√ß√µes que realmente realizam o c√°lculo seguem um protocolo rigoroso para garantir a generalidade e o gerenciamento de mem√≥ria. Cada callback deve:\n\nAlocar Mem√≥ria: Usar malloc para reservar espa√ßo para o resultado na mem√≥ria heap.\nFazer o Casting: Converter o ponteiro gen√©rico de entrada (const void*) para o tipo de dado correto (ex: int* ou double*) para que a opera√ß√£o possa ser realizada.\nDesreferenciar e Calcular: Acessar o valor real (*) do ponteiro para realizar a opera√ß√£o.\nRetornar: Reverter o ponteiro do resultado para o tipo gen√©rico (void*).\n\nObserve nos exemplos de soma como o casting √© usado para transformar o ponteiro gen√©rico (a, b) no tipo esperado:\n\n\ncalculator.c\n\n// Callback para Soma de Inteiros \nvoid* add_int (const void *a, const void *b){\n    int *result = malloc(sizeof(int));\n    \n    // Casting de (const void*) para (int*), seguido pela desrefer√™ncia (*)\n    *result = *(int*)a + *(int*)b; \n    \n    return (void*)result; \n}\n\n// Callback para Soma de Ponto Flutuante\nvoid* add_double (const void *a, const void *b){\n    double *result = malloc(sizeof(double));\n    \n    // Casting de (const void*) para (double*), seguido pela desrefer√™ncia (*)\n    *result = *(double*)a + *(double*)b; \n    \n    return (void*)result; \n}\n\nAs outras fun√ß√µes de callback para multiplica√ß√£o (multiply_int e multiply_double) seguir√£o exatamente o mesmo padr√£o de aloca√ß√£o e casting.\nOs ponteiros de fun√ß√£o nos permitem criar interfaces din√¢micas, como um menu interativo, permitindo que o usu√°rio selecione qual callback deve ser executado em tempo de execu√ß√£o. A fun√ß√£o select_operation_int √© o nosso exemplo de fun√ß√£o de f√°brica para callbacks de inteiros. Seu objetivo √© mapear a entrada num√©rica do usu√°rio para o endere√ßo de mem√≥ria da fun√ß√£o de callback correspondente.\n\n\ncalculator.c\n\nOperation select_operation_int() {\n    int option = 0;\n    printf(\"Escolha sua opera√ß√£o:\\n\");\n    printf(\"1. Soma\\n\");\n    printf(\"2. Multiplica√ß√£o\\n\");\n    printf(\"Digite: \");\n    scanf(\"%d\", &option);\n\n    if (option == 1) return add_int;\n    else if (option == 2) return multiply_int;\n    else return NULL; // Retorna NULL como ponteiro de fun√ß√£o inv√°lido\n}\n\nO bloco de controle de fluxo if-else √© a parte central da fun√ß√£o. Ele mapeia o inteiro c diretamente para o endere√ßo de mem√≥ria da fun√ß√£o de callback desejada. Dessa forma, a fun√ß√£o est√° pronta para ser usada no nosso main para selecionar dinamicamente a opera√ß√£o!\nDo mesmo modo, a fun√ß√£o select_operation_double() √© implementada.",
    "crumbs": [
      "Projeto de Calculadora"
    ]
  },
  {
    "objectID": "disciplinas/aed2/academic/unidade2/4-calculadora.html#uso-da-api",
    "href": "disciplinas/aed2/academic/unidade2/4-calculadora.html#uso-da-api",
    "title": "Projeto de Calculadora",
    "section": "Uso da API",
    "text": "Uso da API\nNossa calculadora simples est√° finalmente finalizada. Prosseguiremos exemplificando o uso da mesma.\n\n\nmain_calculator.c\n\n#include \"calculator.h\"\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main() {\n    \n    Operation operations[] = {add_int, multiply_int};\n    size_t n_operations = sizeof(operations) / sizeof(operations[0]); \n    \n    // 1. CRIA√á√ÉO E TRATAMENTO DE ERRO\n    Calculator* calculator_int = calculator_create(sizeof(int), \n                                                   n_operations, \n                                                   operations);\n    \n    if (calculator_int == NULL) {\n        fprintf(stderr, \"Erro: Falha ao alocar a estrutura Calculator.\\n\");\n        return 1;\n    }\n    \n    // Dados para teste\n    int a = 10;\n    int b = 2;\n    \n    // 2. SELE√á√ÉO E EXECU√á√ÉO\n    Operation selected_op = select_operation_int(); \n    \n    if (selected_op == NULL) {\n        fprintf(stderr, \"Erro: Opera√ß√£o inv√°lida selecionada.\\n\");\n        calculator_destroy(calculator_int); // Limpa o que foi criado\n        return 1;\n    }\n\n    // Chama evaluation, que aloca o resultado na heap\n    void *result_ptr = evaluation(&a, &b, selected_op);\n    \n    if (result_ptr == NULL) {\n        fprintf(stderr, \"Erro: Falha ao alocar mem√≥ria para o resultado.\\n\");\n        calculator_destroy(calculator_int); // Limpa o que foi criado\n        return 1;\n    }\n    \n    printf(\"Resultado: %d\\n\", *(int*)result_ptr);\n\n    // 3. LIMPEZA DA MEM√ìRIA\n    \n    // 3.1 Libera a mem√≥ria alocada DENTRO do callback\n    free(result_ptr); \n    \n    // 3.2 Libera a estrutura Calculator e suas opera√ß√µes internas\n    calculator_destroy(calculator_int); \n    calculator_int = NULL; // Boa pr√°tica: anular o ponteiro\n    \n    return 0;\n}\n\nLembrando que para compilar nossa calculadora, garantindo que ambos os arquivos de implementa√ß√£o sejam processado, devemos executar o seguinte comando no terminal:\n$ gcc calculator.c main_calculator.c -o calc\nIsso ir√° gerar um execut√°vel chamado calc na sua pasta.\nFinalizamos a implementa√ß√£o da nossa Calculadora Gen√©rica. Ela pode n√£o estar perfeita, mas conseguimos aplicar e solidificar conceitos avan√ßados que d√£o um grande up em nossa jornada na programa√ß√£o C. Em particular, a manipula√ß√£o de ponteiros gen√©ricos (void*) e o uso de ponteiros para fun√ß√µes como callbacks s√£o ferramentas poderos√≠ssimas que devem ser exploradas com afinco.\nComo sugest√£o de aprimoramento e pr√°tica adicional, voc√™ pode tentar modularizar o sistema e refinar a interface do usu√°rio:\n\n\n\n\n\n\nNotaüéØ Desafio de C√≥digo\n\n\n\nModulariza√ß√£o\n\nMova as fun√ß√µes select_operation_int e select_operation_double para um novo par de arquivos de utilit√°rio (por exemplo, ui.c/ui.h). Isso ajuda a manter o arquivo principal (calculator.c) focado apenas na l√≥gica de c√°lculo, separando a interface do usu√°rio da l√≥gica de neg√≥cios.\n\nRefinamento do Tipo\n\nRefine a interface do usu√°rio criando uma fun√ß√£o inicial que permita ao usu√°rio escolher entre os tipos (int ou double) antes de chamar as fun√ß√µes de sele√ß√£o de opera√ß√£o.\n\n\n\n\nNesta unidade, voc√™ aprendeu\n‚úÖ a criar um projeto gen√©rico com interface, implementa√ß√£o e uso\n‚úÖ a aplicar os conceitos de fun√ß√£o de ordem superior e callback\n‚úÖ a gerenciar o ciclo de vida dos objetos na mem√≥ria alocando e desalocando\n‚úÖ a compilar um projeto com mais de um arquivo .c\n\n# Qual √© o principal prop√≥sito do projeto da calculadora?\n\n&gt; Pense na aplica√ß√£o dos conceitos anteriores.\n\n1. [ ] Criar uma calculadora apenas para inteiros.\n1. [ ] Demonstrar heran√ßa e polimorfismo em C.\n1. [x] Consolidar o uso de ponteiros gen√©ricos e ponteiros para fun√ß√µes.\n1. [ ] Implementar opera√ß√µes matem√°ticas complexas.\n\n\n# O que o tipo `Operation` representa no c√≥digo?\n\n&gt; Ele √© um dos pilares da arquitetura da calculadora.\n\n1. [ ] Um tipo gen√©rico de vari√°vel num√©rica.\n1. [x] Um ponteiro para fun√ß√£o que recebe dois argumentos gen√©ricos.\n1. [ ] Uma estrutura auxiliar de armazenamento.\n1. [ ] Um alias para `void*` usado para resultados.\n\n\n# Qual √© a fun√ß√£o do campo `data_size` na estrutura `Calculator`?\n\n&gt; Lembre-se da import√¢ncia do `size_t`.\n\n1. [x] Indicar o tamanho em bytes do tipo de dado que ser√° manipulado.\n1. [ ] Controlar o n√∫mero m√°ximo de opera√ß√µes executadas.\n1. [ ] Armazenar o resultado da √∫ltima opera√ß√£o.\n1. [ ] Determinar o n√∫mero de callbacks dispon√≠veis.\n\n\n# Sobre o uso de `const` em `Operation`, qual √© a alternativa correta?\n\n&gt; A palavra-chave tem papel importante na seguran√ßa do c√≥digo.\n\n1. [x] Garante que os par√¢metros passados n√£o ser√£o modificados internamente.\n1. [ ] Impede a fun√ß√£o de retornar um valor.\n1. [ ] Indica que a fun√ß√£o deve ser inline.\n1. [ ] Torna o ponteiro de fun√ß√£o imut√°vel.\n\n\n# Quais fun√ß√µes fazem parte do gerenciamento de ciclo de vida da calculadora?\n\n&gt; Pense em aloca√ß√£o e libera√ß√£o de mem√≥ria.\n\n- [x] `calculator_create`\n- [x] `calculator_destroy`\n- [ ] `evaluation`\n- [ ] `select_operation_int`\n\n\n# Coloque na ordem as etapas executadas dentro de `calculator_create`.\n\n&gt; Observe o processo de cria√ß√£o e inicializa√ß√£o.\n\n1. Verificar pr√©-condi√ß√µes com `assert`.\n2. Alocar mem√≥ria para `Calculator`.\n3. Alocar mem√≥ria para o array `operations`.\n4. Copiar o conte√∫do das opera√ß√µes com `memcpy`.\n5. Retornar o ponteiro da nova calculadora.\n\n\n# Qual √© o papel da fun√ß√£o `calculator_destroy`?\n\n&gt; Pense na ordem correta da libera√ß√£o.\n\n1. [ ] Limpar apenas os dados dos resultados.\n1. [x] Liberar o array de opera√ß√µes e depois a estrutura principal.\n1. [ ] Encerrar o programa e exibir mensagem de sucesso.\n1. [ ] Apenas definir todos os ponteiros como `NULL`.\n\n\n# Quais pr√°ticas de seguran√ßa de mem√≥ria s√£o usadas em `calculator_destroy`?\n\n&gt; Observe o padr√£o de boas pr√°ticas.\n\n- [x] Verifica√ß√£o de ponteiro nulo antes de liberar.\n- [x] Libera√ß√£o dos recursos na ordem inversa da aloca√ß√£o.\n- [x] Atribui√ß√£o de `NULL` ap√≥s `free` para evitar ponteiros pendentes.\n- [ ] Reutiliza√ß√£o autom√°tica da estrutura ap√≥s libera√ß√£o.\n\n\n# O que a fun√ß√£o `evaluation` faz?\n\n&gt; Ela √© o ponto de coordena√ß√£o da execu√ß√£o.\n\n1. [ ] Calcula e imprime o resultado diretamente.\n1. [x] Chama a fun√ß√£o de callback adequada, repassando os par√¢metros.\n1. [ ] Faz a sele√ß√£o autom√°tica da opera√ß√£o.\n1. [ ] Libera os ponteiros ap√≥s a execu√ß√£o.\n\n\n# Qual √© o comportamento comum √†s fun√ß√µes `add_int` e `add_double`?\n\n&gt; Elas seguem o mesmo protocolo de implementa√ß√£o.\n\n- [x] Fazem cast dos ponteiros gen√©ricos para o tipo correto.\n- [x] Alocam mem√≥ria dinamicamente para o resultado.\n- [x] Retornam um `void*` apontando para o resultado.\n- [ ] Escrevem o resultado diretamente em `stdout`.\n\n\n# Qual seria o problema se as fun√ß√µes de callback n√£o alocassem mem√≥ria?\n\n&gt; Pense no tempo de vida dos dados retornados.\n\n1. [ ] A fun√ß√£o n√£o conseguiria imprimir o resultado.\n1. [x] O ponteiro retornado apontaria para uma vari√°vel local inv√°lida.\n1. [ ] O compilador n√£o aceitaria o retorno do tipo `void*`.\n1. [ ] O programa entraria em loop infinito.\n\n\n# Sobre as fun√ß√µes `multiply_int` e `multiply_double`, assinale o correto.\n\n&gt; Elas espelham a l√≥gica das fun√ß√µes de soma.\n\n1. [ ] Fazem casting incorreto para `float*`.\n1. [x] Seguem o mesmo padr√£o de aloca√ß√£o, casting e retorno das fun√ß√µes de soma.\n1. [ ] S√£o implementadas com recurs√£o.\n1. [ ] Liberam automaticamente o resultado ap√≥s a execu√ß√£o.\n\n\n# Qual √© a fun√ß√£o principal de `select_operation_int`?\n\n&gt; Veja o papel do menu interativo.\n\n1. [x] Retornar o endere√ßo da fun√ß√£o correspondente √† opera√ß√£o escolhida.\n1. [ ] Executar diretamente a opera√ß√£o selecionada.\n1. [ ] Criar uma nova estrutura de calculadora.\n1. [ ] Exibir o resultado na tela.\n\n\n# Coloque em ordem as etapas principais da execu√ß√£o em `main_calculator.c`.\n\n&gt; Elas seguem o fluxo do programa principal.\n\n1. Criar a calculadora com `calculator_create`.\n2. Selecionar a opera√ß√£o via `select_operation_int`.\n3. Chamar `evaluation` para obter o resultado.\n4. Exibir o resultado na tela.\n5. Liberar os recursos com `free` e `calculator_destroy`.\n\n\n# Quais verifica√ß√µes de erro s√£o realizadas em `main_calculator.c`?\n\n&gt; Seguran√ßa sempre vem primeiro.\n\n- [x] Verifica se `calculator_create` retornou `NULL`.\n- [x] Verifica se a opera√ß√£o selecionada √© v√°lida.\n- [x] Verifica se houve falha na aloca√ß√£o do resultado.\n- [ ] Verifica se o usu√°rio digitou um n√∫mero negativo.\n\n\n# Por que `calculator_int` √© definido como `NULL` ao final do programa?\n\n&gt; Uma boa pr√°tica de limpeza.\n\n1. [x] Para evitar ponteiros pendentes ap√≥s `free`.\n1. [ ] Porque o compilador exige inicializa√ß√£o nula.\n1. [ ] Para permitir o reuso autom√°tico da mem√≥ria.\n1. [ ] Porque `free` n√£o libera o ponteiro corretamente.\n\n\n# Coloque em ordem o ciclo de vida da mem√≥ria nesta aplica√ß√£o.\n\n&gt; Do in√≠cio ao final da execu√ß√£o.\n\n1. Aloca√ß√£o de `Calculator` com `malloc`.\n2. Aloca√ß√£o de `operations`.\n3. Aloca√ß√£o do resultado dentro do callback.\n4. Libera√ß√£o do resultado com `free`.\n5. Libera√ß√£o de `operations` e da estrutura principal.\n\n\n# Quais melhorias s√£o sugeridas no desafio de c√≥digo?\n\n&gt; Elas visam modulariza√ß√£o e clareza.\n\n- [x] Separar a interface do usu√°rio em arquivos `ui.c` e `ui.h`.\n- [x] Permitir que o usu√°rio escolha entre `int` e `double`.\n- [ ] Adicionar suporte a opera√ß√µes de subtra√ß√£o.\n- [ ] Mudar toda a estrutura para C++.\n\n\n# Quais conceitos fundamentais s√£o refor√ßados neste projeto?\n\n&gt; Ele consolida a base da programa√ß√£o modular em C.\n\n- [x] Uso de ponteiros gen√©ricos (`void*`).\n- [x] Ponteiros para fun√ß√µes como callbacks.\n- [x] Modulariza√ß√£o com m√∫ltiplos arquivos `.c`.\n- [ ] Programa√ß√£o orientada a objetos nativa.",
    "crumbs": [
      "Projeto de Calculadora"
    ]
  },
  {
    "objectID": "disciplinas/aed2/index.html",
    "href": "disciplinas/aed2/index.html",
    "title": "Algoritmos e Estruturas de Dados 2",
    "section": "",
    "text": "Bem-vindo ao portal de REA sobre Algoritmos e Estruturas de Dados 2. Aqui voc√™ encontrar√° informa√ß√µes sobre a bibliografia, aulas ministradas e muito mais. Para iniciar ou continuar seus estudos, escolha uma das vers√µes dispon√≠veis abaixo.\nOs exerc√≠cios propostos est√£o divididos em tr√™s categorias:\nAl√©m disso, h√° um conjunto de exerc√≠cios interativos, onde voc√™ pode aprender de forma descontra√≠da o funcionamento das mais diversas estruturas como √°rvores, filas de prioridade, heaps, tabelas hash e grafos."
  },
  {
    "objectID": "disciplinas/aed2/index.html#bibliografia",
    "href": "disciplinas/aed2/index.html#bibliografia",
    "title": "Algoritmos e Estruturas de Dados 2",
    "section": "Bibliografia",
    "text": "Bibliografia\n\nRecomendada\n\n\nASCENCIO, A. F. G. Estrutura de Dados. S√£o Paulo: Pearson, 2011. 448 p.\n\nSZWARCFITER, J. L.; MARKENZON, L. Estruturas de Dados e Seus Algoritmos. 3¬™ ed.¬†Rio de Janeiro: LTC, 2010. 318 p.\n\nZIVIANI, N. Projeto de Algoritmos com Implementa√ß√µes em Java e C++. S√£o Paulo: Thomson Learning, 2006. 642 p.\n\n\n\nComplementar\nTOSCANI, L. V.; VELOSO, P. A. S. Complexidade de Algoritmos ‚Äì Vol. 13. 3¬™ ed.¬†Porto Alegre: Bookman, 2012. 280 p.¬†(S√©rie de livros did√°ticos em inform√°tica ‚Äì UFRGS).\nLOPES, A.; GARCIA, G. Introdu√ß√£o √† Programa√ß√£o. Rio de Janeiro: Campus, 2002. 488 p.\nDEITEL, P.; DEITEL, H. C: Como Programar. 6¬™ ed.¬†S√£o Paulo: Pearson, 2007. 848 p.\nTENENBAUM, A. M.; LANGSAM, Y.; AUGENSTEIN, M. J. Estruturas de Dados Usando C. S√£o Paulo: Makron Books, 1995. 904 p.\nMIZRAHI, V. V. Treinamento em Linguagem C. 2¬™ ed.¬†S√£o Paulo: Prentice-Hall, 2008. 432 p."
  },
  {
    "objectID": "disciplinas/aed2/gaming/unidade2/1-ponteiros.html",
    "href": "disciplinas/aed2/gaming/unidade2/1-ponteiros.html",
    "title": "üèùÔ∏è Ilha dos Ponteiros",
    "section": "",
    "text": "Sauda√ß√µes!\nInfelizmente, naufragamos na trai√ßoeira Ilha dos Ponteiros. Este lugar √© uma pris√£o natural, cheia de refer√™ncias complexas e caminhos que se perdem se n√£o forem gerenciados corretamente.\nJuntamente com Shell, usaremos nossas habilidades para escapar."
  },
  {
    "objectID": "disciplinas/aed2/gaming/unidade2/1-ponteiros.html#sec-dec",
    "href": "disciplinas/aed2/gaming/unidade2/1-ponteiros.html#sec-dec",
    "title": "üèùÔ∏è Ilha dos Ponteiros",
    "section": "Declara√ß√£o e Desreferencia√ß√£o",
    "text": "Declara√ß√£o e Desreferencia√ß√£o\nQuando declaramos uma vari√°vel e atribu√≠mos um valor, esse valor √© armazenado em um endere√ßo de mem√≥ria. Quando escrevemos int x = 10;, ocorrem dois passos conceituais:\n\nDeclara√ß√£o: o programa reserva um espa√ßo na mem√≥ria para armazenar um inteiro.\nAtribui√ß√£o: o valor 10 √© gravado nesse espa√ßo de mem√≥ria, que possui um endere√ßo.\n\nA vari√°vel x √© apenas um r√≥tulo usado pelo programador.\n\n\n\nVari√°vel\nEndere√ßo\nConte√∫do\n\n\n\n\nx\n0x75\n10\n\n\n\nUm ponteiro tamb√©m √© uma vari√°vel, mas sempre armazena o endere√ßo de mem√≥ria de outra vari√°vel. Essa habilidade √© essencial para criar estruturas de dados din√¢micas.\nO princ√≠pio b√°sico √© a compatibilidade de tipo, ou seja, um ponteiro deve ser do mesmo tipo do dado que ele aponta.\ndouble meta = 7.5;\ndouble *meta_ptr = &meta; // O operador & retorna o endere√ßo na mem√≥ria\nprintf(\"*meta_ptr: %.2f\\n\", *meta_ptr); // *meta_ptr: 7.50\nüí° Na linha 2, meta_ptr guarda o endere√ßo da vari√°vel meta. Na linha 3, o operador * serve para desreferenciar, isto √©, acessar o valor no endere√ßo armazenado.\nüßÆ Mem√≥ria ilustrada\n\n\n\nVari√°vel\nEndere√ßo\nConte√∫do\n\n\n\n\nmeta\n0x55\n7.5\n\n\nmeta_ptr\n0x58\n0x55\n\n\n\nEstamos usando endere√ßos fict√≠cios. Note que meta_ptr guarda o endere√ßo de meta. Ao usar *meta_ptr na impress√£o, o C acessa o valor armazenado nesse endere√ßo (7.5).\n\n\n\n\n\n\nDica‚ö° Dica do Mentor\n\n\n\nO * tem dupla fun√ß√£o:\n\nDeclarar um ponteiro (double *p)\nDesreferenciar um ponteiro (*p)\n\n\n\n\n\n\n\nPodemos ir um pouco devagar aqui, pois √© crucial entender como funciona esse mecanismo. Para isso, eu criei a seguinte ilustra√ß√£o.\n\n\n\n\n\n\n\n\nflowchart RL\n    %% N√≥s de vari√°veis e ponteiros\n    X[\"üì¶ &lt;b&gt;x&lt;/b&gt;&lt;br/&gt;Endere√ßo: &lt;code&gt;0x100&lt;/code&gt;&lt;br/&gt;Conte√∫do: &lt;b&gt;42&lt;/b&gt;\"]\n    Y[\"üì¶ &lt;b&gt;y&lt;/b&gt;&lt;br/&gt;Endere√ßo: &lt;code&gt;0x200&lt;/code&gt;&lt;br/&gt;Conte√∫do: &lt;b&gt;137&lt;/b&gt;\"]\n    P[\"üéØ &lt;b&gt;p&lt;/b&gt;&lt;br/&gt;Endere√ßo: &lt;code&gt;0x300&lt;/code&gt;&lt;br/&gt;Conte√∫do: &lt;code&gt;0x100&lt;/code&gt;\"]\n    PP[\"üéØ &lt;b&gt;pp&lt;/b&gt;&lt;br/&gt;Endere√ßo: &lt;code&gt;0x400&lt;/code&gt;&lt;br/&gt;Conte√∫do: &lt;code&gt;0x300&lt;/code&gt;\"]\n\n    %% Conex√µes\n    PP --&gt;|\"aponta para\"| P\n    P --&gt;|\"aponta para\"| X\n    P ~~~ Y\n    Y ~~~ X\n\n    %% Estilos de formata√ß√£o\n    classDef var fill:#A8E6CF,stroke:#2E7D32,color:#000,stroke-width:1px;\n    classDef ptr fill:#FFD3B6,stroke:#E65100,color:#000,stroke-width:1px;\n    class X,Y var\n    class P,PP ptr\n\n\n\n\n\n\nAs vari√°veis x e y carregam dados que est√£o armazenados nos endere√ßos 0x100 e 0x200, respectivamente. A vari√°vel p √© um ponteiro cujo conte√∫do √© 0x100, portanto aponta para x. A vari√°vel pp √© outro ponteiro, mas com conte√∫do 0x300, ou seja, aponta para o local com endere√ßo 0x300, que seria p. Isso mesmo um ponteiro de ponteiro. O c√≥digo que representa esse diagrama poder ser o seguinte.\nint x = 42;\nint y = 137;\nint *p = &x;\nint **pp = &p;\n\n\n\n\n\n\nResumindo\n\nx ‚Üí cont√©m 42 e est√° no endere√ßo 0x100;\ny ‚Üí cont√©m 137 e est√° no endere√ßo 0x200;\np ‚Üí cont√©m 0x100 (o endere√ßo de x);\npp ‚Üí cont√©m 0x300 (o endere√ßo de p).\n\n\n\n\nPodemos declarar ponteiros de v√°rias formas:\ndouble *meta_ptr = &meta;\ndouble* meta_ptr = &meta;\ndouble * meta_ptr = &meta;\nNo entanto, a primeira √© mais recomendada: tipo *ponteiro = &variavel.\n‚úÖ +5 XP : Voc√™ agora entende a sintaxe dos ponteiros!"
  },
  {
    "objectID": "disciplinas/aed2/gaming/unidade2/1-ponteiros.html#sec-mod",
    "href": "disciplinas/aed2/gaming/unidade2/1-ponteiros.html#sec-mod",
    "title": "üèùÔ∏è Ilha dos Ponteiros",
    "section": "Modificando Valores Indiretamente",
    "text": "Modificando Valores Indiretamente\nAl√©m de ler, voc√™ tamb√©m pode modificar valores indiretamente usando ponteiros:\ndouble meta = 7.5;\ndouble *meta_ptr = &meta; \n\n*meta_ptr = 10;\nprintf(\"meta: %.2f\\n\", meta); // meta: 10.00\n\n\n\n\nMudamos o valor de meta sem acess√°-la diretamente. Isso √© o poder dos ponteiros!\n\n\n\n\n\n\n\n\n\nNotaüéØ Desafio de C√≥digo\n\n\n\n\nCrie um ponteiro int *p que aponte para uma vari√°vel x = 5.\nUse *p para alterar x para 42.\nDepois, exiba o valor e o endere√ßo de x no console.\n\n\n\n\n\n\n\n\n\nDicaSolu√ß√£o (clique para ver)\n\n\n\n\n\n#include &lt;stdio.h&gt; \n\nint main(){\n    int x = 5;\n    int *p = &x;\n    *p = 42;\n\n    printf(\"x: %d\\n\", x);\n    printf(\"&x: %p\\n\", &x);\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\nNotaüéØ Desafio de C√≥digo\n\n\n\n\nPasso 1: Declare um ponteiro ponteiro_chave que aponte para a chave_secreta.\nPasso 2: Mude o valor da chave_secreta para 99 usando o ponteiro.\nPasso 3: Imprima o valor da chave secreta.\n\n#include &lt;stdio.h&gt;\n\nint main() {\n    int chave_secreta = 10;\n    // SEU C√ìDIGO\n\n    return 0;\n}\n\n\n\n\n\n\n\n\nDicaSolu√ß√£o (clique para ver)\n\n\n\n\n\n#include &lt;stdio.h&gt; \n\nint main() {\n    int chave_secreta = 10;\n    int *ponteiro_chave = &chave_secreta;\n    *ponteiro_chave = 99;\n\n    printf(\"chave_secreta: %d\\n\", chave_secreta);\n    return 0;\n}\n\n\n\nüèÖ +10 XP : Voc√™ dominou a manipula√ß√£o indireta de valores!"
  },
  {
    "objectID": "disciplinas/aed2/gaming/unidade2/1-ponteiros.html#sec-par",
    "href": "disciplinas/aed2/gaming/unidade2/1-ponteiros.html#sec-par",
    "title": "üèùÔ∏è Ilha dos Ponteiros",
    "section": "Ponteiros como Par√¢metros",
    "text": "Ponteiros como Par√¢metros\nAcredito que estamos perto de deixar esta ilha. Por enquanto, a situa√ß√£o est√° calma, mas n√£o podemos subestimar este local. Parece que encontramos algo que exige a nossa aten√ß√£o imetata.\nEm C, os par√¢metros s√£o passados por valor. Portanto, a fun√ß√£o recebe uma c√≥pia do argumento.\nvoid dobrar_meta (double meta){ \n    meta = 2*meta; \n}\nNa main:\ndouble meta = 7.5;\nprintf(\"meta: %.2f\\n\", meta);\ndobrar_meta(meta);\nprintf(\"meta: %.2f\\n\", meta);\nSa√≠da:\nmeta: 7.50\nmeta: 7.50\nNada mudou, pois a fun√ß√£o alterou apenas a c√≥pia local.\n\n\n\n\nA vari√°vel meta na fun√ß√£o main √© global, j√° na fun√ß√£o dobrar_meta √© local. Significa que quando esta fun√ß√£o termina, as vari√°veis s√£o descartadas.\n\n\n\nüí° Vamos imprimir os endere√ßos\nvoid dobrar_meta (double meta){ \n    printf(\"local &meta: %x\\n\", &meta);\n    meta = 2*meta; \n}\nNa main:\ndouble meta = 7.5;\nprintf(\"main &meta: %x\\n\", &meta);\ndobrar_meta(meta);\nSa√≠da:\nmain &meta: 0xe8\nlocal &meta: 0xc0\nüßÆ Mem√≥ria ilustrada\n\n\n\nVari√°vel\nEndere√ßo\nConte√∫do\n\n\n\n\nmain meta\n0xe8\n7.5\n\n\nlocal meta\n0xc0\n7.5\n\n\n\n\n\n\n\nComo eu suspeitava, os endere√ßos s√£o diferentes. Logo, n√£o s√£o as mesmas vari√°veis que estamos manipulando.\n\n\n\nA vari√°vel interna em dobrar_meta √© criada em outra regi√£o de mem√≥ria e recebe uma c√≥pia do valor passado como argumento. Esse valor √© dobrado em seguida, mas n√£o reflete na vari√°vel da fun√ß√£o main, pois ela est√° alocada em outro local.\n\n\n\n\n\nflowchart LR\n subgraph s1[\" \"]\n        X[\"üì¶ &lt;b&gt;meta&lt;/b&gt;&lt;br&gt;Endere√ßo: &lt;code&gt;0xe8&lt;/code&gt;&lt;br&gt;Conte√∫do: &lt;b&gt;7.5&lt;/b&gt;\"]\n        Y[\"üì¶ &lt;b&gt;meta&lt;/b&gt;&lt;br&gt;Endere√ßo: &lt;code&gt;0xc0&lt;/code&gt;&lt;br&gt;Conte√∫do: &lt;b&gt;7.5&lt;/b&gt;\"]\n  end\n\n subgraph s2[\" \"]\n        A[\"üì¶ &lt;b&gt;meta&lt;/b&gt;&lt;br&gt;Endere√ßo: &lt;code&gt;0xe8&lt;/code&gt;&lt;br&gt;Conte√∫do: &lt;b&gt;7.5&lt;/b&gt;\"]\n        B[\"üì¶ &lt;b&gt;meta&lt;/b&gt;&lt;br&gt;Endere√ßo: &lt;code&gt;0xc0&lt;/code&gt;&lt;br&gt;Conte√∫do: &lt;b&gt;15&lt;/b&gt;\"]\n  end\n\n    s1 --dobrar_meta--&gt; s2\n    \n     X:::var\n     Y:::var\n     A:::var\n     B:::var\n    classDef var fill:#A8E6CF,stroke:#2E7D32,color:#000,stroke-width:1px\n    style s1 fill:transparent\n    style s2 fill:transparent\n\n\n\n\n\n\n\n\n\n\n\nE se, ao inv√©s de passarmos o conte√∫do armazenado, a gente passar o endere√ßo ?\n\n\n\nShell, isso √© conhecido como passagem por refer√™ncia. Na verdade, ainda ser√° feita uma c√≥pia do valor passado, mas como esse valor copiado √© um endere√ßo (o ponteiro), esse artif√≠cio ser√° suficiente para manipularmos os dados originais.\n#include &lt;stdio.h&gt;\n\nvoid dobrar_meta (double *meta){ \n    *meta = 2*(*meta); // Desreferencia√ß√£o \n}\n\nint main (){\n    double meta = 7.5;\n    \n    printf(\"meta: %.2f\\n\", meta);\n    dobrar_meta(&meta); // Passando o endere√ßo\n    printf(\"meta: %.2f\\n\", meta);\n\n    return 0;\n}\nSa√≠da:\nmeta: 7.50\nmeta: 15.00\nüéâ Agora sim! A fun√ß√£o modificou a vari√°vel original, pois passamos a refer√™ncia.\n\n\n\n\nNossa! que m√°gica foi essa?\n\n\n\nüßÆ Mem√≥ria ilustrada\n\n\n\nVari√°vel\nEndere√ßo\nValor\n\n\n\n\nmain meta\n0xe8\n7.5\n\n\nlocal meta\n0xc0\n0xe8\n\n\n\nDentro da fun√ß√£o, quando fazemos *meta, o C vai na linha de endere√ßo com o valor de meta (0xe8). Neste local, ele efetua a opera√ß√£o de dobrar.\n\n\n\nVari√°vel\nEndere√ßo\nValor\n\n\n\n\nmain meta\n0xe8\n15\n\n\nlocal meta\n0xc0\n0xe8\n\n\n\nAo finalizar, a meta da fun√ß√£o main sofreu a altera√ß√£o.\n\n\n\n\n\nflowchart LR\n subgraph s1[\" \"]\n        X[\"üì¶ &lt;b&gt;meta&lt;/b&gt;&lt;br&gt;Endere√ßo: &lt;code&gt;0xe8&lt;/code&gt;&lt;br&gt;Conte√∫do: &lt;b&gt;7.5&lt;/b&gt;\"]\n        Y[\"üéØ &lt;b&gt;meta&lt;/b&gt;&lt;br&gt;Endere√ßo: &lt;code&gt;0xc0&lt;/code&gt;&lt;br&gt;Conte√∫do: &lt;b&gt;0xe8&lt;/b&gt;\"]\n  end\n subgraph s2[\" \"]\n        A[\"üì¶ &lt;b&gt;meta&lt;/b&gt;&lt;br&gt;Endere√ßo: &lt;code&gt;0xe8&lt;/code&gt;&lt;br&gt;Conte√∫do: &lt;b&gt;15&lt;/b&gt;\"]\n        B[\"üéØ &lt;b&gt;meta&lt;/b&gt;&lt;br&gt;Endere√ßo: &lt;code&gt;0xc0&lt;/code&gt;&lt;br&gt;Conte√∫do: &lt;b&gt;0xe8&lt;/b&gt;\"]\n  end\n    s1 -- dobrar_meta --&gt; s2\n\n     X:::var\n     Y:::ptr\n     A:::var\n     B:::ptr\n    classDef var fill:#A8E6CF,stroke:#2E7D32,color:#000,stroke-width:1px\n    classDef ptr fill:#FFD3B6,stroke:#E65100,color:#000,stroke-width:1px;\n    style s1 fill:transparent\n    style s2 fill:transparent\n\n\n\n\n\n\n\n\n\n\n\n\nNotaüéØ Desafio de C√≥digo\n\n\n\nImplemente uma fun√ß√£o swap que troque os valores de duas vari√°veis. Teste na main com:\nint x = 10, y = 20;\nswap(&x, &y);\nprintf(\"x = %d, y = %d\\n\", x, y);\nSa√≠da esperada: x = 20, y = 10\n\n\n\n\n\n\n\n\nDicaSolu√ß√£o (clique para ver)\n\n\n\n\n\n#include &lt;stdio.h&gt; \n\nvoid swap(int *a, int *b){\n    int aux = *a;\n    a* = *b;\n    b* = aux;\n}\n\nint main(){\n    int x = 10, y = 20;\n    swap(&x, &y);\n    printf(\"x = %d, y = %d\\n\", x, y);\n\n    return 0;\n}\n\n\n\nüéñÔ∏è +20 XP: Voc√™ aplicou a passagem por refer√™ncia\n\n\n\n\n\n\nCuidadoConquista Desbloqueada\n\n\n\n Manipulador de Ponteiros\n\n\n\n\n\n\n\n\nImportanteüèÜ Checkpoint\n\n\n\nVoc√™ aprendeu:\n‚úÖ A declarar e desreferenciar ponteiros\n‚úÖ A modificar valores via ponteiros\n‚úÖ A passar vari√°veis por refer√™ncia\nRecompensas:\nüèÖ +35 XP\nüí•T√≠tulo: Manipulador de Ponteiros\n\n\n\n\n\n\nIhuuu! conseguimos passar com √™xito por todos os desafios da ilha. Precisamos resgatar a Hashy no Deserto dos Callbacks.\n\n\n\n\n\n\n\n\n\n\nCuidadoüèÅ Fase Conclu√≠da!\n\n\n\nA palavra-chave para desbloquear a pr√≥xima fase √©:\nCHAVE: callback"
  },
  {
    "objectID": "disciplinas/aed2/gaming/unidade2/fundamentos.html",
    "href": "disciplinas/aed2/gaming/unidade2/fundamentos.html",
    "title": "Fundamentos e Ferramentas Gen√©ricas",
    "section": "",
    "text": "Nesta unidade do curso, iremos estudar as estruturas gen√©ricas. Imagine poder criar uma lista ou uma √°rvore que funciona com qualquer tipo de dado, sem precisar mudar uma √∫nica linha do c√≥digo principal. As estruturas gen√©ricas permitem criar c√≥digos flex√≠veis usando conceitos como listas gen√©ricas, o uso de callbacks para opera√ß√µes personalizadas, e a constru√ß√£o de √°rvores de busca gen√©ricas.\nAntes de tudo, precisamos preparar o terreno para que n√£o nenhuma ponta solta. Iniciaremos com um pequena revis√£o sobre ponteiros. Em seguida, introduzir os callbacks, seguido por gerenciamento de mem√≥ria."
  },
  {
    "objectID": "disciplinas/aed2/gaming/unidade2/fundamentos.html#sec-mapa",
    "href": "disciplinas/aed2/gaming/unidade2/fundamentos.html#sec-mapa",
    "title": "Fundamentos e Ferramentas Gen√©ricas",
    "section": "üó∫Ô∏è Mapa da Jornada",
    "text": "üó∫Ô∏è Mapa da Jornada\n\n\n\n\n\n\n\n\nDigite a palavra-chave para desbloquear uma fase:\n\n  \n\n\n\n\n\nAo completar desafios ou uma fase, voc√™ encontrar√° a palavra-chave para desbloquear a pr√≥xima.\nFique atento √†s nossas dicas!"
  }
]