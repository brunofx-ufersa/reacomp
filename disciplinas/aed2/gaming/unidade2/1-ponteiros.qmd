---
title: "ğŸï¸ Ilha dos Ponteiros"
lang: pt
toc-title: ConteÃºdo
toc: false
format:
  html:
    css: [../styles/gamify.css, ../styles/turtlemap.css]
---

SaudaÃ§Ãµes!

<i class="fa-solid fa-island-tropical"></i>
Infelizmente, naufragamos na traiÃ§oeira Ilha dos Ponteiros. Este lugar Ã© uma prisÃ£o natural, cheia de referÃªncias complexas e caminhos que se perdem se nÃ£o forem gerenciados corretamente.

Juntamente com Shell, usaremos nossas habilidades para escapar.
 

## DeclaraÃ§Ã£o e DesreferenciaÃ§Ã£o {#sec-dec}

Quando declaramos uma variÃ¡vel e atribuÃ­mos um valor, esse valor Ã© armazenado em um endereÃ§o de memÃ³ria. Quando escrevemos `int x = 10;`, ocorrem dois passos conceituais:

- **DeclaraÃ§Ã£o**: o programa reserva um espaÃ§o na memÃ³ria para armazenar um inteiro.
- **AtribuiÃ§Ã£o**: o valor `10` Ã© gravado nesse espaÃ§o de memÃ³ria, que possui um endereÃ§o.

A variÃ¡vel `x` Ã© apenas um rÃ³tulo usado pelo programador.

| VariÃ¡vel | EndereÃ§o | ConteÃºdo |
|--------|----------|-------|
|   `x`    |   0x75   |  10   |

Um **ponteiro** tambÃ©m Ã© uma variÃ¡vel, mas sempre armazena o **endereÃ§o de memÃ³ria** de outra variÃ¡vel. Essa habilidade Ã© essencial para criar estruturas de dados dinÃ¢micas.

O princÃ­pio bÃ¡sico Ã© a **compatibilidade de tipo**, ou seja, um ponteiro deve ser do mesmo tipo do dado que ele aponta.

```{.c}
double meta = 7.5;
double *meta_ptr = &meta; // O operador & retorna o endereÃ§o na memÃ³ria
printf("*meta_ptr: %.2f\n", *meta_ptr); // *meta_ptr: 7.50
```

ğŸ’¡ Na linha 2, `meta_ptr` guarda o endereÃ§o da variÃ¡vel `meta`. Na linha 3, o operador `*` serve para desreferenciar, isto Ã©, acessar o valor no endereÃ§o armazenado.

ğŸ§® MemÃ³ria ilustrada

| VariÃ¡vel	| EndereÃ§o	| ConteÃºdo | 
|------|----------|-------|
| `meta`	| [0x55]{.mark} | 7.5 |
| `meta_ptr`	| 0x58 |	[0x55]{.mark} |

Estamos usando endereÃ§os fictÃ­cios. Note que `meta_ptr` guarda o endereÃ§o de `meta`. Ao usar `*meta_ptr` na impressÃ£o, o C acessa o valor armazenado nesse endereÃ§o (7.5).


::: {.callout-tip icon="false" title="âš¡ Dica do Mentor"}

O `*` tem dupla funÃ§Ã£o:

- Declarar um ponteiro (`double *p`)
- Desreferenciar um ponteiro (`*p`)

:::

<div class="chat-container">
<div class="chat-line shell">
  <img src="../img/avatars/shell_avatar.png" class="chat-avatar" alt="ShellSort">
  <div class="chat-bubble">Podemos ir um pouco devagar aqui, pois Ã© crucial entender como funciona esse mecanismo. Para isso, eu criei a seguinte ilustraÃ§Ã£o.</div>
</div>
</div>


```{mermaid}
flowchart RL
    %% NÃ³s de variÃ¡veis e ponteiros
    X["ğŸ“¦ <b>x</b><br/>EndereÃ§o: <code>0x100</code><br/>ConteÃºdo: <b>42</b>"]
    Y["ğŸ“¦ <b>y</b><br/>EndereÃ§o: <code>0x200</code><br/>ConteÃºdo: <b>137</b>"]
    P["ğŸ¯ <b>p</b><br/>EndereÃ§o: <code>0x300</code><br/>ConteÃºdo: <code>0x100</code>"]
    PP["ğŸ¯ <b>pp</b><br/>EndereÃ§o: <code>0x400</code><br/>ConteÃºdo: <code>0x300</code>"]

    %% ConexÃµes
    PP -->|"aponta para"| P
    P -->|"aponta para"| X
    P ~~~ Y
    Y ~~~ X

    %% Estilos de formataÃ§Ã£o
    classDef var fill:#A8E6CF,stroke:#2E7D32,color:#000,stroke-width:1px;
    classDef ptr fill:#FFD3B6,stroke:#E65100,color:#000,stroke-width:1px;
    class X,Y var
    class P,PP ptr
```

As variÃ¡veis `x` e `y` carregam dados que estÃ£o armazenados nos endereÃ§os `0x100` e `0x200`, respectivamente. A variÃ¡vel `p` Ã© um ponteiro cujo conteÃºdo Ã© `0x100`, portanto aponta para `x`. A variÃ¡vel `pp` Ã© outro ponteiro, mas com conteÃºdo `0x300`, ou seja, aponta para o local com endereÃ§o `0x300`, que seria `p`. Isso mesmo um ponteiro de ponteiro. O cÃ³digo que representa esse diagrama poder ser o seguinte.

```{.c code-line-numbers="false"}
int x = 42;
int y = 137;
int *p = &x;
int **pp = &p;
```

:::{.chat-container}
:::{.chat-line .shell}
:::{.chat-avatar}
  ![](../img/avatars/shell_avatar.png)
::: 
:::{.chat-bubble}
Resumindo

- x â†’ contÃ©m 42 e estÃ¡ no endereÃ§o `0x100`;
- y â†’ contÃ©m 137 e estÃ¡ no endereÃ§o `0x200`;
- p â†’ contÃ©m `0x100` (o endereÃ§o de x);
- pp â†’ contÃ©m `0x300` (o endereÃ§o de p).
:::
:::
:::




Podemos declarar ponteiros de vÃ¡rias formas:

```{.c code-line-numbers="false"}
double *meta_ptr = &meta;
double* meta_ptr = &meta;
double * meta_ptr = &meta;
```

No entanto, a primeira Ã© mais recomendada: `tipo *ponteiro = &variavel`.

âœ… +5 XP : VocÃª agora entende a sintaxe dos ponteiros!


## Modificando Valores Indiretamente {#sec-mod}

AlÃ©m de ler, vocÃª tambÃ©m pode modificar valores indiretamente usando ponteiros:

```{.c code-line-numbers="false"}
double meta = 7.5;
double *meta_ptr = &meta; 

*meta_ptr = 10;
printf("meta: %.2f\n", meta); // meta: 10.00
```

<div class="chat-container">
<div class="chat-line shell">
  <img src="../img/avatars/shell_avatar.png" class="chat-avatar" alt="ShellSort">
  <div class="chat-bubble">Mudamos o valor de `meta` sem acessÃ¡-la diretamente. Isso Ã© o poder dos ponteiros!</div>
</div>
</div>

::: {.callout-note icon="false" title="ğŸ¯ Desafio de CÃ³digo"}

- Crie um ponteiro `int *p` que aponte para uma variÃ¡vel `x = 5`.
- Use `*p` para alterar `x` para `42`.
- Depois, exiba o valor e o endereÃ§o de `x` no console.
:::


::: {.callout-tip title="SoluÃ§Ã£o (clique para ver)" collapse="true"}
```{.c}
#include <stdio.h> 

int main(){
    int x = 5;
    int *p = &x;
    *p = 42;

    printf("x: %d\n", x);
    printf("&x: %p\n", &x);

    return 0;
}
```
:::

::: {.callout-note icon="false" title="ğŸ¯ Desafio de CÃ³digo"}

- Passo 1: Declare um ponteiro `ponteiro_chave` que aponte para a `chave_secreta`.
- Passo 2: Mude o valor da `chave_secreta` para 99 usando o ponteiro.
- Passo 3: Imprima o valor da chave secreta.
    
```{.c}
#include <stdio.h>

int main() {
    int chave_secreta = 10;
    // SEU CÃ“DIGO

    return 0;
}
```
:::

::: {.callout-tip title="SoluÃ§Ã£o (clique para ver)" collapse="true"}
```{.c}
#include <stdio.h> 

int main() {
    int chave_secreta = 10;
    int *ponteiro_chave = &chave_secreta;
    *ponteiro_chave = 99;

    printf("chave_secreta: %d\n", chave_secreta);
    return 0;
}
```
:::

ğŸ… +10 XP : VocÃª dominou a manipulaÃ§Ã£o indireta de valores!

## Ponteiros como ParÃ¢metros {#sec-par}

Acredito que estamos perto de deixar esta ilha. Por enquanto, a situaÃ§Ã£o estÃ¡ calma, mas nÃ£o podemos subestimar este local. Parece que encontramos algo que exige a nossa atenÃ§Ã£o imetata.

Em C, os parÃ¢metros sÃ£o passados por valor. Portanto, a funÃ§Ã£o recebe uma cÃ³pia do argumento.

```{.c code-line-numbers="false"}
void dobrar_meta (double meta){ 
    meta = 2*meta; 
}
```

Na `main`:

```{.c code-line-numbers="false"}
double meta = 7.5;
printf("meta: %.2f\n", meta);
dobrar_meta(meta);
printf("meta: %.2f\n", meta);
```


SaÃ­da:

```{.console code-line-numbers="false"}
meta: 7.50
meta: 7.50
```

Nada mudou, pois a funÃ§Ã£o alterou apenas a cÃ³pia local.

<div class="chat-container">
<div class="chat-line shell">
  <img src="../img/avatars/shell_avatar.png" class="chat-avatar" alt="ShellSort">
  <div class="chat-bubble">A variÃ¡vel `meta` na funÃ§Ã£o `main` Ã© global, jÃ¡ na funÃ§Ã£o `dobrar_meta` Ã© local. Significa que quando esta funÃ§Ã£o termina, as variÃ¡veis sÃ£o descartadas.</div>
</div>
</div>


ğŸ’¡ Vamos imprimir os endereÃ§os

```{.c code-line-numbers="false"}
void dobrar_meta (double meta){ 
    printf("local &meta: %x\n", &meta);
    meta = 2*meta; 
}
```

Na `main`:

```{.c code-line-numbers="false"}
double meta = 7.5;
printf("main &meta: %x\n", &meta);
dobrar_meta(meta);
```

SaÃ­da:

```{.console code-line-numbers="false"}
main &meta: 0xe8
local &meta: 0xc0
```

ğŸ§® MemÃ³ria ilustrada

| VariÃ¡vel	| EndereÃ§o	| ConteÃºdo |
| ----------|-----------|-------|
| main `meta` | 0xe8	| 7.5 |
| local `meta` | 0xc0	| 7.5 |

<div class="chat-container">
<div class="chat-line shell">
  <img src="../img/avatars/shell_avatar.png" class="chat-avatar" alt="ShellSort">
  <div class="chat-bubble">Como eu suspeitava, os endereÃ§os sÃ£o diferentes. Logo, nÃ£o sÃ£o as mesmas variÃ¡veis que estamos manipulando.</div>
</div>
</div>

A variÃ¡vel interna em `dobrar_meta` Ã© criada em outra regiÃ£o de memÃ³ria e recebe uma cÃ³pia do valor passado como argumento. Esse valor Ã© dobrado em seguida, mas nÃ£o reflete na variÃ¡vel da funÃ§Ã£o `main`, pois ela estÃ¡ alocada em outro local.

```{mermaid}
flowchart LR
 subgraph s1[" "]
        X["ğŸ“¦ <b>meta</b><br>EndereÃ§o: <code>0xe8</code><br>ConteÃºdo: <b>7.5</b>"]
        Y["ğŸ“¦ <b>meta</b><br>EndereÃ§o: <code>0xc0</code><br>ConteÃºdo: <b>7.5</b>"]
  end

 subgraph s2[" "]
        A["ğŸ“¦ <b>meta</b><br>EndereÃ§o: <code>0xe8</code><br>ConteÃºdo: <b>7.5</b>"]
        B["ğŸ“¦ <b>meta</b><br>EndereÃ§o: <code>0xc0</code><br>ConteÃºdo: <b>15</b>"]
  end

    s1 --dobrar_meta--> s2
    
     X:::var
     Y:::var
     A:::var
     B:::var
    classDef var fill:#A8E6CF,stroke:#2E7D32,color:#000,stroke-width:1px
    style s1 fill:transparent
    style s2 fill:transparent

```

<div class="chat-container">
<div class="chat-line shell">
  <img src="../img/avatars/shell_avatar.png" class="chat-avatar" alt="ShellSort">
  <div class="chat-bubble">E se, ao invÃ©s de passarmos o conteÃºdo armazenado, a gente passar o endereÃ§o ?</div>
</div>
</div>

Shell, isso Ã© conhecido como passagem por referÃªncia. Na verdade, ainda serÃ¡ feita uma cÃ³pia do valor passado, mas como esse valor copiado Ã© um endereÃ§o (o ponteiro), esse artifÃ­cio serÃ¡ suficiente para manipularmos os dados originais. 

```{.c}
#include <stdio.h>

void dobrar_meta (double *meta){ 
    *meta = 2*(*meta); // DesreferenciaÃ§Ã£o 
}

int main (){
    double meta = 7.5;
    
    printf("meta: %.2f\n", meta);
    dobrar_meta(&meta); // Passando o endereÃ§o
    printf("meta: %.2f\n", meta);

    return 0;
}
```

SaÃ­da:

```{.console code-line-numbers="false"}
meta: 7.50
meta: 15.00
```

ğŸ‰ Agora sim!
A funÃ§Ã£o modificou a variÃ¡vel original, pois passamos a referÃªncia.

<div class="chat-container">
<div class="chat-line shell">
  <img src="../img/avatars/shell_avatar.png" class="chat-avatar" alt="ShellSort">
  <div class="chat-bubble">Nossa! que mÃ¡gica foi essa?</div>
</div>
</div>

ğŸ§® MemÃ³ria ilustrada

| VariÃ¡vel	| EndereÃ§o	| Valor |
| ----------|-----------|-------|
| main `meta` | [0xe8]{.mark}	| 7.5 |
| local `meta` | 0xc0	| [0xe8]{.mark} |

Dentro da funÃ§Ã£o, quando fazemos `*meta`, o C vai na linha de endereÃ§o com o valor de `meta` (0xe8). Neste local, ele efetua a operaÃ§Ã£o de dobrar.

| VariÃ¡vel	| EndereÃ§o	| Valor |
| ----------|-----------|-------|
| main `meta` | [0xe8]{.mark}	| 15 |
| local `meta` | 0xc0	| [0xe8]{.mark} |

Ao finalizar, a `meta` da funÃ§Ã£o `main` sofreu a alteraÃ§Ã£o.

```{mermaid}
flowchart LR
 subgraph s1[" "]
        X["ğŸ“¦ <b>meta</b><br>EndereÃ§o: <code>0xe8</code><br>ConteÃºdo: <b>7.5</b>"]
        Y["ğŸ¯ <b>meta</b><br>EndereÃ§o: <code>0xc0</code><br>ConteÃºdo: <b>0xe8</b>"]
  end
 subgraph s2[" "]
        A["ğŸ“¦ <b>meta</b><br>EndereÃ§o: <code>0xe8</code><br>ConteÃºdo: <b>15</b>"]
        B["ğŸ¯ <b>meta</b><br>EndereÃ§o: <code>0xc0</code><br>ConteÃºdo: <b>0xe8</b>"]
  end
    s1 -- dobrar_meta --> s2

     X:::var
     Y:::ptr
     A:::var
     B:::ptr
    classDef var fill:#A8E6CF,stroke:#2E7D32,color:#000,stroke-width:1px
    classDef ptr fill:#FFD3B6,stroke:#E65100,color:#000,stroke-width:1px;
    style s1 fill:transparent
    style s2 fill:transparent
```


::: {.callout-note icon="false" title="ğŸ¯ Desafio de CÃ³digo"}
Implemente uma funÃ§Ã£o `swap` que troque os valores de duas variÃ¡veis.
Teste na `main` com:

```{.c code-line-numbers="false"}
int x = 10, y = 20;
swap(&x, &y);
printf("x = %d, y = %d\n", x, y);
```

SaÃ­da esperada: `x = 20, y = 10`
:::


::: {.callout-tip title="SoluÃ§Ã£o (clique para ver)" collapse="true"}
```{.c}
#include <stdio.h> 

void swap(int *a, int *b){
    int aux = *a;
    a* = *b;
    b* = aux;
}

int main(){
    int x = 10, y = 20;
    swap(&x, &y);
    printf("x = %d, y = %d\n", x, y);

    return 0;
}
```
:::

ğŸ–ï¸ +20 XP: VocÃª aplicou a passagem por referÃªncia 

::: {.callout-caution icon="false" title="Conquista Desbloqueada"}
<i class="bi bi-arrow-down-right-square"></i> Manipulador de Ponteiros
:::

::: {.callout-important icon="false" title="ğŸ† Checkpoint"}

VocÃª aprendeu:

âœ… A declarar e desreferenciar ponteiros

âœ… A modificar valores via ponteiros

âœ… A passar variÃ¡veis por referÃªncia

Recompensas:

ğŸ… +35 XP

ğŸ’¥TÃ­tulo: Manipulador de Ponteiros
:::

<div class="chat-container">
<div class="chat-line shell">
  <img src="../img/avatars/shell_avatar.png" class="chat-avatar" alt="ShellSort">
  <div class="chat-bubble">Ihuuu! conseguimos passar com Ãªxito por todos os desafios da ilha. Precisamos resgatar a Hashy no Deserto dos Callbacks.</div>
</div>
</div>

---

::: {.callout-caution icon="false"}
### ğŸ Fase ConcluÃ­da!
 A palavra-chave para desbloquear a prÃ³xima fase Ã©:  
 **CHAVE: callback**
:::


<!-- <a href='fundamentos.html#sec-mapa' ><button class="button"><i class="bi bi-globe-americas"></i> Voltar</button></a> -->



```{=html}
 <div class="progress-bar" id="progressBar"></div>

<script>
window.addEventListener("scroll", function() {
  const scrollTop = window.scrollY;
  const docHeight = document.body.scrollHeight - window.innerHeight;
  const scrollPercent = (scrollTop / docHeight) * 100;
  document.getElementById("progressBar").style.width = scrollPercent + "%";
});
</script>
```
