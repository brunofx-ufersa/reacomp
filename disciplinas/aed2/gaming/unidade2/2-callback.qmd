---
title: "üèúÔ∏è Deserto dos Callbacks"
lang: pt
toc-title: Conte√∫do
toc: false
format:
  html:
    css: [../styles/gamify.css, ../styles/turtlemap.css]
---

Voc√™ chegou ao Deserto dos Callbacks, uma terra √°rida onde apenas os programadores mais habilidosos conseguem sobreviver.
Dizem que quem domina os ponteiros de fun√ß√£o e os callbacks pode invocar comportamentos gen√©ricos e controlar o fluxo da execu√ß√£o com maestria.

Prepare-se, nossa miss√£o come√ßa agora.


## O Mapa dos Endere√ßos {#sec-fun}

Um ponteiro tamb√©m pode armazenar o endere√ßo de uma fun√ß√£o. O racioc√≠nio √© o mesmo, mas a sintaxe para a declara√ß√£o √© mais espec√≠fica, pois ela precisa descrever a assinatura completa da fun√ß√£o: seu tipo de retorno e seus par√¢metros.

A sintaxe de declara√ß√£o pode parecer confusa no in√≠cio, mas pode ser lida assim:

```{.console code-line-numbers="false"}
tipo_de_retorno (*nome_do_ponteiro)(tipos_de_parametros);
```

Vamos tomar a fun√ß√£o `meta` como exemplo:

```{.c code-line-numbers="false"}
double meta (double n1, double n2){
  return (n1 + n2)/2;
}

// Declara√ß√£o de um ponteiro de fun√ß√£o:
double (*meta_ptr)(double, double) = meta;
```

A sintaxe de declara√ß√£o deve ser lida da seguinte forma:

- `double`: √© o tipo de retorno;

- `(*meta_ptr)`: indica que `meta_ptr` √© um ponteiro para fun√ß√£o. Os par√™nteses s√£o obrigat√≥rios para diferenci√°-lo de uma fun√ß√£o que retorna um ponteiro;

- `(double, double)`: s√£o os tipos dos par√¢metros da fun√ß√£o apontada.

::: {.callout-note }
Diferentemente das vari√°veis, ao atribuir o endere√ßo de uma fun√ß√£o a um ponteiro de fun√ß√£o, n√£o √© necess√°rio usar o operador & (o nome da fun√ß√£o sozinho j√° representa seu endere√ßo).
:::

Note que a fun√ß√£o `meta` obedece a **assinatura** (ou contrato) estabelecido pelo ponteiro de fun√ß√£o `meta_ptr`, ou seja, possui o mesmo **tipo de retorno** e os mesmos **tipos de par√¢metros de entrada** (`double, double`) Portanto, devemos manter a **compatibilidade** de tipos.


## Introdu√ß√£o aos Callbacks {#sec-cal}

O verdadeiro poder dos ponteiros de fun√ß√£o aparece quando uma fun√ß√£o √© passada como argumento para outra.
Nesse caso, a fun√ß√£o que recebe outra fun√ß√£o √© chamada de **fun√ß√£o de ordem superior**, enquanto a fun√ß√£o fornecida como argumento √© chamada de **_callback_**.

Essa t√©cnica permite que um trecho de c√≥digo delegue parte de seu comportamento a outro, tornando o programa mais flex√≠vel, modular e param√©trico.

Abaixo, um exemplo de uma calculadora de inteiros, onde `calcular` √© uma fun√ß√£o de ordem superior, pois recebe outra fun√ß√£o como par√¢metro. As fun√ß√µes `soma`, `subtracao`, `produto` e `divisao` s√£o _callbacks_, pois s√£o passadas para `calcular` para que ela decida qual comportamento executar.

```{.c filename=calculadora_param.c}
#include <stdio.h>

// Fun√ß√µes concretas (implementam comportamentos espec√≠ficos)
int soma (int a, int b)     { return a + b; }
int subtracao (int a, int b){ return a - b; }
int produto (int a, int b)  { return a * b; }
int divisao (int a, int b)  { return a / b; }

// Fun√ß√£o coordenadora (de ordem superior)
// Recebe duas vari√°veis e uma fun√ß√£o como par√¢metro
int calcular(int a, int b, int (*operacao)(int, int)) {
  return operacao(a, b);
}

int main(){

  int n1 = 10;
  int n2 = 2;
  
  printf("Soma:      %d\n", calcular(n1, n2, soma));
  printf("Subtra√ß√£o: %d\n", calcular(n1, n2, subtracao));
  printf("Produto:   %d\n", calcular(n1, n2, produto));
  printf("Divis√£o:   %d\n", calcular(n1, n2, divisao));  
  
  return 0;
}
```

A fun√ß√£o `calcular` n√£o sabe qual opera√ß√£o ser√° executada, ela apenas invoca o comportamento recebido como par√¢metro. Isso √© o que chamamos de **abstra√ß√£o de comportamento**.

A sa√≠da desse programa ser√°

```{.console code-line-numbers="false"}
  Soma:      12
  Subtra√ß√£o: 8
  Produto:   20
  Divis√£o:   5 
```
Ao **passar a fun√ß√£o como par√¢metro**, tornamos o c√≥digo de C extremamente **poderoso e reutiliz√°vel**. A fun√ß√£o `calcular` n√£o se importa como o c√°lculo √© feito, apenas que a fun√ß√£o fornecida (o _callback_) respeite o contrato de tipos (`int` para retorno, e `int`, `int` para par√¢metros).

Podemos ir al√©m nessa reutiliza√ß√£o? Sim, mas atingimos o limite do **{{< glossary polimorfismo >}}** simples em C. Imagine que voc√™ queira adicionar uma opera√ß√£o com n√∫meros de ponto flutuante:


```{.c code-line-numbers="false"}
double somad (double a, double b) { return a + b; }
```

O problema √© que n√£o podemos passar `somad` para a fun√ß√£o `calcular` e nem a usar para operar com `double`, pois o _callback_ `int (*operacao)(int, int)` e os par√¢metros fixos em `calcular(int a, int b, ...)` tornam essa fun√ß√£o totalmente incompat√≠vel com o tipo `double`.

Para resolver esse problema e criar uma √∫nica fun√ß√£o verdadeiramente gen√©rica que aceite qualquer tipo de dado, precisamos abandonar os tipos concretos (`int`, `double`) e generalizar usando o ponteiro sem tipo (`void*`).


Antes de darmos o salto para o c√≥digo verdadeiramente gen√©rico usando `void*`, vamos usar o `typedef` para melhorar a legibilidade de nosso c√≥digo.

A sintaxe de um ponteiro de fun√ß√£o (`int (*operacao)(int, int)`) √© complexa e pode dificultar a leitura do c√≥digo. O `typedef` permite que voc√™ crie um apelido para essa assinatura complexa, tratando-a como um novo tipo de dado simples.

Ao definir o tipo do _callback_, tornamos a fun√ß√£o `calcular` muito mais limpa:


```c
// Definimos 'Operacao' como o tipo para qualquer fun√ß√£o
// que retorna int e aceita dois int como par√¢metros.
typedef int (*Operacao)(int, int);

// A fun√ß√£o 'calcular' agora usa o tipo 'Operacao', 
// simplificando sua assinatura.
int calcular(int a, int b, Operacao operacao); 
```
O c√≥digo final ficaria assim:

```{.c filename=calculadora_typedef.c}
#include <stdio.h>

// Defini√ß√£o do TIPO de ponteiro de fun√ß√£o
typedef int (*Operacao)(int, int);

// Fun√ß√µes concretas (omitidas para brevidade)
int soma (int a, int b) { return a + b; }
// ...

// A Fun√ß√£o Coordenadora agora √© mais leg√≠vel
int calcular(int a, int b, Operacao operacao) {
  return operacao(a, b);
}

int main(){

  int n1 = 10;
  int n2 = 2;
  
  printf("Soma: %d\n", calcular(n1, n2, soma));
  
  return 0;
}
```

## Ponteiro gen√©rico {#sec-gen}

Agora que compreendemos o funcionamento dos ponteiros e a passagem por refer√™ncia, podemos dar um passo al√©m, como representar qualquer tipo de dado usando ponteiros gen√©ricos.

Em C, o tipo `void*` √© conhecido como ponteiro gen√©rico (_generic pointer_). Ele √© um tipo especial de ponteiro que pode armazenar o endere√ßo de qualquer tipo de dado, por exemplo `int`, `double`, `char`, `struct` etc.

```{.c code-line-numbers="false"}
int idade = 20;
double meta = 8.5;
char letra = 'A';

void *ptr;

ptr = &idade;
printf("idade: %d\n", *(int*)ptr);

ptr = &meta;
printf("meta: %.2f\n", *(double*)ptr);

ptr = &letra;
printf("letra: %c\n", *(char*)ptr);
```

Repare que, embora `ptr` sempre seja do tipo `void*`, precisamos fazer um _cast_ (convers√£o expl√≠cita) para o tipo correto antes de acessar o valor. Isso ocorre porque o compilador n√£o sabe qual √© o tipo real do dado armazenado e, portanto, n√£o pode fazer aritm√©tica de ponteiros nem desreferencia√ß√£o direta.

Essa caracter√≠stica √© o que permite criar estruturas de dados gen√©ricas em C, como listas, pilhas ou filas capazes de armazenar qualquer tipo. Essas estruturas ir√£o guardar apenas endere√ßos gen√©ricos (`void*`) e n√£o se importar com o tipo concreto do dado. A responsabilidade de interpretar corretamente o tipo ser√° de quem usar a estrutura.

## O papel de `size_t` {#sec-siz}

Ao manipular dados de tipos diferentes, precisamos tamb√©m saber quanto de mem√≥ria reservar ou copiar.
√â a√≠ que entra o tipo `size_t`, definido no cabe√ßalho `<stddef.h>` (ou implicitamente inclu√≠do via `<stdlib.h>` ou `<stdio.h>`).

Como um tipo num√©rico sem sinal (_unsigned_), `size_t` √© usado para representar tamanhos e quantidades de _bytes_. Ele √© o tipo de retorno de fun√ß√µes como `sizeof`, `malloc`, `calloc` e `strlen`.

```{.c}
#include <stdio.h>
#include <stdlib.h>

int main() {
    int x = 10;
    double y = 3.14;

    printf("sizeof(int): %zu bytes\n", sizeof(int));
    printf("sizeof(double): %zu bytes\n", sizeof(double));

    void *ptr = malloc(sizeof(double));
    printf("Alocado %zu bytes em %p\n", sizeof(double), ptr);

    free(ptr);
    return 0;
}
```

Sa√≠da t√≠pica:

```{.console code-line-numbers="false"}
sizeof(int): 4 bytes
sizeof(double): 8 bytes
Alocado 8 bytes em 0x7ffee1
```

A combina√ß√£o de `void*` e `size_t` √© fundamental para criar estruturas gen√©ricas, pois usaremos `void*` para representar o dado, independentemente de tipo e `size_t` para indicar o tamanho desse dado, permitindo c√≥pia, aloca√ß√£o e manipula√ß√£o seguras.

Falta pouco para criarmos nossas estruturas gen√©ricas com comportamentos tamb√©m gen√©ricos. Antes, precisamos entender como generalizar a√ß√µes, ou seja, como permitir que uma estrutura chame fun√ß√µes que mudam conforme o tipo de dado.

E √© aqui que entra o pr√≥ximo conceito fundamental, a abstra√ß√£o de comportamento. Para isso, devemos estudar os ponteiros para fun√ß√£o e _callbacks_.
