---
title: "Gerenciamento da Memória"
lang: pt
toc-title: Conteúdo
toc: false
sidebar: false
format:
  html:
    reference-location: margin
    css: ../styles/academic.css
---
 

Até aqui, vimos como generalizar dados e comportamentos em C usando ponteiros e _callbacks_.
No entanto, toda essa flexibilidade traz a responsabilidade de gerenciar manualmente a memória.

Nesta seção, vamos entender como a linguagem C lida com a alocação dinâmica, isto é, a capacidade de reservar e liberar memória em tempo de execução. Mais importante, veremos como evitar os erros de memória mais comuns que podem comprometer a estabilidade e a segurança de um programa.

## Alocação e liberação dinâmica {#sec-alo}

Quando trabalhamos com _arrays_ ou estruturas em C, geralmente definimos seus tamanhos em tempo de compilação. Eles ficam armazenados em uma área de memória chamada **_stack_**. 

No entanto, há muitos casos em que o tamanho dos dados não é conhecido antecipadamente. Para esses casos, o C fornece funções de alocação dinâmica de memória, que permitem reservar e liberar espaço em tempo de execução. Esses blocos de memória são criados em uma região especial chamada **_heap_**.

Dizemos que a memória _stack_ é estática, enquanto que a _heap_ é dinâmica. Na _stack_, quando a função termina, a variável é destruída. Já na _heap_, o programador decide quando alocar e liberar. 

A alocação dinâmica oferece flexibilidade, mas também exige disciplina. O princípio fundamental é: **quem aloca, deve liberar**.

### Alocação simples 

A função `malloc` (de _memory allocation_) reserva um bloco contíguo de memória de tamanho especificado em _bytes_.

```{.c code-line-numbers="false"}
int *v = malloc(5 * sizeof(int));
```

O argumento é o número total de _bytes_ a serem alocados. No trecho acima, estamos alocando o espaço suficiente para cinco inteiros. O retorno é um ponteiro genérico (`void*`) para o início do bloco. Caso a alocação falhe, `malloc` retorna `NULL`.

::: {.column-margin}
**[Se liga!]{.text-warning}**
Em C, ao contrário de C++, não há necessidade de fazer o _cast_ do ponteiro genérico neste caso. 
:::

Como não temos garantia que a memória foi alocada, precisamos tratar quando `malloc` falha. Isso é geramente feito com um bloco `if`.

```{.c code-line-numbers="false"}
int *v = malloc(5 * sizeof(int));
    
if (v == NULL) {
    fprintf(stderr, "Erro: sem memória suficiente!\n");
    return 1;
}       
```

No trecho acima, poderíamos ter usado `printf` ao invés de `fprintf`. A escolha, por `fprintf` se dá por ser o padrão para erros. Ele permite especificar exatamente para onde a saída deve ir. Ao usarmos `stderr` (de _standard error_), estamos dizendo ao sistema que esta mensagem é um erro e deve ser tratada como tal.

::: {.column-margin}
**[Se liga!]{.text-warning}**
A função `perror` imprime uma mensagem de erro em `stderr` também e é muito usada para depuração.
:::

Quando usamos `printf` a saída é armazenada em _buffer_, portanto a mensagem de erro poderia ficar presa e nunca ser exibida antes do programa abortar. Já quando optamos por `fprintf`, a saída é _unbuffered_, ou seja, é exibida imediatamente no terminal.

Resumindo, use `fprinf` mensagens de erro, diagnóstico e logs críticos e use `printf` para mensagens de sucesso, resultado da aplicação e saída esperada.

O `return 1` informa ao sistema operacional que algo deu errado .

### Alocação e inicialização 

A função `calloc` (de _contiguous allocation_) funciona como `malloc`, mas com duas diferenças:

- Recebe dois parâmetros, número de elementos e tamanho de cada um;
- Inicializa o bloco com zeros.

```{.c code-line-numbers="false"}
int *v = calloc(5, sizeof(int));
```

Assim, todo as posições começam zeradas, o que evita leituras de lixo de memória.

### Redimensionamento de bloco 

A função `realloc` permite ajustar o tamanho de um bloco de memória já alocado.

```{.c code-line-numbers="false"}
int *v = calloc(5, sizeof(int));
int *novo = realloc(v, 10 * sizeof(int));
```

Se houver espaço contíguo suficiente, o bloco é expandido no mesmo local. Caso contrário, um novo bloco é alocado e o conteúdo antigo é copiado automaticamente. Em caso de falha, retorna `NULL` e não desaloca o bloco de memória original. Por isso, é recomendado sempre usar um ponteiro temporário:

```{.c code-line-numbers="false"}
int *v = calloc(5, sizeof(int));
int *temp = realloc(v, 10 * sizeof(int));
if (temp == NULL) {
    fprintf(stderr, "Erro ao realocar memória!\n");
    return 1;
}
v = temp; // Atualiza o ponteiro com segurança
```

### Liberação de memória

A função `free` libera um bloco previamente alocado com `malloc`, `calloc` ou `realloc`.
Ela devolve o espaço ao sistema operacional, mas não zera o ponteiro.

```{.c code-line-numbers="false"}
free(v);
v = NULL; // Boa prática
```

::: {.callout-important}
Após liberar, o ponteiro ainda guarda o endereço antigo, agora inválido. Atribuir `NULL` ajuda a evitar o uso acidental, um erro clássico conhecido como _dangling pointer_.
:::

Este ciclo é a base de toda manipulação segura de memória dinâmica em C:

```{mermaid}
flowchart LR
    A("Alocar") --> B("Usar")
    B --> C("Liberar")  
    C --> D("Invalidar")
    D --> A
```    

- Alocar (`malloc`, `calloc` ou `realloc`)
- Usar (ler e escrever por meio do ponteiro)
- Liberar (`free`)
- Invalidar o ponteiro (`ptr = NULL`)


Com essas funções, temos total controle sobre a vida útil de cada dado em memória. No entanto, esse poder vem acompanhado de riscos. Podemos citar os acessos indevidos, vazamentos e corrupção de memória como erros comuns quando o ciclo de alocação não é seguido corretamente.

Na próxima seção, vamos explorar as funções de manipulação de blocos de memória e entender como operá-las com segurança antes de mergulhar nos erros clássicos de memória.


## Manipulação de blocos de memória {#sec-man}

Quando trabalhamos com alocação dinâmica, frequentemente precisamos copiar dados de uma região de memória para outra. O C oferece um conjunto de funções na biblioteca `<string.h>` para manipular blocos de memória de forma genérica, usando ponteiros do tipo `void *`.

Essas funções operam diretamente em _bytes_, e não conhecem o tipo de dado armazenado. Por isso, exigem atenção com o tamanho dos blocos manipulados (geralmente expresso com `size_t`).

As três funções principais para manipulação de blocos de memória são:

- `memcpy`: copia _bytes_ de uma origem para um destino
- `memmove`: copia _bytes_ com segurança mesmo se houver sobreposição
- `memset`: preenche uma área de memória com um valor constante

### Copiando blocos de memória

A função `memcpy` copia $n$ _bytes_ do bloco apontado por `src` (origem) para o bloco apontado por `dest` (destino).

```{.c code-line-numbers="false"}
void *memcpy(void *dest, const void *src, size_t n);
```

Exemplo prático:

```{.c}
#include <stdio.h>
#include <string.h>

int main() {
    int origem[5] = {1, 2, 3, 4, 5};
    int destino[5];

    memcpy(destino, origem, 5 * sizeof(int));

    for (int i = 0; i < 5; i++)
        printf("%d ", destino[i]);
    
    return 0;
}
```

Saída:

```{.console code-line-numbers="false"}
1 2 3 4 5
```

::: {.callout-important}
A função `memcpy` não deve ser usada quando as regiões de origem e destino se sobrepõem.
O comportamento é indefinido, podendo corromper os dados.
:::

### Cópia segura com sobreposição

A função `memmove` é semelhante a `memcpy`, mas trata corretamente casos de sobreposição. Se o bloco de destino estiver dentro da área de origem (ou vice-versa), ela ajusta a direção da cópia automaticamente.

```{.c code-line-numbers="false"}
void *memmove(void *dest, const void *src, size_t n);
```

Exemplo:

```{.c}
#include <stdio.h>
#include <string.h>

int main() {
    char texto[20] = "ABCDEF";

    // Copiando parte sobreposta
    memmove(texto + 2, texto, 4);
    texto[6] = '\0'; // Caracter de fim de string

    printf("%s\n", texto); // Resultado: "ABABCD"
    return 0;
}
```

Se tivéssemos usado `memcpy` nesse exemplo, o conteúdo de texto poderia ser corrompido, pois as regiões `texto` e `texto + 2` se sobrepõem.

### Inicializando memória

A função `memset` preenche um bloco de memória com um valor constante em _bytes_. Ela é muito usada para inicializar _buffers_ ou zerar estruturas.

```{.c code-line-numbers="false"}
void *memset(void *ptr, int valor, size_t n);
```

Exemplo:

```{.c}
#include <stdio.h>
#include <string.h>

int main() {
    int v[5];
    memset(v, 0, 5 * sizeof(int));

    for (int i = 0; i < 5; i++)
        printf("%d ", v[i]);
    
    return 0;
}
```
::: {.column-margin}
**[Se liga!]{.text-warning}**
O valor passado a `memset` é interpretado como um _byte_, e não como um inteiro completo.
Por exemplo, `memset(v, 1, sizeof(int)*5)` preencherá todos os _bytes_ com `0x01`, não com o inteiro `1`.
:::


Saída:

```{.console code-line-numbers="false"}
0 0 0 0 0
```


::: {.callout-important}
Os seguintes cuidados são recomendados quando estamos programando com uso de memória dinâmica.

- Sempre use `sizeof` para calcular o número correto de _bytes_.
  + Evite expressões mágicas como `memcpy(dest, src, 20)`.
  + Ao invés, use `memcpy(dest, src, n * sizeof(T))`.
- Prefira `memmove` quando houver dúvida sobre sobreposição.
- Zere estruturas antes de usá-las (por exemplo, _buffers_ de _strings_).
- Evite manipular memória de tipos complexos (estruturas com ponteiros internos) com `memcpy` 
  + Isso pode quebrar o encapsulamento e gerar cópias superficiais perigosas.
:::

Com essas funções, temos ferramentas poderosas para manipular diretamente a memória. Isso é um recurso essencial para implementar estruturas genéricas e operações de baixo nível. Entretanto, o uso incorreto dessas funções é uma das principais causas de erros sutis e difíceis de depurar em C.

Na próxima seção, estudaremos exatamente esses erros, os erros clássicos de memória, como _dangling pointers_, _buffer overflow_ e _double free_, e como evitá-los com boas práticas.


## Erros clássicos

Gerenciar memória manualmente é uma das maiores responsabilidades (e riscos) ao programar em C. Ao lidar com ponteiros e alocação dinâmica, pequenos descuidos podem causar comportamentos indefinidos, travamentos ou até falhas de segurança.

Nesta seção, veremos os erros mais comuns, seus sintomas e como evitá-los.

### Ponteiros não inicializados (_wild pointers_)

Um _wild pointer_ é um ponteiro que não foi inicializado antes do uso. Ele contém um valor de endereço aleatório, podendo apontar para qualquer lugar da memória.

```{.c}
#include <stdio.h>

int main() {
    int *p;       // não inicializado!
    *p = 42;      // ❌ comportamento indefinido!
    printf("%d\n", *p);
    return 0;
}
```

::: {.callout-caution}
Esse código pode travar o programa (_segmentation fault_), corromper dados ou até "funcionar", mascarando o erro (o pior cenário).
:::

Como boa prática, sempre inicialize ponteiros:

```{.c code-line-numbers="false"}
int *p = NULL;
```
::: {.column-margin}
**[Se liga!]{.text-warning}**
Um ponteiro deve sempre apontar para algo válido, ou para `NULL`. Isso é chamado de **inicialização defensiva**.
:::

Essa prática evita comportamentos indefinidos quando o ponteiro é usado antes de ser atribuído.
Ela também facilita verificações de segurança:

```{.c code-line-numbers="false"}
if (p != NULL) {
    *p = 42;
}
```

### Ponteiros pendentes (_dangling pointers_)

Um _dangling pointer_ ocorre quando o ponteiro ainda referencia uma região de memória já liberada.

```{.c}
#include <stdlib.h>

int main() {
    int *p = malloc(sizeof(int));
    *p = 10;
    free(p);
    printf("%d\n", *p); // ❌ uso após liberação
    return 0;
}
```

::: {.callout-caution}
O bloco de memória foi liberado, mas o ponteiro ainda "acha" que é válido. Acessar ou modificar essa região causa comportamento indefinido.
:::

Como boa prática, após `free(p)`, defina `p = NULL`; para evitar acessos acidentais.

### Vazamentos de memória (_memory leaks_)

Um _memory leak_ acontece quando um programa perde a referência para uma região de memória alocada, sem chamá-la com `free`.

```{.c}
#include <stdlib.h>

int main() {
    int *p = malloc(100 * sizeof(int));
    p = NULL;  // ❌ perdemos a referência — vazamento!
    return 0;
}
```

::: {.callout-caution}
A memória continua alocada, mas inacessível. Em programas longos, isso pode acumular e exaurir a memória do sistema.
:::

Como boas prática, sempre emparelhe `malloc` e `free`. Pois, cada chamada de alocação dinâmica deve ter uma contrapartida de liberação. Evite fluxos de execução que impeçam o `free` de ser chamado.

```{.c code-line-numbers="false"}
char *p = malloc(100);
if (!p) return;  // ❌ erro de alocação
// ...
free(p);
```

::: {.callout-tip}
Centralize liberações num único ponto de saída, especialmente em funções longas.
:::


### Liberação duplicada (_double free_)

Um _double free_ ocorre quando tentamos liberar o mesmo bloco de memória mais de uma vez.

```{.c}
#include <stdlib.h>

int main() {
    int *p = malloc(sizeof(int));
    free(p);
    free(p); // ❌ ERRO: double free
    return 0;
}
```

::: {.callout-caution}
Isso causa corrupção da estrutura interna do _heap_ e frequentemente resulta em _segmentation fault_.
:::

Como boa prática, após liberar, defina `p = NULL`.

Em programas maiores, é comum que uma função faça alocação de memória e outra a utilize.
Para evitar vazamentos ou liberações incorretas, defina quem é o dono (_owner_) de cada bloco alocado.

Exemplo:

```{.c code-line-numbers="false"}
char* criar_mensagem() {
    char *msg = malloc(50);
    sprintf(msg, "Olá, mundo!");
    return msg;  // a função devolve a posse
}

int main() {
    char *m = criar_mensagem();
    puts(m);
    free(m);     // responsabilidade de quem recebeu
}
```

### Acesso fora dos limites (_buffer overflow_ e _underrun_)

Um _buffer overflow_ ocorre quando se escreve além do final (ou antes do início) de um bloco de memória.


```{.c}
#include <stdio.h>

int main() {
    int v[3] = {1, 2, 3};
    v[3] = 99; // índice inválido — overflow
    printf("%d\n", v[3]); // ❌ comportamento indefinido
    return 0;
}
```

::: {.callout-caution}
Esse tipo de erro é grave: pode corromper variáveis adjacentes, causar travamentos ou vulnerabilidades de segurança.
:::

Como boas prática, sempre verifique limites de vetores. Ao usar `malloc`, garanta que o tamanho esteja correto com `sizeof`.

Podemos resumir os tipos de erros abordados por meio da seguinte tabela.


| Tipo de Erro	| Causa	| Sintoma	| Prevenção|
|---------------|-------|-----------|----------|
| _Wild Pointer_	|Ponteiro não inicializado | _Crash_ aleatório | Inicializar com `NULL` | 
| _Dangling Pointer_ | Uso após `free` | _Segmentation fault_ | `p = NULL` após `free` | 
| _Memory Leak_ | Perda de referência | Aumento de uso de memória | Sempre liberar | 
| _Double Free_ | Liberação repetida | Corrupção do _heap_ | Controle de _ownership_ | 
| _Buffer Overflow_ | Escrita fora dos limites | Corrupção de memória | Verificar limites | 

::: {.column-margin}
**[Se liga!]{.text-warning}**
_Ownership_ se refere ao proprietário do ponteiro. Se duas regiões estão liberando o ponteiro (_double free_), então estão compartilhando a guarda. Evite isso!
:::

Erros de memória estão entre os mais sutis e perigosos em C. Eles não apenas causam falhas, mas podem introduzir vulnerabilidades de segurança sérias. Com boas práticas e ferramentas adequadas, é possível evitá-los e desenvolver sistemas robustos e confiáveis.

## Boas práticas  {#sec-boa}

A seguir, algumas sugestões de boas práticas quando gerenciamos a memória em C.

### Evite operações parciais

Nunca tente liberar apenas parte de uma estrutura alocada. Sempre opere sobre a mesma referência retornada por `malloc`.

```{.c code-line-numbers="false"}
int *v = malloc(10 * sizeof(int));
int *p = v + 5;
free(p); // ❌ comportamento indefinido
free(v); // ✅ correto
```


### Zerar memória após liberação (quando necessário)

Em sistemas que lidam com dados sensíveis (como senhas), vale a pena limpar o conteúdo antes de liberar.

```{.c code-line-numbers="false"}
memset(senha, 0, tamanho);
free(senha);
```

Isso impede que dados fiquem acessíveis em regiões de memória reaproveitadas.

### Macros e wrappers de segurança

Em projetos grandes, é comum encapsular chamadas de alocação/liberação em funções auxiliares.
Isso facilita rastrear erros e aplicar verificações centralizadas.

```{.c code-line-numbers="false"}
void* safe_malloc(size_t n) {
    void *p = malloc(n);
    if (p == NULL) {
        fprintf(stderr, "Erro: malloc falhou\n");
        return 1;
    }
    return p;
}
```
::: {.column-margin}
**[Se liga!]{.text-warning}**
 Com esse padrão, você garante que toda alocação seja verificada.
:::

Gerenciar memória em C é uma arte de equilíbrio entre controle total e responsabilidade absoluta.
Com disciplina e padrões bem definidos, é possível construir sistemas robustos, performáticos e seguros.