---
title: "Callbacks"
lang: pt
toc-title: Conte√∫do
toc: false
sidebar: false
format:
  html:
    reference-location: margin
    css: ../styles/academic.css
---

Nossa jornada pelos ponteiros ainda n√£o acabou. Nesta unidade vamos estudar o uso de ponteiros com fun√ß√µes. Isso mesmo, uma fun√ß√£o tamb√©m possui um endere√ßo de mem√≥ria. Poderemos chamar fun√ß√µes indiretamente e passar fun√ß√µes como param√™tros para outras fun√ß√µes. 


## Ponteiros de Fun√ß√µes {#sec-fun}

Um ponteiro tamb√©m pode armazenar o endere√ßo de uma fun√ß√£o. O racioc√≠nio √© o mesmo de antes, mas a sintaxe para a declara√ß√£o √© mais espec√≠fica, pois ela precisa descrever a **assinatura** completa da fun√ß√£o: seu tipo de retorno e seus par√¢metros.

A sintaxe de declara√ß√£o pode parecer confusa no in√≠cio, mas pode ser lida assim:

`tipo_de_retorno (*nome_do_ponteiro)(tipos_de_parametros);`

Vamos tomar a fun√ß√£o `media` como exemplo. Ela recebe dois valores e retorna a m√©dia aritm√©tica deles.

```{.c code-line-numbers="false"}
double media (double n1, double n2){
  return (n1 + n2)/2;
}

// Declara√ß√£o de um ponteiro de fun√ß√£o:
double (*media_ptr)(double, double) = media;
```

A sintaxe de declara√ß√£o do ponteiro `media_prt` deve ser lida da seguinte forma:

- `double`: √© o tipo de retorno;

- `(*media_ptr)`: indica que `media_ptr` √© um ponteiro para fun√ß√£o. Os par√™nteses s√£o **obrigat√≥rios** para diferenci√°-lo de uma fun√ß√£o que retorna um ponteiro;

- `(double, double)`: s√£o os tipos dos par√¢metros da fun√ß√£o apontada.

::: {.callout-note }
Diferentemente das vari√°veis, ao atribuir o endere√ßo de uma fun√ß√£o a um ponteiro de fun√ß√£o, n√£o √© necess√°rio usar o operador & (o nome da fun√ß√£o sozinho j√° representa seu endere√ßo).
:::

Note que a fun√ß√£o `media` obedece a **assinatura** (ou contrato) estabelecido pelo ponteiro de fun√ß√£o `media_ptr`, ou seja, possui o mesmo **tipo de retorno** e os mesmos **tipos de par√¢metros de entrada** (`double, double`). Portanto, devemos manter a **compatibilidade** de tipos, como fizemos com as vari√°veis na se√ß√£o anterior.


## Introdu√ß√£o aos Callbacks {#sec-cal}

O verdadeiro poder dos ponteiros de fun√ß√£o aparece quando uma fun√ß√£o √© passada como argumento para outra.
Nesse caso, a fun√ß√£o que recebe outra fun√ß√£o √© chamada de **fun√ß√£o de ordem superior**, enquanto a fun√ß√£o fornecida como argumento √© chamada de **_callback_**.

Essa t√©cnica permite que um trecho de c√≥digo delegue parte de seu comportamento a outro, tornando o programa mais flex√≠vel, modular e param√©trico.

Abaixo, um exemplo de uma calculadora de inteiros, onde `calcular` √© uma fun√ß√£o de ordem superior, pois recebe outra fun√ß√£o como par√¢metro. As fun√ß√µes `soma`, `subtracao`, `produto` e `divisao` s√£o _callbacks_, pois s√£o passadas para `calcular`.

```{.c filename=calculadora_param.c}
#include <stdio.h>

// Fun√ß√µes concretas (implementam comportamentos espec√≠ficos)
int soma (int a, int b)     { return a + b; }
int subtracao (int a, int b){ return a - b; }
int produto (int a, int b)  { return a * b; }
int divisao (int a, int b)  { return a / b; }

// Fun√ß√£o coordenadora (de ordem superior)
// Recebe duas vari√°veis e um ponteior de fun√ß√£o como par√¢metros
int calcular(int a, int b, int (*operacao)(int, int)) {
  return operacao(a, b);
}

int main(){

  int n1 = 10;
  int n2 = 2;
  
  printf("Soma:      %d\n", calcular(n1, n2, soma));
  printf("Subtra√ß√£o: %d\n", calcular(n1, n2, subtracao));
  printf("Produto:   %d\n", calcular(n1, n2, produto));
  printf("Divis√£o:   %d\n", calcular(n1, n2, divisao));  
  
  return 0;
}
```

::: {.column-margin}
**[Se liga!]{.text-warning}**
A fun√ß√£o `calcular` n√£o sabe qual opera√ß√£o ser√° executada, ela apenas invoca o comportamento recebido como par√¢metro. Isso √© o que chamamos de **abstra√ß√£o de comportamento**.
:::



A sa√≠da desse programa ser√°

```{.console code-line-numbers="false"}
  Soma:      12
  Subtra√ß√£o: 8
  Produto:   20
  Divis√£o:   5 
```
Ao **passar a fun√ß√£o como par√¢metro**, tornamos o c√≥digo de C extremamente **poderoso e reutiliz√°vel**. A fun√ß√£o `calcular` n√£o se importa como o c√°lculo √© feito, apenas que a fun√ß√£o fornecida (o _callback_) respeite o contrato de tipos (`int` para retorno, e `int`, `int` para par√¢metros).

Podemos ir al√©m nessa reutiliza√ß√£o? Sim, mas atingimos o limite do **{{< glossary polimorfismo >}}** simples em C. Imagine que voc√™ queira adicionar uma opera√ß√£o com n√∫meros de ponto flutuante:


```{.c code-line-numbers="false"}
double somad (double a, double b) { return a + b; }
```

O problema √© que n√£o podemos passar `somad` para a fun√ß√£o `calcular` e nem a usar para operar com `double`, pois o _callback_ `int (*operacao)(int, int)` e os par√¢metros fixos em `calcular(int a, int b, ...)` tornam essa fun√ß√£o totalmente incompat√≠vel com o tipo `double`.

Para resolver esse problema e criar uma √∫nica fun√ß√£o verdadeiramente gen√©rica que aceite qualquer tipo de dado, precisamos abandonar os tipos concretos (`int`, `double`) e generalizar usando o ponteiro sem tipo (`void*`).


Antes de darmos o salto para o c√≥digo verdadeiramente gen√©rico usando `void*`, vamos usar o `typedef` para melhorar a legibilidade de nosso c√≥digo.

A sintaxe de um ponteiro de fun√ß√£o (por exemplo, `int (*operacao)(int, int)`) pode dificultar a leitura do c√≥digo, principalmente como argumentos de fun√ß√£o. O `typedef` permite que voc√™ crie um apelido para essa assinatura complexa, tratando-a como um novo tipo de dado simples.

Ao definir o tipo do _callback_, tornamos a fun√ß√£o `calcular` muito mais limpa:


```c
// Definimos 'Operacao' como o tipo para qualquer fun√ß√£o
// que retorna int e aceita dois int como par√¢metros.
typedef int (*Operacao)(int, int);

// A fun√ß√£o 'calcular' agora usa o tipo 'Operacao', 
// simplificando sua assinatura.
int calcular(int a, int b, Operacao operacao); 
```
O c√≥digo final ficaria assim:

```{.c filename=calculadora_typedef.c}
#include <stdio.h>

// Defini√ß√£o do TIPO de ponteiro de fun√ß√£o
typedef int (*Operacao)(int, int);

// Fun√ß√µes concretas (omitidas para brevidade)
int soma (int a, int b) { return a + b; }
// ...

// A Fun√ß√£o Coordenadora agora √© mais leg√≠vel
int calcular(int a, int b, Operacao operacao) {
  return operacao(a, b);
}

int main(){

  int n1 = 10;
  int n2 = 2;
  
  printf("Soma: %d\n", calcular(n1, n2, soma));
  
  return 0;
}
```
::: {.column-margin}
**[Se liga!]{.text-warning}**
Com `typedef`, ganhamos mais clareza no c√≥digo. A fun√ß√£o `calcular` se torna muito mais limpa e leg√≠vel. 
:::

Com essa abrodardagem, ganhamos:

- **Reutiliza√ß√£o**: A fun√ß√£o `calcular` √© reutilizada para todas as opera√ß√µes.
- **F√°cil extens√£o**:	Para adicionar uma nova opera√ß√£o, basta criar a fun√ß√£o e pass√°-la para `calcular`. N√£o precisamos de blocos `if/else` ou `switch` dentro de `calcular`.
- **Baixo acoplamento**:	`calcular` n√£o precisa saber como a opera√ß√£o √© feita (se √© soma ou subtra√ß√£o), apenas que a fun√ß√£o passada segue o contrato definido pelo tipo `Operacao`.

Dessa maneira, `calcular` se comporta de v√°rias formas (polimorfismo).

## Ponteiro gen√©rico {#sec-gen}

Agora que compreendemos o funcionamento dos ponteiros, passagem por refer√™ncia e _callbacks_, podemos dar um passo al√©m. Vamos estudar um m√©todo para representar qualquer tipo de dado.

Em C, o tipo `void *` √© conhecido como ponteiro gen√©rico (_generic pointer_). Ele √© um tipo especial de ponteiro que pode armazenar o endere√ßo de qualquer tipo de dado, por exemplo `int`, `double`, `char`, `struct` etc.

```{.c code-line-numbers="false"}
int idade = 20;
double meta = 8.5;
char letra = 'A';

void *ptr;

ptr = &idade;
printf("idade: %d\n", *(int *)ptr);

ptr = &meta;
printf("meta: %.2f\n", *(double *)ptr);

ptr = &letra;
printf("letra: %c\n", *(char *)ptr);
```

::: {.column-margin}
**[Se liga!]{.text-warning}**
N√£o podemos desreferenciar diretamente um ponteiro `void *` , pois o compilador n√£o sabe quantos _bytes_ ele deve ler. Devemos sempre fazer um _cast_ (convers√£o) do `void *` para o tipo espec√≠fico de ponteiro que desejamos, antes de poder us√°-lo.
:::

Repare que, embora `ptr` sempre seja do tipo `void *`, precisamos fazer um _cast_ (convers√£o expl√≠cita) para o tipo correto antes de acessar o valor. Isso ocorre porque o compilador n√£o sabe qual √© o tipo real do dado armazenado e, portanto, n√£o pode fazer aritm√©tica de ponteiros nem desreferencia√ß√£o direta.

Essa caracter√≠stica √© o que permite criar estruturas de dados gen√©ricas em C, como listas, pilhas ou filas capazes de armazenar qualquer tipo. Essas estruturas ir√£o guardar apenas endere√ßos gen√©ricos (`void *`) e n√£o se importar com o tipo concreto do dado. A responsabilidade de interpretar corretamente o tipo ser√° de quem usar a estrutura.

## O papel de `size_t` {#sec-siz}

Ao manipular dados de tipos diferentes, precisamos tamb√©m saber quanto de mem√≥ria reservar ou copiar.
√â a√≠ que entra o tipo `size_t`, definido no cabe√ßalho `<stddef.h>` (ou implicitamente inclu√≠do via `<stdlib.h>` ou `<stdio.h>`).

Como um tipo num√©rico sem sinal (_unsigned_), `size_t` √© usado para representar tamanhos e quantidades de _bytes_. Ele √© o tipo de retorno de fun√ß√µes como `sizeof`, `malloc`, `calloc` e `strlen`.

```{.c}
#include <stdio.h>
#include <stdlib.h>

int main() {
    int x = 10;
    double y = 3.14;

    printf("sizeof(int)   : %zu bytes\n", sizeof(int));
    printf("sizeof(double): %zu bytes\n", sizeof(double));

    void *ptr = malloc(sizeof(double));
    printf("Alocado %zu bytes em %p\n", sizeof(double), ptr);

    free(ptr);
    return 0;
}
```

::: {.column-margin}
**[Se liga!]{.text-warning}**

- `z` √© um modificador de comprimento que especifica que o argumento √© do tipo `size_t`
- `u`	√© o c√≥digo de convers√£o para inteiro decimal sem sinal (`unsigned`).
:::

Sa√≠da t√≠pica:

```{.console code-line-numbers="false"}
sizeof(int)   : 4 bytes
sizeof(double): 8 bytes
Alocado 8 bytes em 0x7ffee1
```

A combina√ß√£o de `void *` e `size_t` √© fundamental para criar estruturas gen√©ricas, pois usaremos `void *` para representar o dado, independentemente de tipo e `size_t` para indicar o tamanho desse dado, permitindo c√≥pia, aloca√ß√£o e manipula√ß√£o seguras.

::: {.callout-note icon="false" title="üéØ Desafio de C√≥digo"}
Crie uma fun√ß√£o `aplicar` que recebe um vetor de inteiros e uma fun√ß√£o _callback_ que √© aplicada a cada elemento do vetor. Para as fun√ß√µes de callback, implemente: 

- `dobra`: dobra o valor de cada elemento do vetor
- `zerar`: Define cada elemento como zero
- `incrementar`: soma um a cada elemento do vetor

Segue a decla√ß√£o da fun√ß√µes de callback e ordem superior, al√©m de um exemplo de uso.

```c
#include <stdio.h>

void dobrar(int *x);
void zerar(int *x);
void incrementar(int *x);

void aplicar(int *vetor, int tamanho, void (*funcao)(int *));

int main() {
    int numeros[] = {1, 2, 3, 4, 5};
    aplicar(numeros, 5, dobrar);

    for (int i = 0; i < 5; i++) {
        printf("%d ", numeros[i]);
    }

    return 0;
}
```
:::

::: {.callout-tip title="Solu√ß√£o (clique para ver)" collapse="true"}
```{.c}
void dobrar(int *x){ *x = *x * 2; }

void zerar(int *x){ *x = 0; }

void incrementar(int *x){ *x = *x + 1; }

void aplicar(int *vetor, int tamanho, void (*funcao)(int *)){
  for (int i = 0; i < tamanho; i++)
        funcao(&vetor[i]);
}    

```
:::


Nesta unidade, voc√™ aprendeu

‚úÖ a declarar um ponteiro de fun√ß√£o

‚úÖ a criar fun√ß√µes de ordem superior e de _callbacks_

‚úÖ a usar ponteiros sem tipo (`void *`)

‚úÖ a usar `site_t` para designar tamanho ou quantidade de _bytes_


Falta pouco para criarmos nossas estruturas gen√©ricas com comportamentos tamb√©m gen√©ricos. Por√©m, ainda precisamos pontuar algumas quest√µes sobre o gerenciamento de mem√≥ria.