---
title: "Callbacks"
lang: pt
toc-title: Conteúdo
toc: false
sidebar: false
format:
  html:
    reference-location: margin
    css: ../styles/academic.css
---

Nossa jornada pelos ponteiros ainda não acabou. Nesta unidade vamos estudar o uso de ponteiros com funções. Isso mesmo, uma função também possui um endereço de memória. Poderemos chamar funções indiretamente e passar funções como paramêtros para outras funções. 


## Ponteiros de Funções {#sec-fun}

Um ponteiro também pode armazenar o endereço de uma função. O raciocínio é o mesmo de antes, mas a sintaxe para a declaração é mais específica, pois ela precisa descrever a **assinatura** completa da função: seu tipo de retorno e seus parâmetros.

A sintaxe de declaração pode parecer confusa no início, mas pode ser lida assim:

`tipo_de_retorno (*nome_do_ponteiro)(tipos_de_parametros);`

Vamos tomar a função `media` como exemplo. Ela recebe dois valores e retorna a média aritmética deles.

```{.c code-line-numbers="false"}
double media (double n1, double n2){
  return (n1 + n2)/2;
}

// Declaração de um ponteiro de função:
double (*media_ptr)(double, double) = media;
```

A sintaxe de declaração do ponteiro `media_prt` deve ser lida da seguinte forma:

- `double`: é o tipo de retorno;

- `(*media_ptr)`: indica que `media_ptr` é um ponteiro para função. Os parênteses são **obrigatórios** para diferenciá-lo de uma função que retorna um ponteiro;

- `(double, double)`: são os tipos dos parâmetros da função apontada.

::: {.callout-note }
Diferentemente das variáveis, ao atribuir o endereço de uma função a um ponteiro de função, não é necessário usar o operador & (o nome da função sozinho já representa seu endereço).
:::

Note que a função `media` obedece a **assinatura** (ou contrato) estabelecido pelo ponteiro de função `media_ptr`, ou seja, possui o mesmo **tipo de retorno** e os mesmos **tipos de parâmetros de entrada** (`double, double`). Portanto, devemos manter a **compatibilidade** de tipos, como fizemos com as variáveis na seção anterior.


## Introdução aos Callbacks {#sec-cal}

O verdadeiro poder dos ponteiros de função aparece quando uma função é passada como argumento para outra.
Nesse caso, a função que recebe outra função é chamada de **função de ordem superior**, enquanto a função fornecida como argumento é chamada de **_callback_**.

Essa técnica permite que um trecho de código delegue parte de seu comportamento a outro, tornando o programa mais flexível, modular e paramétrico.

Abaixo, um exemplo de uma calculadora de inteiros, onde `calcular` é uma função de ordem superior, pois recebe outra função como parâmetro. As funções `soma`, `subtracao`, `produto` e `divisao` são _callbacks_, pois são passadas para `calcular`.

```{.c filename=calculadora_param.c}
#include <stdio.h>

// Funções concretas (implementam comportamentos específicos)
int soma (int a, int b)     { return a + b; }
int subtracao (int a, int b){ return a - b; }
int produto (int a, int b)  { return a * b; }
int divisao (int a, int b)  { return a / b; }

// Função coordenadora (de ordem superior)
// Recebe duas variáveis e um ponteior de função como parâmetros
int calcular(int a, int b, int (*operacao)(int, int)) {
  return operacao(a, b);
}

int main(){

  int n1 = 10;
  int n2 = 2;
  
  printf("Soma:      %d\n", calcular(n1, n2, soma));
  printf("Subtração: %d\n", calcular(n1, n2, subtracao));
  printf("Produto:   %d\n", calcular(n1, n2, produto));
  printf("Divisão:   %d\n", calcular(n1, n2, divisao));  
  
  return 0;
}
```

::: {.column-margin}
**[Se liga!]{.text-warning}**
A função `calcular` não sabe qual operação será executada, ela apenas invoca o comportamento recebido como parâmetro. Isso é o que chamamos de **abstração de comportamento**.
:::



A saída desse programa será

```{.console code-line-numbers="false"}
  Soma:      12
  Subtração: 8
  Produto:   20
  Divisão:   5 
```
Ao **passar a função como parâmetro**, tornamos o código de C extremamente **poderoso e reutilizável**. A função `calcular` não se importa como o cálculo é feito, apenas que a função fornecida (o _callback_) respeite o contrato de tipos (`int` para retorno, e `int`, `int` para parâmetros).

Podemos ir além nessa reutilização? Sim, mas atingimos o limite do **{{< glossary polimorfismo >}}** simples em C. Imagine que você queira adicionar uma operação com números de ponto flutuante:


```{.c code-line-numbers="false"}
double somad (double a, double b) { return a + b; }
```

O problema é que não podemos passar `somad` para a função `calcular` e nem a usar para operar com `double`, pois o _callback_ `int (*operacao)(int, int)` e os parâmetros fixos em `calcular(int a, int b, ...)` tornam essa função totalmente incompatível com o tipo `double`.

Para resolver esse problema e criar uma única função verdadeiramente genérica que aceite qualquer tipo de dado, precisamos abandonar os tipos concretos (`int`, `double`) e generalizar usando o ponteiro sem tipo (`void*`).


Antes de darmos o salto para o código verdadeiramente genérico usando `void*`, vamos usar o `typedef` para melhorar a legibilidade de nosso código.

A sintaxe de um ponteiro de função (por exemplo, `int (*operacao)(int, int)`) pode dificultar a leitura do código, principalmente como argumentos de função. O `typedef` permite que você crie um apelido para essa assinatura complexa, tratando-a como um novo tipo de dado simples.

Ao definir o tipo do _callback_, tornamos a função `calcular` muito mais limpa:


```c
// Definimos 'Operacao' como o tipo para qualquer função
// que retorna int e aceita dois int como parâmetros.
typedef int (*Operacao)(int, int);

// A função 'calcular' agora usa o tipo 'Operacao', 
// simplificando sua assinatura.
int calcular(int a, int b, Operacao operacao); 
```
O código final ficaria assim:

```{.c filename=calculadora_typedef.c}
#include <stdio.h>

// Definição do TIPO de ponteiro de função
typedef int (*Operacao)(int, int);

// Funções concretas (omitidas para brevidade)
int soma (int a, int b) { return a + b; }
// ...

// A Função Coordenadora agora é mais legível
int calcular(int a, int b, Operacao operacao) {
  return operacao(a, b);
}

int main(){

  int n1 = 10;
  int n2 = 2;
  
  printf("Soma: %d\n", calcular(n1, n2, soma));
  
  return 0;
}
```
::: {.column-margin}
**[Se liga!]{.text-warning}**
Com `typedef`, ganhamos mais clareza no código. A função `calcular` se torna muito mais limpa e legível. 
:::

Com essa abrodardagem, ganhamos:

- **Reutilização**: A função `calcular` é reutilizada para todas as operações.
- **Fácil extensão**:	Para adicionar uma nova operação, basta criar a função e passá-la para `calcular`. Não precisamos de blocos `if/else` ou `switch` dentro de `calcular`.
- **Baixo acoplamento**:	`calcular` não precisa saber como a operação é feita (se é soma ou subtração), apenas que a função passada segue o contrato definido pelo tipo `Operacao`.

Dessa maneira, `calcular` se comporta de várias formas (polimorfismo).

## Ponteiro genérico {#sec-gen}

Agora que compreendemos o funcionamento dos ponteiros, passagem por referência e _callbacks_, podemos dar um passo além. Vamos estudar um método para representar qualquer tipo de dado.

Em C, o tipo `void *` é conhecido como ponteiro genérico (_generic pointer_). Ele é um tipo especial de ponteiro que pode armazenar o endereço de qualquer tipo de dado, por exemplo `int`, `double`, `char`, `struct` etc.

```{.c code-line-numbers="false"}
int idade = 20;
double meta = 8.5;
char letra = 'A';

void *ptr;

ptr = &idade;
printf("idade: %d\n", *(int *)ptr);

ptr = &meta;
printf("meta: %.2f\n", *(double *)ptr);

ptr = &letra;
printf("letra: %c\n", *(char *)ptr);
```

::: {.column-margin}
**[Se liga!]{.text-warning}**
Não podemos desreferenciar diretamente um ponteiro `void *` , pois o compilador não sabe quantos _bytes_ ele deve ler. Devemos sempre fazer um _cast_ (conversão) do `void *` para o tipo específico de ponteiro que desejamos, antes de poder usá-lo.
:::

Repare que, embora `ptr` sempre seja do tipo `void *`, precisamos fazer um _cast_ (conversão explícita) para o tipo correto antes de acessar o valor. Isso ocorre porque o compilador não sabe qual é o tipo real do dado armazenado e, portanto, não pode fazer aritmética de ponteiros nem desreferenciação direta.

Essa característica é o que permite criar estruturas de dados genéricas em C, como listas, pilhas ou filas capazes de armazenar qualquer tipo. Essas estruturas irão guardar apenas endereços genéricos (`void *`) e não se importar com o tipo concreto do dado. A responsabilidade de interpretar corretamente o tipo será de quem usar a estrutura.

## O papel de `size_t` {#sec-siz}

Ao manipular dados de tipos diferentes, precisamos também saber quanto de memória reservar ou copiar.
É aí que entra o tipo `size_t`, definido no cabeçalho `<stddef.h>` (ou implicitamente incluído via `<stdlib.h>` ou `<stdio.h>`).

Como um tipo numérico sem sinal (_unsigned_), `size_t` é usado para representar tamanhos e quantidades de _bytes_. Ele é o tipo de retorno de funções como `sizeof`, `malloc`, `calloc` e `strlen`.

```{.c}
#include <stdio.h>
#include <stdlib.h>

int main() {
    int x = 10;
    double y = 3.14;

    printf("sizeof(int)   : %zu bytes\n", sizeof(int));
    printf("sizeof(double): %zu bytes\n", sizeof(double));

    void *ptr = malloc(sizeof(double));
    printf("Alocado %zu bytes em %p\n", sizeof(double), ptr);

    free(ptr);
    return 0;
}
```

::: {.column-margin}
**[Se liga!]{.text-warning}**

- `z` é um modificador de comprimento que especifica que o argumento é do tipo `size_t`
- `u`	é o código de conversão para inteiro decimal sem sinal (`unsigned`).
:::

Saída típica:

```{.console code-line-numbers="false"}
sizeof(int)   : 4 bytes
sizeof(double): 8 bytes
Alocado 8 bytes em 0x7ffee1
```

A combinação de `void *` e `size_t` é fundamental para criar estruturas genéricas, pois usaremos `void *` para representar o dado, independentemente de tipo e `size_t` para indicar o tamanho desse dado, permitindo cópia, alocação e manipulação seguras.

::: {.callout-note icon="false" title="🎯 Desafio de Código"}
Crie uma função `aplicar` que recebe um vetor de inteiros e uma função _callback_ que é aplicada a cada elemento do vetor. Para as funções de callback, implemente: 

- `dobra`: dobra o valor de cada elemento do vetor
- `zerar`: Define cada elemento como zero
- `incrementar`: soma um a cada elemento do vetor

Segue a declação da funções de callback e ordem superior, além de um exemplo de uso.

```c
#include <stdio.h>

void dobrar(int *x);
void zerar(int *x);
void incrementar(int *x);

void aplicar(int *vetor, int tamanho, void (*funcao)(int *));

int main() {
    int numeros[] = {1, 2, 3, 4, 5};
    aplicar(numeros, 5, dobrar);

    for (int i = 0; i < 5; i++) {
        printf("%d ", numeros[i]);
    }

    return 0;
}
```
:::

::: {.callout-tip title="Solução (clique para ver)" collapse="true"}
```{.c}
void dobrar(int *x){ *x = *x * 2; }

void zerar(int *x){ *x = 0; }

void incrementar(int *x){ *x = *x + 1; }

void aplicar(int *vetor, int tamanho, void (*funcao)(int *)){
  for (int i = 0; i < tamanho; i++)
        funcao(&vetor[i]);
}    

```
:::


Nesta unidade, você aprendeu

✅ a declarar um ponteiro de função

✅ a criar funções de ordem superior e de _callbacks_

✅ a usar ponteiros sem tipo (`void *`)

✅ a usar `site_t` para designar tamanho ou quantidade de _bytes_


Falta pouco para criarmos nossas estruturas genéricas com comportamentos também genéricos. Porém, ainda precisamos pontuar algumas questões sobre o gerenciamento de memória.