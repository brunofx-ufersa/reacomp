---
title: "Tabela de Dispers√£o"
lang: pt
toc-title: Conte√∫do
toc: false
sidebar: false
format:
  html:
    reference-location: margin
    css: ../styles/academic.css
---

Nesta unidade do curso, iremos estudar as **tabelas de dispers√£o** (_hash table_). Pense em uma busca que n√£o demora, que n√£o precisa de caminhadas longas por uma lista ou descidas por uma √°rvore. Imagine que voc√™ pode encontrar qualquer dado em um instante, de forma quase m√°gica. Essa √© a promessa de uma tabela de dispers√£o.

Vamos explorar o conceito de **fun√ß√£o de hash**, que √© o cora√ß√£o dessa estrutura, e aprenderemos a lidar com as **colis√µes**. Ao final, voc√™ ter√° em m√£os uma das ferramentas mais r√°pidas e eficientes para a manipula√ß√£o de grandes volumes de dados desde dicion√°rios de programa√ß√£o at√© _caches_ de navegador e bancos de dados. 


## Problematiza√ß√£o

Voc√™ est√° desenvolvendo um RPG retr√¥ com restri√ß√µes severas de mem√≥ria, limitando seu cat√°logo mestre de itens a um array de apenas 10 slots (√≠ndices de 0 a 9).

No entanto, o jogo tem muito mais do que 10 itens no total, e cada um tem um ID inteiro √∫nico (a chave).

| Item	            | ID (chave) | Cor (valor) |
|-------------------|------------|-------------|
| Po√ß√£o de Vida     | 12         | Vermelho    |
| Amuleto Raro      | 18         | Ouro        |
| Espada Longa      | 21         | A√ßo         |
| P√£o Velho         | 3          |  Marrom     |
| Armadura de Couro | 15         | Couro       |

O desafio √© como mapear IDs muito maiores que 9 (12, 22, 13) para um slot que s√≥ vai de 0 a 9, e ainda assim conseguir encontr√°-los rapidamente?


## Proposta de solu√ß√£o

A ideia √© usar uma fun√ß√£o que transforma qualquer ID em um n√∫mero entre 0 e 9, reaproveitando o mesmo espa√ßo de forma controlada.

Essa fun√ß√£o √© o m√≥dulo (resto da divis√£o):

$$h(id) = id\bmod 10$$

Como o divisor √© $10$, os √∫nicos valores de resto poss√≠veis s√£o os n√∫meros de 0 a 9, como desejamos.

Aplicando a fun√ß√£o aos nossos itens:

- $h(12) = 12 \bmod 10 = 2$
- $h(18) = 18 \bmod 10 = 8$
- $h(21) = 21 \bmod 10 = 1$
- $h(3)\,\,\,= 3\,\,\,\bmod 10 = 3$
- $h(15) = 15 \bmod 10 = 5$

Dessa maneira, nosso vetor resultante seria:


|slot | 0   | 1    |  2   | 3  | 4  | 5   | 6   | 7   | 8   | 9  |
|-----| :----: | :-----: | :-----: | :---: | :---: | :----: | :----: | :----: | :----: | :---: |
| id  | ‚ùå | Espada Longa  | Po√ß√£o de Vida  | P√£o Velho | ‚ùå | Armadura de Couro | ‚ùå | ‚ùå | Amuleto Raro | ‚ùå |

Agora, para verificar se o jogador possui o Amuleto Raro, basta aplicar novamente a mesma fun√ß√£o: $h(18) = 18 \bmod 10 = 8$.

Sem precisar percorrer todo o _array_, o jogo j√° sabe que o item (se existir) estar√° na posi√ß√£o $8$.

::: {.column-margin}
**[Se liga!]{.text-warning}**
Essa t√©cnica permite economizar mem√≥ria e acessar elementos em tempo constante, O(1).
:::

Um questionamento comum acontece quando a fun√ß√£o retorna o mesmo valor para duas chaves distintas. Por exemplo, com uma chave $25$, teremos $f(25)=25\bmod 10=5$, mas a posi√ß√£o $5$ j√° est√° ocupada e o vetor n√£o est√° totalmente preenchido. Hesse caso, dizemos que ocorreu uma colis√£o.

Colis√µes s√£o indesej√°veis! Precisamos de fun√ß√µes bem definidas para evitar esse tipo de problema.


## Fun√ß√£o Hash

A fun√ß√£o que escolhemos anteriormente √© chamada de fun√ß√£o de hash. Existem v√°rias vers√µes, mas a que mostramos √© uma das mais simples.


### Caracter√≠sticas da Fun√ß√£o Hash
	
- F√°cil de ser calculada;
- Distribui√ß√£o uniforme dos dados;
- Minimiza as colis√µes;
- Capaz de resolver poss√≠veis colis√µes.

A vantagem da tabela hash √© a velocidade de busca, uma fun√ß√£o muito complicada para calcular √© incoveniente, pois pode demorar mais que uma busca em uma √°rvore bin√°ria, por exemplo. Al√©m disso, se a fun√ß√£o n√£o distribui as chaves de maneira uniforme, muitas delas ir√£o se concentrar em um local do vetor, aumentando a probabilidade de colis√µes.


### M√©todo da Divis√£o
	
  No m√©todo da divis√£o, usamos o resultado do resto da divis√£o do valor da chave pelo tamanho da tabela.
 $$h(k) = k \bmod m$$

O ideal √© que $m$ seja um n√∫mero primo e n√£o muito pr√≥ximo de pot√™ncias de $2$.
	
Por exemplo, se $k=12345$ e $m=101$, ent√£o
$$h(k) = h(12345)= 12345 \bmod 101 = 22$$

A chave $12345$ deve ser alocada na posi√ß√£o $22$ do vetor de $101$ posi√ß√µes.	
	
::: {.column-margin}
**[Se liga!]{.text-warning}**
Nem sempre trateremos com chaves inteiras simples como as vistas at√© aqui. Nesses casos, precisamos de um mecanismo para transformar em um valor inteiro antes de processar a fun√ß√£o hash. Veremos isso √† frente.
:::


Este √© o m√©todo mais simples e f√°cil de gerar um valor de hash. A fun√ß√£o hash divide o valor $k$ (chave) por $m$ (tamanho da tabela) e, em seguida, usa o resto obtido. √â mais adequado que $m$ seja um n√∫mero primo, pois isso pode garantir que as chaves sejam distribu√≠das de forma mais uniforme. 

Embora simples, o m√©todo da divis√£o leva a um desempenho ruim, uma vez que chaves consecutivas mapeiam para valores de hash consecutivos na tabela de hash.
	
::: {.callout-note icon="false" title="Exerc√≠cio"}
Dada a fun√ß√£o hash $h(k) = k^2\bmod 7$, calcule os valores hash para as chaves $$4, 17, 13, 35, 25, 11, 2, 10, 32$$.
:::

::: {.callout-tip title="Solu√ß√£o (clique para ver)" collapse="true"}
- $h(4)\,\,\,=\,\,\,4^2\bmod 7=16\bmod 7\,\,\,\,\,\,=2$
- $h(17)=17^2\bmod 7=289\bmod 7\,\,\,=2$
- $h(13)=13^2\bmod 7=169\bmod 7\,\,\,=1$
- $h(35)=35^2\bmod 7=1225\bmod 7=0$
- $h(25)=25^2\bmod 7=625\bmod 7\,\,\,=2$
- $h(11)=11^2\bmod 7=121\bmod 7\,\,\,=2$
- $h(2)\,\,\,=\,\,\,2^2\bmod 7=4\bmod 7\,\,\,\,\,\,\,\,\,=4$
- $h(10)=10^2\bmod 7=100\bmod 7\,\,\,=2$
- $h(32)=32^2\bmod 7=1024\bmod 7=2$

Muitas colis√µes ocorreram! Era evidente que haveria sobreposi√ß√£o de chaves, pois temos somentes sete espa√ßos. 
:::

### M√©todo da Multiplica√ß√£o

No m√©todo da multiplica√ß√£o, realizamos os seguintes passos:

- Multiplicamos a chave ($k$) por uma constate $A$ entre $0$ e $1$;
- Extra√≠mos a parte fracion√°ria de $kA$;
- Multiplicamos esse valor por $m$ (tamanho da tabela);
- Arredondamos para baixo;

Ou seja,

$$h(k) = \lfloor m (kA \bmod 1) \rfloor, \text{ com } 0 < A < 1$$

Por exemplo, considere $k = 123$, $m = 1000$, e $A \approx 0,618$.

$$h(k) = \lfloor 1000 (123 \cdot 0,618 \bmod 1) \rfloor=\lfloor 1000 (76,014 \bmod 1) \rfloor=\lfloor 1000\cdot 0.014 \rfloor=14$$
	
	
A vantagem do m√©todo de multiplica√ß√£o √© que ele pode trabalhar com qualquer valor entre 0 e 1. 

::: {.column-margin}
**[Se liga!]{.text-warning}**
O m√©todo de multiplica√ß√£o √© geralmente adequado quando o tamanho da tabela √© uma pot√™ncia de dois.	
:::

::: {.callout-note icon="false" title="Exerc√≠cio"}
Seja a chave $k = 12345$, a constante $A = 0,357840$ e o tamanho da tabela $m = 100$, calcule o valor hash usando o m√©todo da multiplica√ß√£o.
:::

::: {.callout-tip title="Solu√ß√£o (clique para ver)" collapse="true"}
$$h(k) = \lfloor m (kA \bmod 1) \rfloor$$
$h(12345) = \lfloor 100 (12345\cdot 0,357840 \bmod 1) \rfloor=\lfloor 100 (4417,5348 \bmod 1) \rfloor=\lfloor 100 (0,5348) \rfloor=\lfloor 53,48 \rfloor=53$
:::

### Hashing Universal

O hash universal tenta resolver o problema das colis√µes usando uma fam√≠lia de fun√ß√µes de hash, $\mathcal{H}$, que possui uma propriedade matem√°tica crucial:

> Para quaisquer duas chaves distintas, $k_1$ e $k_2$, a probabilidade de que a fun√ß√£o de hash $h \in \mathcal{H}$ escolhida aleatoriamente cause uma colis√£o √© no m√°ximo igual √† probabilidade de colis√£o aleat√≥ria, que √© $1/m$, onde $m$ √© o n√∫mero de posi√ß√µes na tabela hash.

Uma das fam√≠lias universais mais usadas para chaves que s√£o n√∫meros inteiros e uma tabela de tamanho $m$ √© definida da seguinte forma:

Seja $p$ um n√∫mero primo maior que qualquer chave poss√≠vel, e $m$ o tamanho da tabela hash. A fam√≠lia $\mathcal{H}$ √© o conjunto de fun√ß√µes $h_{a,b}$ dadas pela f√≥rmula:
$$h_{a,b}(k) = ((ak + b) \bmod p) \bmod m$$

Onde $a$ e $b$ s√£o par√¢metros **inteiros** aleat√≥rios escolhidos no in√≠cio, com $a\in[1, p-1]$ e $b\in[0, p-1]$.
  
Os par√¢metros aleat√≥rios ajudam a dispersar o valor da chave. J√° a opera√ß√£o de m√≥dulo por um primo $p$ ajuda a garantir que a distribui√ß√£o do resultado seja uniforme no intervalo $[0, p-1]$. Finalmente, o resultado final √© mapeado para o √≠ndice da tabela hash, no intervalo $[0, m-1]$. 
  
Por exemplo, digamos uma tabela com $m=10$ slots e escolhamos $p=103$.

- Sorteamos $a$ entre $1$ e $p-1$, ou seja, no intervalo $[1, 102]$ 
- Sorteamos $b$ entre $0$ e $p-1$, ou seja, no intervalo $[0, 102]$ 

Digamos que $a=5$ e $b=13$, ent√£o nossa fun√ß√£o sorteada da fam√≠lia universal ser√°:
$$h_{5,13}(k)=((5k+13)\bmod103)\bmod 10$$

Vamos calcular alguns valores de hash para fixa√ß√£o.

- $h(4)\,\,\,=\,\,\,((5\cdot4+13)\bmod103)\bmod 10=\,\,\,(33\bmod103)\bmod 10=33 \bmod 10=3$
- $h(17)=((5\cdot17+13)\bmod103)\bmod 10=\,\,\,(98\bmod103)\bmod 10= 98\bmod 10=8$
- $h(25)=((5\cdot25+13)\bmod103)\bmod 10=(138\bmod103)\bmod 10=35\bmod 10=5$
- $h(32)=((5\cdot32+13)\bmod103)\bmod 10=(173\bmod103)\bmod 10=70\bmod 10=0$


Mesmo com os melhores m√©todos, √© imposs√≠vel evitar colis√µes. Quando acontece, devemos trat√°-la de modo que o desempenho da busca n√£o seja muito afetado. No entanto, antes de estudarmos os tratamentos de coli√ß√µes, iremos abordar as estrat√©gias para mapeamento de chaves em inteiros.


## Estrat√©gias para Mapeamento

Quando falamos em mapeamento de chaves em inteiros, estamos nos referindo a um pr√©-processamento que transforma uma chave (como uma string ou um n√∫mero muito grande) em um inteiro mais adequado para ser usado por uma fun√ß√£o de hash.

Embora seja poss√≠vel criar suas pr√≥prias estrat√©gias, apresentamos a seguir alguns m√©todos cl√°ssicos encontrados na literatura.

### üî† Chaves do tipo _string_

Os m√©todos cl√°ssicos para tratar strings usam o fato de cada letra ter um inteiro correspondente na tabela ASCII.

#### Soma

Muitas vezes, as chaves que estamos trabalhando s√£o _strings_. Uma forma simples de convert√™-las em inteiros √© somar os valores ASCII de cada caractere:
$$k=\sum_{i=0}^{n-1}s[i]=s[0]+s[1]+s[2]+\cdots+s[n-1]$$

onde $n$ √© o tamanho da palavra.

Por exemplo, a palavra "PAI" (P = 80, A = 65 e I = 73):
$$k=\sum_{i=0}^{3-1}s[i]=\sum_{i=0}^{2}s[i]=s[0]+s[1]+s[2]=80+65+73=218$$

Esse m√©todo √© simples, mas apresenta m√° distribui√ß√£o, ou seja, palavras com as mesmas letras em ordem diferente geram o mesmo valor.

#### Multiplica√ß√£o Polinomial

Um m√©todo mais robusto √© o da **multiplica√ß√£o polinomial**. Aqui, tratamos a _string_ como um n√∫mero em uma base $\beta$ (Œ≤ (geralmente um n√∫mero primo pequeno):
$$k=s[0]\cdot\beta^{n-1}+s[1]\cdot\beta^{n-2}+\cdots+s[n-1]\cdot\beta^{0}$$

Por exemplo, a palavra "PAI" (P = 80, A = 65 e I = 73) e $\beta=13$:
$$k=s[0]\cdot 13^{3-1}+s[1]\cdot 13^{3-2}+\cdots+s[2]\cdot 13^{0}=80\cdot13^2+65\cdot13^1+73\cdot13^0=14438$$

::: {.column-margin}
**[Se liga!]{.text-warning}**
A multiplica√ß√£o por um n√∫mero primo ajuda a espalhar os valores de forma mais uniforme do que se us√°ssemos um n√∫mero composto.
:::

Essa t√©cnica √© superior √† soma simples, pois considera a ordem dos caracteres. Para palavras como "cama" e "maca", a soma simples ir√° retornar os mesmos valores, enquanto que a multiplica√ß√£o polinomial n√£o.

Exemplo simples: 

- $BA : 66\cdot13^1 + 65\cdot13^0 = 923$.
- $AB : 65\cdot13^1 + 66\cdot13^0 = 911$.

Dessa forma, "BA" e "AB" produzem resultados distintos, evitando colis√µes triviais.

### üî¢ Chaves do tipo _int_ grandes

Quando lidamos com inteiros muito grandes, precisamos reduzi-los para evitar estouro de capacidade (overflow) ou para encaix√°-los em um intervalo menor. A seguir, apresentamos tr√™s m√©todos comuns: dobramento (folding), XOR e quadrado central (mid-square).

#### Dobramento (Folding)

Consiste em dividir a chave em partes menores e, em seguida, som√°-las ou aplicar XOR entre elas para gerar um n√∫mero reduzido. Por exemplo, suponha $k = 83.529.170$, vamos dividir a chave assim:

- $k_1 = 835$
- $k_2 = 291$
- $k_3 = 70$

O dobramento por soma resulta em $k_1+k_2+k_3=835+291+70=1196$.

No dobramento por XOR, as partes s√£o combinadas usando a opera√ß√£o l√≥gica OU exclusivo (XOR), muito comum em fun√ß√µes de hash criptogr√°ficas. Primeiro, convertemos as partes para bin√°rio (aqui, usando 10 bits para simplificar):


| Parte | Decimal | Bin√°rio (10 bits)|
| -----| -----| -----|  
| $k_1$ | 835 | 1101000011| 
| $k_2$ | 291 | 0100100011| 
| $k_3$ | 70  | 0001000110| 

Realizamos a opera√ß√£o XOR bit a bit entre as partes.
$$k_1 \oplus k_2 \oplus k_3$$$$\begin{array}{r l l} & 1101000011 & (k_1) \\ \oplus & 0100100011 & (k_2) \\ \hline & 1001100000 & (k_1 \oplus k_2) \\ \oplus & 0001000110 & (k_3) \\ \hline & \mathbf{1000100110} & (\text{Resultado}) \end{array}$$

Transformando 1000100110 de volta para decimal:
$$1000100110_2=512+64+8+4+2=590$$

O m√©todo XOR tende a preservar melhor as caracter√≠sticas de todas as partes da chave, ainda que seja um pouco mais complexo de implementar do que a soma simples.

#### Mid-Square

O m√©todo do quadrado central √© uma t√©cnica cl√°ssica de extra√ß√£o. A chave √© elevada ao quadrado, e ent√£o o hash √© formado pelos d√≠gitos centrais do resultado. A quantidade de d√≠gitos extra√≠dos √© indicada por $d$.

Apesar de ser simples, ele pode gerar um c√≥digo hash razoavelmente bem distribu√≠do. Como exemplo, considere uma $k=931$ e $d=3$.
$$k^2=931^2=866761$$
Assim, podemos selecionar $676$, ou at√© $667$.

Esses m√©todos apresentados podem ser combinados ou at√© mesmo utilizados como substitutos de uma fun√ß√£o hash. Em sistemas mais complexos, essas abordagens costumam ser empregadas como etapas auxiliares dentro de fun√ß√µes de hash mais sofisticadas.

## Tratamento de Colis√µes

Sabemos que uma colis√£o ocorre quando a fun√ß√£o hash produz o mesmo valor para duas ou mais chaves
distintas.
$$h(k1) = h(k2)$$

Uma colis√£o √© praticamente inevit√°vel, por isso devemos trat√°-la. As principais
abordagens s√£o endere√ßamento aberto e encadeamento separado.

- **Endere√ßamento aberto**: percorrer a tabela em busca de um local n√£o ocupado.
- **Encadeamento separado**: uso de listas ligadas para armazenar as colis√µes.

::: {.column-margin}
**[Se liga!]{.text-warning}**
Endere√ßamento aberto: procura um endere√ßo aberto, um slot vazio.
Encadeamento separado: usa listas encadeadas separadas, uma para cada slot.
:::

### Endere√ßamento aberto

A t√©cnica de endere√ßamento aberto tenta resolver o problema de colis√£o buscando
um outro lugar vazio para armazenar a chave que colidiu. As maneiras principais de sondar um espa√ßo vazio s√£o:

- Sondagem linear;
- Sondagem quadr√°tica;
- Duplo hash

#### Sondagem linear

A sondagem linear procura pela pr√≥xima posi√ß√£o vazia do vetor. A fun√ß√£o de hash possui uma nova vari√°vel iterativa que permitir√° a procura por esse lugar vazio:
$$h(k,i) = (h(k)+i)\bmod n$$
onde $i=0,1,2,3,\ldots$

Sempre que ocorre um colis√£o, esta vari√°vel ($i$) √© incrementada em uma unidade.


Por exemplo, considere o vetor abaixo:

|slot | 0   | 1    |  2   | 3  | 4  | 5   | 6   | 7   | 8   | 9  |
|-----| :----: | :-----: | :-----: | :---: | :---: | :----: | :----: | :----: | :----: | :---: |
| chave  | ‚ùå | 21  | 42  | 63 | ‚ùå | ‚ùå | ‚ùå | ‚ùå | ‚ùå | 69 |

E a fun√ß√£o de hash $h(k)=k\bmod 10$.

Vamos adicionar a chave 81:

- $h(81,0) = (h(81) + 0) \bmod 10 = (1+0) \bmod 10 = 1$, colis√£o com 21
- $h(81,1) = (h(81) + 1) \bmod 10 = (1+1) \bmod 10 = 2$, colis√£o com 42
- $h(81,2) = (h(81) + 2) \bmod 10 = (1+2) \bmod 10 = 3$, colis√£o com 63
- $h(81,3) = (h(81) + 3) \bmod 10 = (1+3) \bmod 10 = 4$

Como a posi√ß√£o 4 est√° vazia, a chave 81 ser√° alocada l√°.


|slot | 0   | 1    |  2   | 3  | 4  | 5   | 6   | 7   | 8   | 9  |
|-----| :----: | :-----: | :-----: | :---: | :---: | :----: | :----: | :----: | :----: | :---: |
| chave  | ‚ùå | 21  | 42  | 63 | 81 | ‚ùå | ‚ùå | ‚ùå | ‚ùå | 69 |



#### Sondagem quadr√°tica

A sondagem quadr√°tica procura pela pr√≥xima posi√ß√£o vazia usando uma fun√ß√£o quadr√°tica. 
$$h(k,i) = (h(k)+c_1i+c_2i^2)\bmod n$$
onde $c_1,c_2$ s√£o constantes e $i=0,1,2,3,\ldots$

Considere o exemplo anterior com sondagem quadr√°tica ($c_1=0$ e $c_2=1$).

- $h(81,0) = (h(81) + 0^2) \bmod 10 = (1+0) \bmod 10 = 1$, colis√£o com 21
- $h(81,1) = (h(81) + 1^2) \bmod 10 = (1+1) \bmod 10 = 2$, colis√£o com 42
- $h(81,2) = (h(81) + 2^2) \bmod 10 = (1+4) \bmod 10 = 5$


Como a posi√ß√£o 5 est√° vazia, a chave 81 ser√° alocada l√°.


|slot | 0   | 1    |  2   | 3  | 4  | 5   | 6   | 7   | 8   | 9  |
|-----| :----: | :-----: | :-----: | :---: | :---: | :----: | :----: | :----: | :----: | :---: |
| chave  | ‚ùå | 21  | 42  | 63 | ‚ùå | 81 | ‚ùå | ‚ùå | ‚ùå | 69 |

#### Duplo hash

Como o nome sugere, o tratamento de colis√£o usa duas fun√ß√µes hash ($h_1$ e $h_2$). 
$$h(k,i) = (h_1(k) + i\cdot h_2(k)) \bmod n$$
onde $i=0,1,2,3,\ldots$

Por exemplo, suponha
$h_1(k) = k \bmod 10$ e $h_2(k) = 5 ‚àí (k \bmod 5)$. 

No exemplo anterior teremos:

- $h(81,0) = (h_1(81) + 0 \cdot h_2(81)) \bmod 10 = (1+0) \bmod 10 = 1$, colis√£o com 21
- $h(81,1) = (h_1(81) + 1 \cdot h_2(81)) \bmod 10 = (1 + 4) \bmod 10 = 5$

Ou seja,


|slot | 0   | 1    |  2   | 3  | 4  | 5   | 6   | 7   | 8   | 9  |
|-----| :----: | :-----: | :-----: | :---: | :---: | :----: | :----: | :----: | :----: | :---: |
| chave  | ‚ùå | 21  | 42  | 63 | ‚ùå | 81 | ‚ùå | ‚ùå | ‚ùå | 69 |

### Encadeamento separado

A t√©cnica de encadeamento separado √© bastante simples. Ao inv√©s de tratar a colis√£o procurando um lugar vazio, iremos colocar as colis√µes em uma lista encadeada. Logo, n√£o teremos um vetor de chaves, mas sim um vetor de ponteiros que apontam para listas encadeadas separadamente. 

No exemplo anterior, quando houve a colis√£o da chave 81 com 21, a posi√ß√£o 1 iria apontar para uma lista ligada com dois componentes.


```{mermaid}
flowchart TD
 subgraph s1["Array"]
        A0["‚ùå"]
        A1["prt_1"]
        A2["prt_2"]
        A3["prt_3"]
        A4["‚ùå"]
        A5["‚ùå"]
        A6["‚ùå"]
        A7["‚ùå"]
        A8["‚ùå"]
        A9["prt_9"]
  end
    A1 -.-> B1["21"]
    B1 --> B2["81"]
    A2 -.-> B3["42"]
    A3 -.-> B4["63"]
    A9 -.-> B5["69"]
    B2 --> n1["Filled Circle"]
    B3 --> n2["Filled Circle"]
    B4 --> n3["Filled Circle"]
    B5 --> n4["Filled Circle"]

    n1@{ shape: f-circ}
    n2@{ shape: f-circ}
    n3@{ shape: f-circ}
    n4@{ shape: f-circ}
    style A1 fill:#fff
    style A2 fill:#fff
    style A3 fill:#fff
    style A9 fill:#fff
```

## Tabela de Dispers√£o Din√¢mica

Imagine que voc√™ possui um pequeno m√≥vel com quatro compartimentos:

- No compartimento 1, voc√™ guarda um rel√≥gio **Ferrari**.
- No compartimento 2, um rel√≥gio **Casio**.
- No compartimento 3, um rel√≥gio **Xing-ling**.

Com o tempo, voc√™ percebe que o m√≥vel est√° ficando cheio e decide comprar um novo m√≥vel com o dobro do tamanho, para ter mais espa√ßo e organiza√ß√£o.

No novo m√≥vel, os rel√≥gios podem ficar em posi√ß√µes diferentes, por exemplo, o Ferrari agora pode ser guardado no compartimento 6. Al√©m disso, voc√™ adquire um novo rel√≥gio **Rolex** e o coloca no compartimento 5.

Mais tarde, voc√™ decide presentear seu melhor amigo com o rel√≥gio **Xing-ling** e vender o **Casio**. Para completar, um dos rel√≥gios acaba sendo roubado. Agora, dos oito compartimentos, apenas um est√° ocupado. Um grande desperd√≠cio de espa√ßo.

Diante disso, voc√™ decide trocar novamente de m√≥vel, voltando a um modelo menor, com quatro compartimentos, mais adequado √† sua nova cole√ß√£o.

Esse comportamento de aumentar ou diminuir o n√∫mero de compartimentos conforme a quantidade de itens √© exatamente o que ocorre em uma tabela hash din√¢mica.

Em resumo, ela funciona como um "guarda-roupa inteligente" que se adapta automaticamente:

- Expande (aumenta) quando est√° ficando cheia, evitando que as "gavetas" fiquem apertadas (muitas colis√µes).
- Contrai (diminui) quando est√° quase vazia, economizando espa√ßo e mem√≥ria.

Essa capacidade de ajustar dinamicamente o tamanho permite que a tabela hash mantenha alto desempenho e uso eficiente de mem√≥ria, independentemente do n√∫mero de elementos armazenados.

### Fator de Carga

O fator de carga (load factor) determina quando uma tabela hash deve ser expandida ou contra√≠da.
Ele √© definido como a raz√£o entre o n√∫mero de elementos armazenados e o n√∫mero total de buckets (ou posi√ß√µes dispon√≠veis na tabela):
$$\lambda = \frac{n}{m}$$
onde $n$ √© o n√∫mero de itens atualmente armazenados e $m$ o tamanho da tabela.


O desempenho ideal de uma tabela hash depende de duas condi√ß√µes principais:

- uma fun√ß√£o hash eficiente, que distribua os elementos de forma uniforme;
- um fator de carga baixo, que mantenha o n√∫mero de colis√µes sob controle.

Se o fator de carga $\lambda$ for muito alto, o n√∫mero de colis√µes tende a crescer, e as opera√ß√µes de busca, inser√ß√£o e remo√ß√£o podem degradar de O(1) para O(n). Por outro lado, se $\lambda$ for muito baixo, haver√° desperd√≠cio de espa√ßo, pois a tabela ficar√° com muitos buckets vazios.

O cora√ß√£o de uma tabela hash din√¢mica √© justamente o processo de redimensionamento, que ajusta o tamanho da tabela conforme o fator de carga ultrapassa (ou cai abaixo de) determinados limites predefinidos. Por exemplo,

- expans√£o: quando $\lambda>0.7$ ou  $\lambda>0.75$;
- contra√ß√£o: quando $\lambda<0.25$.


O processo de redimensionamento normalmente envolve tr√™s etapas principais:


- **Cria√ß√£o de uma nova tabela**: Uma nova tabela √© alocada, geralmente com o dobro (em caso de expans√£o) ou metade (em caso de contra√ß√£o) do tamanho atual.
- **Re-hashing dos elementos**: Todos os elementos da tabela antiga s√£o reprocessados por uma nova fun√ß√£o hash e inseridos na nova tabela, agora com √≠ndices recalculados conforme o novo tamanho.
- **Substitui√ß√£o**: A tabela antiga √© descartada, e a nova tabela passa a ser usada nas pr√≥ximas opera√ß√µes de inser√ß√£o, busca e remo√ß√£o.

Finalmente, podemos citar como vantagens e desvantagens da tabela hash din√¢mica:

::: {.panel-tabset}

## Vantagens

- **Otimiza√ß√£o do espa√ßo**: A tabela se ajusta √† quantidade de dados, evitando
desperd√≠cio de mem√≥ria quando h√° poucos itens e garantindo espa√ßo
suficiente para muitos itens.
- **Desempenho consistente**: Ajuda a manter o fator de carga em n√≠veis √≥timos,
garantindo que as opera√ß√µes de O(1) sejam mantidas na m√©dia.
- **Facilidade de uso**: O desenvolvedor n√£o precisa se preocupar em prever o
tamanho da tabela, simplificando o desenvolvimento.

## Desvantagens

- **Custo do redimensionamento**: A opera√ß√£o de redimensionamento pode ser
custosa, pois envolve a cria√ß√£o de uma nova tabela e o re-hashing de todos os
elementos. Isso pode levar a picos de lat√™ncia inesperados.
- **Complexidade de implementa√ß√£o**: √â mais complexa de implementar do que
uma tabela hash est√°tica.
- **Cache ineficiente durante redimensionamento**: Durante o re-hashing, os
dados podem se espalhar por novas posi√ß√µes de mem√≥ria, o que pode impactar
o desempenho do cache da CPU temporariamente.
:::




