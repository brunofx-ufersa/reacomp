---
title: "Lista Gen√©rica"
lang: pt
toc-title: Conte√∫do
toc: false
sidebar: false
format:
  html:
    reference-location: margin
    css: ../styles/academic.css
---

Nesta unidade, iremos implementar uma lista gen√©rica. As fun√ß√µes de _callback_ ser√£o armazenadas no construtor da lista, dando um toque mais profissional para nosso programa.
 

## Interface

```{.c filename=list.h}
#include <stdbool.h>
#include <stddef.h>

typedef void(*cb_free)(void *);
typedef int(*cb_compare)(void *a, void *b);

typedef struct node {
    void* data;          // Ponteiro gen√©rico para o dado
    struct node* next;
} Node;

typedef struct {
    site_t data_size;
	Node *head;	
    // Fun√ß√µes de callback para o tipo de dado
    cb_free free_data;
    cb_compare compare_data;
} List;


List* list_create (size_t data_size, cb_free free_data, cb_compare compare_data);
void list_destroy (List *list);
void list_add (List *list, void *data);
bool list_contains (List *list, void *data);
```

Nossa lista √© bastante simples. Cada n√≥ possui um dado e um ponteiro para o pr√≥ximo n√≥. J√° a estrutura lista √© composta pelo tamanho do dado, um ponteiro para a cabe√ßa da lista e duas fun√ß√µes de _callback_. As fun√ß√µes declaradas ser√£o usadas para criar uma lista, liberar a mem√≥ria da lista, adicionar um novo n√≥ e determinar se um n√≥ pertence a uma lista.

## Implementa√ß√£o

Importando as bibliotecas.

```{.c filename=list.c}
#include "list.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
```

### Criar Lista

A primeira fun√ß√£o que iremos implementar √© o construtor da lista, `list_create`. O primeiro param√™tro √© o tamanho em _bytes_ do dado que iremos armazenar na lista. Depois as fun√ß√µes de _callback_ para liberar a mem√≥ria desse dado e como comparar dois dados.


```{.c filename=list.c}
List *list_create(size_t data_size, cb_free free_data, cb_compare compare_data) {
	assert(data_size > 0);	

	List *list = malloc(sizeof(List));
	list->data_size = data_size;
	list->head = NULL;
	list->free_data = free_data;
	list->compare_data = compare_data;
	return list;
}
```

Como a lista inicia vazia, logo a cabe√ßa da lista ser√° `NULL`. 

### Adicionar Elementos

Ap√≥s criar a lista, temos de adicionar n√≥s a ela. A fun√ß√£o `list_add` aloca mem√≥ria duas vezes, uma para o n√≥ e outra para o dado. N√£o podemos fazer um simples atribui√ß√£o com `=` para passar o dado para o campo `data` do n√≥. Portanto, usamos a fun√ß√£o `memcpy` que estudamos na se√ß√£o sobre [gerenciamento de mem√≥ria](3-memoria.qmd#sec-man).


```{.c filename=list.c}
void list_add(List *list, void *data) {
    assert(list != NULL);
    assert(data != NULL);

    Node *newNode = calloc(1, sizeof(Node));
    newNode->data = malloc(list->data_size);
    memcpy(newNode->data, data, list->data_size);

    newNode->next = list->head;
    list->head = newNode;
}
```

Essa fun√ß√£o adiciona elementos na cabe√ßa da lista: o novo n√≥ aponta para a cabe√ßa da lista (linha 9) e depois a cabe√ßa da lista √© atualizada para o novo n√≥ (linha 10).

### Apagar Lista

Precisamos criar o destrutor da lista. Mas antes temos de implementar a `free_node_data`. Ela serve para liberar a mem√≥ria 
alocada para o dado que √© armazenado na lista. Esse dado pode ser mais complexo do que pensamos (algum `struct` com aloca√ß√£o interna). Por isso, passamos um fun√ß√£o _callback_ para tratar esses casos. Por outro lado, para uma lista de inteiros ou outro tipo simples, um `free` √© suficiente.

```{.c filename=list.c}
static void free_node_data(cb_free free_data, void *data) { 
	if (free_data != NULL) 
		free_data(data); 
	else 
		free(data); 
}
```

Mote que essa fun√ß√£o n√£o foi declarada no arquivo `.h` e isso significa que ela √© privada. O modificador `static` indica isso para n√≥s.

A l√≥gica do destrutor √© simples. Ap√≥s a verifica√ß√£o de seguran√ßa do `assert`, criamos um n√≥ que aponta para a cabe√ßa da lista. Em seguida, caminhamos na lista em dire√ß√£o a cauda. Nesse percurso, liberamos a mem√≥ria do dado e depois do n√≥. Quando acabamos o percurso, liberaramos a estrutura lista.

```{.c filename=list.c}
void list_destroy(List *list){
	assert(list != NULL);
	
	Node *node = list->head;
		
	while (node != NULL){
		Node *next = node->next; // guarda o pr√≥ximo antes de liberar
		free_node_data(list->free_data, node->data);
		free(node);
		node = next;
	}

	free(list);
}
```

Note que usamos tr√™s libera√ß√µes de mem√≥ria. Uma para o dado (linha 8), uma para o n√≥ (linha 9) e outra para a lista (linha 13). Isso porque usamos a aloca√ß√£o de mem√≥ria tr√™s vezes, uma em `list_create` e duas em `list_add`. Lembre-se do que estudamos, para cada aloca√ß√£o deve haver um libera√ß√£o correspondente.

### Procurar Elementos

Uma das fun√ß√µes que declaramos em nossa interface foi `list_contains`. Ela ser√° usada para saber se algum elemento existe dentro da lista. Ela s√≥ retorna sim ou n√£o.

```{.c filename=list.c}
bool list_contains(List *list, void *data) {
	assert(list->compare_data != NULL);
	
	Node *node = list->head;
	while (node != NULL)	{
		if (list->compare_data(node->data, data) == 0)
			return true;		
		node = node->next;
	}
	return false;
}
```

::: {.column-margin}
**[Se liga!]{.text-warning}**
√â uma boa pr√°tica implementar a fun√ß√£o de compara√ß√£o da seguinte forma:

- Se a < b, retorne um n√∫mero negativo
- Se a = b, retorne zero
- Se a > b, retorne um n√∫mero positivo
:::

Note que para tipos primitivos, como inteiros, a igualdade √© simples (`a == b`). Contudo, nossa lista armazena dados de forma gen√©rica (`void *data`), o que significa que o operador `==` s√≥ compararia os endere√ßos de mem√≥ria dos dados, e n√£o o seu conte√∫do l√≥gico. Por isso, o _callback_ `compare_data` √© essencial: ele permite que o usu√°rio defina a l√≥gica de compara√ß√£o correta para tipos complexos, como um `struct` de aluno (onde a igualdade pode depender, por exemplo, do ID ou Matr√≠cula).

## Exemplo de Uso

Importando as bibliotecas e API da lista que criamos.

```{.c filename=int_list.c}
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include "list.h" 
```

Fun√ß√£o de _callback_ para comparar dois inteiros.

```{.c filename=int_list.c}
// Callback para comparar dois inteiros
int compare_int(void *a, void *b) {
    int x = *(int*)a;
    int y = *(int*)b;
    return x - y;
}
```
::: {.column-margin}
**[Se liga!]{.text-warning}**
N√£o vamos precisar de um fun√ß√£o _callback_ para liberar um inteiro, pois nossa fun√ß√£o `free_node_data` j√° trata esse caso se passarmos `NULL` como argumento para `list_create`. 
:::

Lembre-se, o padr√£o √© que retorne zero se ambos s√£o iguais. 

Fun√ß√£o principal:


```{.c filename=int_list.c}
int main() {

    // Criar uma lista de inteiros
    List *list = list_create(sizeof(int), NULL, compare_int);
    int item[5] = {2, 5, 3, 8, 9};
 
    // Adicionar elementos
    for (int i = 0; i < 5; i++) {
        int *data = malloc(sizeof(int));
        *data = item[i];
        list_add(list, data);
        free(data);
    }

    // Verificar se um valor est√° na lista
    int search_key = 8;
    
    printf("Procurando n√≥ com chave: %d...\n", search_key);
    
    if (list_contains(list, &search_key))
        printf("-> Sucesso: Chave %d encontrada!\n", search_key);
    else 
        printf("-> Falha: Chave %d n√£o encontrada.\n", search_key);
    
    printf("----------------------------------------\n");

    
    // Destruir a lista    
    list_destroy(list);
    list = NULL;

    return 0;
}
```

Para demonstrar o poder da nossa lista gen√©rica, vamos criar uma lista de anulos, onde cada aluno √© uma `struct`.

```{.c filename=student_list.c}
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include "list.h" 

typedef struct student {
    char* name;
    int id;
} Student;

int compare_student(void *a, void *b) {
    Student *student_a = (Student *)a;
    Student *student_b = (Student *)b;

    return student_a->id - student_b->id;
}

void free_student(void *data) {
    Student *student_ptr = (Student *)data;
    
    if (student_ptr == NULL) 
        return; 
    
    if (student_ptr->name != NULL) 
        free(student_ptr->name); 
    
    free(student_ptr);
}
```

Fun√ß√£o auxiliar para criar um aluno.

```{.c filename=student_list.c}
Student *create_student(const char *name, int id) {
    Student *new_student = (Student *)malloc(sizeof(Student));
    if (new_student == NULL) {
        fprintf(stderr, "Erro ao alocar Student\n");
        return 1; 
    }

    new_student->id = id;
    
    // strdup faz o malloc interno e a c√≥pia.
    new_student->name = strdup(name); 
    if (new_student->name == NULL) {
        free(new_student); // Limpeza em caso de falha de aloca√ß√£o do nome
        fprintf(stderr, "Erro ao alocar nome\n");
        return 1; 
    }

    return new_student;
}
```
::: {.column-margin}
**[Se liga!]{.text-warning}**
Internamente, `strdup` faz:

- `char *new_name = malloc(strlen(name) + 1);` 
- `strcpy(new_name, name);`

Note que o `free` correspondente ao `malloc` de `strdup` est√° no _callback_ `free_student`, no segundo `if`.
:::

Agora estamos prontos para simular uma lista de alunos.

```{.c filename=student_list.c}
int main() {

    // Criar um  lista de alunos
    List *list = list_create(sizeof(Student), free_student, compare_student);

    // Nomes e IDs
    const char *names[] = {"Alice", "Bob", "Charlie", "Diana"};
    int ids[] = {101, 205, 303, 408};

    // Adicionar elementos
    for (int i = 0; i < 4; i++) {
        Student *s = create_student(names[i], ids[i]);
        list_add(list, s); 
    }
   
    // Verificar se um aluno est√° na lista
    Student search_key = {.name = NULL, .id = 303}; 
    
    printf("Procurando aluno com ID: %d...\n", search_key.id);
    
    if (list_contains(list, &search_key)) 
        printf("-> Sucesso: Aluno ID %d encontrado!\n", search_key.id);
    else
        printf("-> Falha: Aluno ID %d n√£o encontrado.\n", search_key.id);
    
    printf("----------------------------------------\n");

    // Destruir a lista
    list_destroy(list); 
    list = NULL;

    return 0;
}
```

A implementa√ß√£o desta lista gen√©rica garante alta modularidade. Gra√ßas ao design baseado em fun√ß√µes _callback_, evitamos a reimplementa√ß√£o de fun√ß√µes centrais (como cria√ß√£o, adi√ß√£o ou destrui√ß√£o). Para adaptar a lista a qualquer novo tipo de dado, basta fornecer os _callbacks_ espec√≠ficos para a compara√ß√£o e libera√ß√£o de mem√≥ria daquele tipo.

::: {.callout-note icon="false" title="üéØ Desafio de C√≥digo"}
Defina uma nova assinatura para um fun√ß√£o _callback_ chamada `cb_iterate` e adicione a declara√ß√£o da fun√ß√£o `list_iterate` no arquivo de cabe√ßalho (`list.h`).

```{.c code-line-numbers="false"}
typedef bool(*cb_iterate)(int index, void *data);
void list_iterate(LinkedList *list, cb_iterate iterate_callback);
```

Depois, na implementa√ß√£o (`list.c`) escreva a o c√≥digo para essa fun√ß√£o.

```{.c code-line-numbers="false"}
void list_iterate(LinkedList *list, cb_iterate iterate_callback) {
	assert(list != NULL);
    assert(iterate_callback != NULL);

    Node *current = list->head;  
    int index = 0;               

    // Enquanto ainda houver n√≥s para visitar
    while (current != NULL) {
        // Chamamos a fun√ß√£o de callback para o n√≥ atual.
        bool continuar = iterate_callback(index, current->data);

        // Se a fun√ß√£o de callback retornar 'false', paramos a itera√ß√£o
        if (!continuar) break;

        // Avan√ßamos para o pr√≥ximo n√≥
        current = current->next;
        index++;
    }
}
```

Implemente uma fun√ßao _callback_ para imprimir a lista de inteiros. Ela deve ter a mesma assinatura de `cb_iterate`:

```{.c code-line-numbers="false"}
bool print_int(int index, void *data);
```

Exemplo de uso:

```{.c code-line-numbers="false"}
printf("Conte√∫do da lista:\n");
list_iterate(list, print_int);
```

:::


::: {.callout-tip title="Solu√ß√£o (clique para ver)" collapse="true"}
```{.c code-line-numbers="false"}
// Callback para iterar e imprimir
bool print_int(int index, void *data) {
    int value = *(int*)data;
    printf("[%d]: %d\n", index, value);
    return true; // continuar a itera√ß√£o
}
```

:::


## Conclus√£o

Com a lista gen√©rica implementada, conclu√≠mos com sucesso a explora√ß√£o de um dos temas mais poderosos em programa√ß√£o C: o design de estruturas de dados independentes de tipo.

O verdadeiro valor deste exerc√≠cio n√£o est√° apenas no c√≥digo da lista, mas nos conceitos transfer√≠veis que voc√™ aprendeu. A utiliza√ß√£o estrat√©gica de ponteiros para fun√ß√µes (_callbacks_) e a rigorosa gest√£o da mem√≥ria via Heap s√£o os pilares que sustentam a cria√ß√£o de qualquer estrutura avan√ßada. Voc√™ agora tem o conhecimento necess√°rio para replicar essa arquitetura em pilhas, filas, √°rvores gen√©ricas e al√©m.

Este trabalho estabelece a base para o desenvolvimento profissional, alinhando seu c√≥digo com os padr√µes utilizados nas bibliotecas de software de c√≥digo aberto mais robustas. Voc√™ n√£o apenas criou uma lista; voc√™ adquiriu um modelo de design para resolver problemas complexos com eleg√¢ncia.