---
title: "Lista Gen√©rica"
lang: pt
toc-title: Conte√∫do
toc: false
sidebar: false
format:
  html:
    reference-location: margin
    css: ../styles/academic.css
filters: 
    - quizdown
---

Nesta unidade, iremos implementar uma lista gen√©rica. As fun√ß√µes de _callback_ ser√£o armazenadas no construtor da lista, dando um toque mais profissional para nosso programa.
 

## Interface

```{.c filename=list.h}
#include <stdbool.h>
#include <stddef.h>

typedef void(*cb_free)(void *);
typedef int(*cb_compare)(void *a, void *b);

typedef struct node {
    void* data;          // Ponteiro gen√©rico para o dado
    struct node* next;
} Node;

typedef struct {
    site_t data_size;
	Node *head;	
    // Fun√ß√µes de callback para o tipo de dado
    cb_free free_data;
    cb_compare compare_data;
} List;


List* list_create (size_t data_size, cb_free free_data, cb_compare compare_data);
void list_destroy (List *list);
void list_add (List *list, void *data);
bool list_contains (List *list, void *data);
```

Nossa lista √© bastante simples. Cada n√≥ possui um dado e um ponteiro para o pr√≥ximo n√≥. J√° a estrutura lista √© composta pelo tamanho do dado, um ponteiro para a cabe√ßa da lista e duas fun√ß√µes de _callback_. As fun√ß√µes declaradas ser√£o usadas para criar uma lista, liberar a mem√≥ria da lista, adicionar um novo n√≥ e determinar se um n√≥ pertence a uma lista.

## Implementa√ß√£o

Importando as bibliotecas.

```{.c filename=list.c}
#include "list.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
```

### Criar Lista

A primeira fun√ß√£o que iremos implementar √© o construtor da lista, `list_create`. O primeiro param√™tro √© o tamanho em _bytes_ do dado que iremos armazenar na lista. Depois as fun√ß√µes de _callback_ para liberar a mem√≥ria desse dado e como comparar dois dados.


```{.c filename=list.c}
List *list_create(size_t data_size, cb_free free_data, cb_compare compare_data) {
	assert(data_size > 0);	

	List *list = malloc(sizeof(List));
	list->data_size = data_size;
	list->head = NULL;
	list->free_data = free_data;
	list->compare_data = compare_data;
	return list;
}
```

Como a lista inicia vazia, logo a cabe√ßa da lista ser√° `NULL`. 

### Adicionar Elementos

Ap√≥s criar a lista, temos de adicionar n√≥s a ela. A fun√ß√£o `list_add` aloca mem√≥ria duas vezes, uma para o n√≥ e outra para o dado. N√£o podemos fazer um simples atribui√ß√£o com `=` para passar o dado para o campo `data` do n√≥. Portanto, usamos a fun√ß√£o `memcpy` que estudamos na se√ß√£o sobre [gerenciamento de mem√≥ria](3-memoria.qmd#sec-man).


```{.c filename=list.c}
void list_add(List *list, void *data) {
    assert(list != NULL);
    assert(data != NULL);

    Node *newNode = calloc(1, sizeof(Node));
    newNode->data = malloc(list->data_size);
    memcpy(newNode->data, data, list->data_size);

    newNode->next = list->head;
    list->head = newNode;
}
```

Essa fun√ß√£o adiciona elementos na cabe√ßa da lista: o novo n√≥ aponta para a cabe√ßa da lista (linha 9) e depois a cabe√ßa da lista √© atualizada para o novo n√≥ (linha 10).

### Apagar Lista

Precisamos criar o destrutor da lista. Mas antes temos de implementar a `free_node_data`. Ela serve para liberar a mem√≥ria 
alocada para o dado que √© armazenado na lista. Esse dado pode ser mais complexo do que pensamos (algum `struct` com aloca√ß√£o interna). Por isso, passamos um fun√ß√£o _callback_ para tratar esses casos. Por outro lado, para uma lista de inteiros ou outro tipo simples, um `free` √© suficiente.

```{.c filename=list.c}
static void free_node_data(cb_free free_data, void *data) { 
	if (free_data != NULL) 
		free_data(data); 
	else 
		free(data); 
}
```

Mote que essa fun√ß√£o n√£o foi declarada no arquivo `.h` e isso significa que ela √© privada. O modificador `static` indica isso para n√≥s.

A l√≥gica do destrutor √© simples. Ap√≥s a verifica√ß√£o de seguran√ßa do `assert`, criamos um n√≥ que aponta para a cabe√ßa da lista. Em seguida, caminhamos na lista em dire√ß√£o a cauda. Nesse percurso, liberamos a mem√≥ria do dado e depois do n√≥. Quando acabamos o percurso, liberaramos a estrutura lista.

```{.c filename=list.c}
void list_destroy(List *list){
	assert(list != NULL);
	
	Node *node = list->head;
		
	while (node != NULL){
		Node *next = node->next; // guarda o pr√≥ximo antes de liberar
		free_node_data(list->free_data, node->data);
		free(node);
		node = next;
	}

	free(list);
}
```

Note que usamos tr√™s libera√ß√µes de mem√≥ria. Uma para o dado (linha 8), uma para o n√≥ (linha 9) e outra para a lista (linha 13). Isso porque usamos a aloca√ß√£o de mem√≥ria tr√™s vezes, uma em `list_create` e duas em `list_add`. Lembre-se do que estudamos, para cada aloca√ß√£o deve haver um libera√ß√£o correspondente.

### Procurar Elementos

Uma das fun√ß√µes que declaramos em nossa interface foi `list_contains`. Ela ser√° usada para saber se algum elemento existe dentro da lista. Ela s√≥ retorna sim ou n√£o.

```{.c filename=list.c}
bool list_contains(List *list, void *data) {
	assert(list->compare_data != NULL);
	
	Node *node = list->head;
	while (node != NULL)	{
		if (list->compare_data(node->data, data) == 0)
			return true;		
		node = node->next;
	}
	return false;
}
```

::: {.column-margin}
**[Se liga!]{.text-warning}**
√â uma boa pr√°tica implementar a fun√ß√£o de compara√ß√£o da seguinte forma:

- Se a < b, retorne um n√∫mero negativo
- Se a = b, retorne zero
- Se a > b, retorne um n√∫mero positivo
:::

Note que para tipos primitivos, como inteiros, a igualdade √© simples (`a == b`). Contudo, nossa lista armazena dados de forma gen√©rica (`void *data`), o que significa que o operador `==` s√≥ compararia os endere√ßos de mem√≥ria dos dados, e n√£o o seu conte√∫do l√≥gico. Por isso, o _callback_ `compare_data` √© essencial: ele permite que o usu√°rio defina a l√≥gica de compara√ß√£o correta para tipos complexos, como um `struct` de aluno (onde a igualdade pode depender, por exemplo, do ID ou Matr√≠cula).

## Exemplo de Uso

Importando as bibliotecas e API da lista que criamos.

```{.c filename=int_list.c}
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include "list.h" 
```

Fun√ß√£o de _callback_ para comparar dois inteiros.

```{.c filename=int_list.c}
// Callback para comparar dois inteiros
int compare_int(void *a, void *b) {
    int x = *(int*)a;
    int y = *(int*)b;
    return x - y;
}
```
::: {.column-margin}
**[Se liga!]{.text-warning}**
N√£o vamos precisar de um fun√ß√£o _callback_ para liberar um inteiro, pois nossa fun√ß√£o `free_node_data` j√° trata esse caso se passarmos `NULL` como argumento para `list_create`. 
:::

Lembre-se, o padr√£o √© que retorne zero se ambos s√£o iguais. 

Fun√ß√£o principal:


```{.c filename=int_list.c}
int main() {

    // Criar uma lista de inteiros
    List *list = list_create(sizeof(int), NULL, compare_int);
    int item[5] = {2, 5, 3, 8, 9};
 
    // Adicionar elementos
    for (int i = 0; i < 5; i++) {
        int *data = malloc(sizeof(int));
        *data = item[i];
        list_add(list, data);
        free(data);
    }

    // Verificar se um valor est√° na lista
    int search_key = 8;
    
    printf("Procurando n√≥ com chave: %d...\n", search_key);
    
    if (list_contains(list, &search_key))
        printf("-> Sucesso: Chave %d encontrada!\n", search_key);
    else 
        printf("-> Falha: Chave %d n√£o encontrada.\n", search_key);
    
    printf("----------------------------------------\n");

    
    // Destruir a lista    
    list_destroy(list);
    list = NULL;

    return 0;
}
```

Para demonstrar o poder da nossa lista gen√©rica, vamos criar uma lista de anulos, onde cada aluno √© uma `struct`.

```{.c filename=student_list.c}
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include "list.h" 

typedef struct student {
    char* name;
    int id;
} Student;

int compare_student(void *a, void *b) {
    Student *student_a = (Student *)a;
    Student *student_b = (Student *)b;

    return student_a->id - student_b->id;
}

void free_student(void *data) {
    Student *student_ptr = (Student *)data;
    
    if (student_ptr == NULL) 
        return; 
    
    if (student_ptr->name != NULL) 
        free(student_ptr->name); 
    
    free(student_ptr);
}
```

Fun√ß√£o auxiliar para criar um aluno.

```{.c filename=student_list.c}
Student *create_student(const char *name, int id) {
    Student *new_student = (Student *)malloc(sizeof(Student));
    if (new_student == NULL) {
        fprintf(stderr, "Erro ao alocar Student\n");
        return 1; 
    }

    new_student->id = id;
    
    // strdup faz o malloc interno e a c√≥pia.
    new_student->name = strdup(name); 
    if (new_student->name == NULL) {
        free(new_student); // Limpeza em caso de falha de aloca√ß√£o do nome
        fprintf(stderr, "Erro ao alocar nome\n");
        return 1; 
    }

    return new_student;
}
```
::: {.column-margin}
**[Se liga!]{.text-warning}**
Internamente, `strdup` faz:

- `char *new_name = malloc(strlen(name) + 1);` 
- `strcpy(new_name, name);`

Note que o `free` correspondente ao `malloc` de `strdup` est√° no _callback_ `free_student`, no segundo `if`.
:::

Agora estamos prontos para simular uma lista de alunos.

```{.c filename=student_list.c}
int main() {

    // Criar um  lista de alunos
    List *list = list_create(sizeof(Student), free_student, compare_student);

    // Nomes e IDs
    const char *names[] = {"Alice", "Bob", "Charlie", "Diana"};
    int ids[] = {101, 205, 303, 408};

    // Adicionar elementos
    for (int i = 0; i < 4; i++) {
        Student *s = create_student(names[i], ids[i]);
        list_add(list, s); 
    }
   
    // Verificar se um aluno est√° na lista
    Student search_key = {.name = NULL, .id = 303}; 
    
    printf("Procurando aluno com ID: %d...\n", search_key.id);
    
    if (list_contains(list, &search_key)) 
        printf("-> Sucesso: Aluno ID %d encontrado!\n", search_key.id);
    else
        printf("-> Falha: Aluno ID %d n√£o encontrado.\n", search_key.id);
    
    printf("----------------------------------------\n");

    // Destruir a lista
    list_destroy(list); 
    list = NULL;

    return 0;
}
```

A implementa√ß√£o desta lista gen√©rica garante alta modularidade. Gra√ßas ao design baseado em fun√ß√µes _callback_, evitamos a reimplementa√ß√£o de fun√ß√µes centrais (como cria√ß√£o, adi√ß√£o ou destrui√ß√£o). Para adaptar a lista a qualquer novo tipo de dado, basta fornecer os _callbacks_ espec√≠ficos para a compara√ß√£o e libera√ß√£o de mem√≥ria daquele tipo.

::: {.callout-note icon="false" title="üéØ Desafio de C√≥digo"}
Defina uma nova assinatura para um fun√ß√£o _callback_ chamada `cb_iterate` e adicione a declara√ß√£o da fun√ß√£o `list_iterate` no arquivo de cabe√ßalho (`list.h`).

```{.c code-line-numbers="false"}
typedef bool(*cb_iterate)(int index, void *data);
void list_iterate(LinkedList *list, cb_iterate iterate_callback);
```

Depois, na implementa√ß√£o (`list.c`) escreva a o c√≥digo para essa fun√ß√£o.

```{.c code-line-numbers="false"}
void list_iterate(LinkedList *list, cb_iterate iterate_callback) {
	assert(list != NULL);
    assert(iterate_callback != NULL);

    Node *current = list->head;  
    int index = 0;               

    // Enquanto ainda houver n√≥s para visitar
    while (current != NULL) {
        // Chamamos a fun√ß√£o de callback para o n√≥ atual.
        bool continuar = iterate_callback(index, current->data);

        // Se a fun√ß√£o de callback retornar 'false', paramos a itera√ß√£o
        if (!continuar) break;

        // Avan√ßamos para o pr√≥ximo n√≥
        current = current->next;
        index++;
    }
}
```

Implemente uma fun√ßao _callback_ para imprimir a lista de inteiros. Ela deve ter a mesma assinatura de `cb_iterate`:

```{.c code-line-numbers="false"}
bool print_int(int index, void *data);
```

Exemplo de uso:

```{.c code-line-numbers="false"}
printf("Conte√∫do da lista:\n");
list_iterate(list, print_int);
```

:::


::: {.callout-tip title="Solu√ß√£o (clique para ver)" collapse="true"}
```{.c code-line-numbers="false"}
// Callback para iterar e imprimir
bool print_int(int index, void *data) {
    int value = *(int*)data;
    printf("[%d]: %d\n", index, value);
    return true; // continuar a itera√ß√£o
}
```

:::


## Conclus√£o

Com a lista gen√©rica implementada, conclu√≠mos com sucesso a explora√ß√£o de um dos temas mais poderosos em programa√ß√£o C: o design de estruturas de dados independentes de tipo.

O verdadeiro valor deste exerc√≠cio n√£o est√° apenas no c√≥digo da lista, mas nos conceitos transfer√≠veis que voc√™ aprendeu. A utiliza√ß√£o estrat√©gica de ponteiros para fun√ß√µes (_callbacks_) e a rigorosa gest√£o da mem√≥ria via Heap s√£o os pilares que sustentam a cria√ß√£o de qualquer estrutura avan√ßada. Voc√™ agora tem o conhecimento necess√°rio para replicar essa arquitetura em pilhas, filas, √°rvores gen√©ricas e al√©m.

Este trabalho estabelece a base para o desenvolvimento profissional, alinhando seu c√≥digo com os padr√µes utilizados nas bibliotecas de software de c√≥digo aberto mais robustas. Voc√™ n√£o apenas criou uma lista; voc√™ adquiriu um modelo de design para resolver problemas complexos com eleg√¢ncia.

---

Nesta unidade, voc√™ aprendeu

‚úÖ a criar uma lista ligada gen√©rica simples


```quizdown 
# Qual √© o principal objetivo da estrutura `List` apresentada?

> Pense na abstra√ß√£o que ela representa.

1. [ ] Armazenar apenas inteiros de forma sequencial.
1. [x] Permitir o armazenamento de dados gen√©ricos com callbacks para opera√ß√µes espec√≠ficas.
1. [ ] Substituir arrays fixos por vetores din√¢micos.
1. [ ] Gerenciar automaticamente a mem√≥ria da heap sem interven√ß√£o do usu√°rio.


# Qual √© a fun√ß√£o do campo `data_size` dentro da estrutura `List`?

> Ele √© essencial para manipular dados gen√©ricos.

1. [x] Indicar o tamanho em bytes do tipo de dado armazenado.
1. [ ] Controlar o n√∫mero total de n√≥s da lista.
1. [ ] Identificar o tipo de dado armazenado (inteiro, float etc.).
1. [ ] Servir como √≠ndice de posi√ß√£o atual na lista.


# Qual √© a principal diferen√ßa entre o campo `free_data` e a fun√ß√£o `free` padr√£o?

> Observe o papel do callback no gerenciamento de mem√≥ria.

1. [x] `free_data` permite liberar dados complexos com l√≥gica personalizada.
1. [ ] `free_data` √© usada apenas para liberar a estrutura `List`.
1. [ ] `free_data` substitui a fun√ß√£o `malloc`.
1. [ ] N√£o h√° diferen√ßa ‚Äî ambas fazem exatamente a mesma coisa.


# No contexto da fun√ß√£o `list_add`, por que √© necess√°rio usar `memcpy`?

> Lembre-se de que `data` √© um ponteiro gen√©rico.

1. [x] Para copiar o conte√∫do do dado em vez do endere√ßo.
1. [ ] Para liberar a mem√≥ria de origem ap√≥s a c√≥pia.
1. [ ] Porque `malloc` n√£o inicializa a mem√≥ria corretamente.
1. [ ] Para evitar que o ponteiro `data` fique nulo.


# Quais afirma√ß√µes sobre a fun√ß√£o `list_create` est√£o corretas?

> Considere os par√¢metros e suas fun√ß√µes.

- [x] Recebe o tamanho do dado a ser armazenado.
- [x] Recebe ponteiros de fun√ß√£o para liberar e comparar dados.
- [ ] Aloca apenas o n√≥ inicial da lista.
- [ ] Cria automaticamente um primeiro elemento.


# Quais s√£o os tr√™s tipos de aloca√ß√£o de mem√≥ria usados ao longo da implementa√ß√£o?

> Pense no ciclo completo da lista.

- [x] Aloca√ß√£o para a estrutura `List`.
- [x] Aloca√ß√£o para cada `Node`.
- [x] Aloca√ß√£o para o campo `data` em cada n√≥.
- [ ] Aloca√ß√£o para cada chamada de compara√ß√£o.


# Coloque em ordem as etapas da fun√ß√£o `list_destroy`.

> Ela percorre e libera a lista corretamente.

1. Criar um ponteiro auxiliar para o n√≥ inicial.
2. Guardar o pr√≥ximo n√≥ antes de liberar o atual.
3. Liberar o dado interno com `free_node_data`.
4. Liberar o n√≥ atual.
5. Repetir at√© o final e liberar a estrutura `List`.


# Por que `compare_data` √© necess√°rio em uma lista gen√©rica?

> Ele garante a compara√ß√£o l√≥gica correta dos dados.

1. [x] Porque `==` apenas compara endere√ßos de mem√≥ria.
1. [ ] Porque ele substitui o operador `sizeof`.
1. [ ] Porque o compilador n√£o aceita compara√ß√£o de `void *`.
1. [ ] Porque ele √© obrigat√≥rio para listas de inteiros.


# Em rela√ß√£o ao uso de `assert`, assinale as op√ß√µes verdadeiras.

> Elas s√£o fundamentais para seguran√ßa em C.

- [x] Garante que ponteiros n√£o sejam nulos antes do uso.
- [x] √â usada para detectar falhas de pr√©-condi√ß√£o em tempo de execu√ß√£o.
- [ ] √â um comando que substitui `if`.
- [ ] Impede o programa de compilar se a condi√ß√£o for falsa.


# Quais pr√°ticas s√£o adequadas ao manipular listas gen√©ricas?

> Pense em modularidade e seguran√ßa.

- [x] Passar callbacks apropriados para cada tipo de dado.
- [x] Liberar todos os recursos com `list_destroy` ap√≥s o uso.
- [ ] Usar o operador `==` diretamente em ponteiros `void *`.
- [ ] Atribuir dados com `=` sem `memcpy`.


# Coloque na ordem correta as etapas executadas pela fun√ß√£o `list_add`.

> Ela insere o elemento na cabe√ßa da lista.

1. Criar um novo n√≥ com `calloc`.
2. Alocar mem√≥ria para o campo `data`.
3. Copiar o conte√∫do do dado com `memcpy`.
4. Fazer o novo n√≥ apontar para a cabe√ßa atual.
5. Atualizar a cabe√ßa da lista para o novo n√≥.


# Sobre o uso de `strdup` na cria√ß√£o de um aluno, marque as op√ß√µes corretas.

> Lembre-se que `strdup` tamb√©m faz aloca√ß√£o.

- [x] Ela aloca mem√≥ria e copia a string de origem.
- [x] O `free` correspondente ocorre em `free_student`.
- [ ] √â equivalente a `strcpy`.
- [ ] N√£o precisa de tratamento de erro ap√≥s chamada.


# Qual problema ocorreria se esquec√™ssemos de liberar `student->name` em `free_student`?

> Ocorre com dados compostos alocados internamente.

1. [ ] *Segmentation fault*
1. [ ] *Double free*
1. [x] *Memory leak*
1. [ ] *Buffer overflow*


# Quais vantagens o uso de callbacks traz para a implementa√ß√£o da lista?

> Pense em reuso e generaliza√ß√£o.

- [x] Permite adaptar a lista a diferentes tipos de dados.
- [x] Evita duplica√ß√£o de c√≥digo em diferentes listas.
- [ ] Aumenta a velocidade de execu√ß√£o do programa.
- [ ] Impede a ocorr√™ncia de erros de aloca√ß√£o.


# Coloque em ordem as etapas da fun√ß√£o `list_contains`.

> Ela percorre e compara os dados.

1. Inicia em `head`.
2. Compara o dado do n√≥ com o elemento buscado usando `compare_data`.
3. Retorna `true` se a compara√ß√£o for igual a zero.
4. Avan√ßa para o pr√≥ximo n√≥.
5. Retorna `false` se atingir o final sem encontrar.


# Quais s√£o os par√¢metros da fun√ß√£o `list_iterate` no desafio proposto?

> Eles controlam o fluxo da itera√ß√£o.

- [x] Um ponteiro para a lista.
- [x] Um ponteiro para fun√ß√£o `cb_iterate`.
- [ ] O n√∫mero de n√≥s da lista.
- [ ] Um vetor de ponteiros para dados.


# O que ocorre se o callback em `list_iterate` retornar `false`?

> Veja o controle de fluxo dentro da fun√ß√£o.

1. [x] A itera√ß√£o √© interrompida imediatamente.
1. [ ] A itera√ß√£o reinicia do in√≠cio.
1. [ ] O n√≥ atual √© removido.
1. [ ] O programa encerra a execu√ß√£o.


# Quais boas pr√°ticas s√£o aplicadas na fun√ß√£o `create_student`?

> Observe o tratamento de erros e aloca√ß√µes.

- [x] Verificar se o `malloc` retornou `NULL`.
- [x] Liberar mem√≥ria parcialmente alocada em caso de falha.
- [ ] Ignorar erros de aloca√ß√£o.
- [ ] Retornar `1` para indicar sucesso na aloca√ß√£o.


# Coloque em ordem o ciclo de vida completo de um elemento na lista de alunos.

> Do in√≠cio at√© a libera√ß√£o final.

1. Criar `Student` com `malloc` e `strdup`.
2. Adicionar √† lista com `list_add`.
3. Buscar elemento com `list_contains`.
4. Destruir lista com `list_destroy`.
5. Liberar mem√≥ria de cada aluno via `free_student`.


# Quais conceitos fundamentais da linguagem C s√£o consolidados nesta unidade?

> Eles formam a base para estruturas gen√©ricas.

- [x] Ponteiros para fun√ß√µes (*callbacks*).
- [x] Manipula√ß√£o de mem√≥ria din√¢mica.
- [x] Estruturas gen√©ricas com `void *`.
- [ ] Recursividade em tempo de compila√ß√£o.

```


{{< include /_includes/progress-bar.qmd >}}

