---
title: "Projeto de Calculadora"
lang: pt
toc-title: Conte√∫do
toc: false
sidebar: false
format:
  html:
    reference-location: margin
    css: ../styles/academic.css
filters: 
    - quizdown
---

Vamos usar os conhecimentos adquiridos at√© aqui para desenvolver uma calculadora simples. Nosso projeto ser√° composto pelo arquivo de cabe√ßalho (`calculator.h`), a implementa√ß√£o (`calculator.c`) e o programa que usa nossa calculadora (`main_calculator.c`). 

At√© aqui, usamos muitas palavras em portugu√™s, visto que os ponteiros para fun√ß√£o podem causar confus√£o no in√≠cio. Agora, vamos usar mais o ingl√™s nas implementa√ß√µes, pois o ecossistema de programa√ß√£o C (bibliotecas, documenta√ß√£o, e _frameworks_) utiliza predominantemente o ingl√™s. Adotar o ingl√™s em nomes de vari√°veis, fun√ß√µes e estruturas √© crucial para aderir √†s boas pr√°ticas da ind√∫stria e facilitar a colabora√ß√£o e a leitura global do c√≥digo.

:::{.callout-note}
Se voc√™ possui um pouco de dificuldade com o ingl√™s, mantenha um **gl√≥ssario** com as palavras mais usadas em programa√ß√£o. Consumir conte√∫do de programa√ß√£o em ingl√™s ajudar√° bastante nesta empreitada tamb√©m.  
:::

## Interface da API

A interface da calculadora cont√©m um novo tipo `Operation` que representa uma fun√ß√£o bin√°ria. Como j√° mencionamos √© um ponteiro para uma fun√ß√£o gen√©rica que recebe dois param√™tros. Definimos a estrtura calculadora que cont√©m os campos `data_size` para o tamanho em _bytes_ do tipo de dados que iremos trabalhar, `n_operations` para o n√∫mero de opera√ß√µes que a calculadora suporta e um ponteiro `operations` que cont√©m as opera√ß√µes da calculadora.

```{.c filename=calculator.h}
#include <stddef.h> // Necess√°rio para o tipo size_t

typedef void* (*Operation)(const void*, const void*);

typedef struct calculator {
    size_t data_size;
    size_t n_operations;
    Operation *operations; 
} Calculator;
```

::: {.column-margin}
**[Se liga!]{.text-warning}**
A palavra chave `const` indica que os valores passados para a opera√ß√£o n√£o podem ser modificados internamente.
:::

Em seguida, temos prot√≥tipos das fun√ß√µes para criar e destruir uma calculadora. A fun√ß√£o `evaluation` j√° √© conhecida e ela coordenda qual _callback_ usar para calcular. Al√©m dela, temos quatro fun√ß√µes de _callback_ para adicionar e multiplicar inteiros ou n√∫meros em ponto flutuante.

```{.c filename=calculator.h}
Calculator *calculator_create(size_t data_size, 
                              size_t n_operations, 
                              const Operation *operations);
void calculator_destroy(Calculator *calc);

void* evaluation(const void *a, const void *b, Operation operation); 

void* add_int (const void *a, const void *b);
void* add_double (const void *a, const void *b);
void* multiply_int (const void *a, const void *b);
void* multiply_double (const void *a, const void *b);

Operation select_operation_int();
Operation select_operation_double();
```

Em resumo:

| Componente	| Fun√ß√£o	| Design √© S√≥lido |
|---------------|-----------|---------------------------|
| `typedef Operation`	| O contrato bin√°rio de todas as fun√ß√µes de c√°lculo. |	O uso de `const void*` protege os dados de entrada, garantindo que os _callbacks_ apenas leiam. |
| `struct Calculator`	| O cont√™iner para metadados e opera√ß√µes. | Os campos `data_size` e `n_operations` (ambos `size_t`) tornam a estrutura robusta e configur√°vel para qualquer tipo de dado. | 
| `calculator_create/destroy`	| Gerenciamento de ciclo de vida.	| Define claramente como a mem√≥ria √© alocada e, mais importante, como deve ser liberada.| 
`evaluation` | 	A fun√ß√£o coordenadora.	| Mant√©m o c√≥digo principal limpo, delegando a l√≥gica complexa (o _callback_). | 
_Callbacks_ | 	As fun√ß√µes de soma e multiplica√ß√£o.	| Est√£o prontas para serem implementadas com a l√≥gica de aloca√ß√£o de mem√≥ria e _casting_ de tipos. |
`select_operation_int` | Fun√ß√£o de f√°brica/sele√ß√£o de _callback_. | Permite ao usu√°rio selecionar dinamicamente a opera√ß√£o para inteiros em tempo de execu√ß√£o, desacoplando a escolha da l√≥gica de execu√ß√£o. |
`select_operation_double` | Fun√ß√£o de f√°brica/sele√ß√£o de _callback_. | Permite ao usu√°rio selecionar dinamicamente a opera√ß√£o para reais em tempo de execu√ß√£o, desacoplando a escolha da l√≥gica de execu√ß√£o. |

## Implementa√ß√£o da API

Agora partiremos para a implementa√ß√£o das fun√ß√µes da nossa interface. Primeiramente, vamos estabelecer quais bibliotecas padr√£o C e quais arquivos de interface precisamos importar.

```{.c filename=calculator.c}
#include "calculator.h"
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <stdio.h>
```

Na primeira linha, estamos importando nossa interface `calculator.h`. Como ela n√£o faz parte da biblioteca padr√£o de C, usamos aspas duplas (`"..."`) designando o caminho (basta o nome, pois ela est√° na mesma pasta).

Em seguida, importamos quatro bibliotecas padr√£o:

- `<stdlib.h>`: Essencial para o gerenciamento de mem√≥ria (`malloc` e `free`).

- `<string.h>`: Necess√°ria para o m√©todo `memcpy`, que utilizaremos para realizar a c√≥pia segura de dados e dos ponteiros de fun√ß√£o em um contexto gen√©rico.

- `<assert.h>`: Usada para a macro `assert`, que insere verifica√ß√µes de seguran√ßa no c√≥digo e garante que as pr√©-condi√ß√µes das fun√ß√µes sejam atendidas.

- `<stdio.h>`: Usada para imprimir mensagem na tela e receber dados do usu√°rio.

Com as depend√™ncias definidas, podemos come√ßar a implementa√ß√£o das fun√ß√µes, come√ßando pelo construtor `calculator_create`.

```{.c filename=calculator.c}
Calculator *calculator_create(size_t data_size, 
                              size_t n_operations, 
                              const Operation *operations) {
	assert(data_size > 0);
    assert(n_operations > 0); 	
    assert(operations != NULL); 
    
	Calculator *calc = (Calculator *)malloc(sizeof(Calculator));
	calc->data_size = data_size;
    calc->n_operations = n_operations;
    calc->operations = (Operation *)malloc(sizeof(Operation) * n_operations);

    if (calc->operations == NULL) {
        free(calc);
        return NULL;
    }

    memcpy(calc->operations, operations, sizeof(Operation) * n_operations);

    return calc;
}
```

O primeiro ato √© verificar as pr√©-condi√ß√µes com `assert`. Caso a pr√©-condi√ß√£o seja falsa, o programa √© abortado, especificando qual condi√ß√£o falhou e em qual linha ela se encontra.

- `assert(data_size > 0)`: Esta verifica√ß√£o garante que a calculadora tenha recebido um tamanho de dado v√°lido. N√£o faz sentido alocar mem√≥ria para um dado com 0 _bytes_, o que √© fundamental para a fun√ß√£o `memcpy` funcionar corretamente.

- `assert(n_operations > 0)` e `assert(operations != NULL)`: Esses _asserts_ trabalham em conjunto para garantir que a calculadora possa de fato operar. Eles verificam que h√° pelo menos uma fun√ß√£o de _callback_ para a calculadora utilizar e que o ponteiro para o _array_ de _callbacks_ n√£o √© nulo.

O restante da fun√ß√£o executa a aloca√ß√£o para `Calculator`, inicializa os campos e usa o tratamento de erro (_rollback_) para liberar corretamente a mem√≥ria se algo falhar na aloca√ß√£o do _array_ de opera√ß√µes. O uso de `memcpy` finaliza a fun√ß√£o, garantindo que a estrutura `Calculator` √© dona de sua pr√≥pria tabela de _callbacks_. Ela copia o _array_ de opera√ß√µes passado de forma segura, _byte a byte_.


Para cada construtor, implemente um destrutor (ou, mais precisamente, para cada `malloc` deve haver um `free` correspondente). Use esse princ√≠pio para programar em C e evitar vazamentos de mem√≥ria (_memory leaks_). Uma vez que criamos o construtor da calculadora, vamos criar seu destrutor, `calculator_destroy`.

Primeiro, devemos liberar a mem√≥ria alocada para as opera√ß√µes. Depois, a mem√≥ria alocada para a estrutura principal da calculadora. √â uma boa pr√°tica verificar se o ponteiro √© v√°lido antes de tentar liberar.


```{.c filename=calculator.c}
void calculator_destroy(Calculator *calc) {
    if (calc == NULL) return;

    // 1. Libera o array de opera√ß√µes (operations).
    if (calc->operations != NULL) {
        free(calc->operations);
        calc->operations = NULL; 
    }
    
    // 2. Libera a estrutura Calculator principal.
    free(calc);
}
```

A ordem de libera√ß√£o √© crucial: se a gente liberasse a estrutura principal `free(calc)` primeiro, o endere√ßo de `calc->operations` (que est√° dentro de `calc`) seria perdido para sempre. Isso resultaria em um vazamento de mem√≥ria (_memory leak_), pois voc√™ n√£o conseguiria liberar o _array_ de opera√ß√µes.

Depois de liberar a mem√≥ria, √© uma boa pr√°tica atribuir o valor `NULL` ao ponteiro a fim de evitar ponteiros pendentes (_dangling pointers_). No entanto, note que n√£o fazemos isso com o ponteiro `calc`, porque ele foi passado por valor. A vari√°vel `calc` dentro desta fun√ß√£o √© apenas uma c√≥pia do endere√ßo; o ponteiro original (por exemplo, `calculator_int`) no `main` n√£o √© alterado.

A fun√ß√£o coordenadora (`evaluation`) √© a parte mais simples da nossa implementa√ß√£o. Ela n√£o precisa saber qual opera√ß√£o est√° sendo executada, apenas delega a responsabilidade para a fun√ß√£o de _callback_ que foi passada:

```{.c filename=calculator.c}
void* evaluation(const void *a, const void *b, Operation operation){
  return operation(a, b);
} 
```

As fun√ß√µes que realmente realizam o c√°lculo seguem um protocolo rigoroso para garantir a generalidade e o gerenciamento de mem√≥ria. Cada _callback_ deve:

- Alocar Mem√≥ria: Usar `malloc` para reservar espa√ßo para o resultado na mem√≥ria _heap_.
- Fazer o _Casting_: Converter o ponteiro gen√©rico de entrada (`const void*`) para o tipo de dado correto (ex: `int*` ou `double*`) para que a opera√ß√£o possa ser realizada.
- Desreferenciar e Calcular: Acessar o valor real (`*`) do ponteiro para realizar a opera√ß√£o.
- Retornar: Reverter o ponteiro do resultado para o tipo gen√©rico (`void*`).

Observe nos exemplos de soma como o _casting_ √© usado para transformar o ponteiro gen√©rico (`a`, `b`) no tipo esperado:

```{.c filename=calculator.c}
// Callback para Soma de Inteiros 
void* add_int (const void *a, const void *b){
    int *result = malloc(sizeof(int));
    
    // Casting de (const void*) para (int*), seguido pela desrefer√™ncia (*)
    *result = *(int*)a + *(int*)b; 
    
    return (void*)result; 
}

// Callback para Soma de Ponto Flutuante
void* add_double (const void *a, const void *b){
    double *result = malloc(sizeof(double));
    
    // Casting de (const void*) para (double*), seguido pela desrefer√™ncia (*)
    *result = *(double*)a + *(double*)b; 
    
    return (void*)result; 
}
```

As outras fun√ß√µes de _callback_ para multiplica√ß√£o (`multiply_int` e `multiply_double`) seguir√£o exatamente o mesmo padr√£o de aloca√ß√£o e _casting_.

Os **ponteiros de fun√ß√£o** nos permitem criar interfaces din√¢micas, como um menu interativo, permitindo que o usu√°rio selecione qual _callback_ deve ser executado em tempo de execu√ß√£o. A fun√ß√£o `select_operation_int` √© o nosso exemplo de **fun√ß√£o de f√°brica** para _callbacks_ de inteiros. Seu objetivo √© mapear a entrada num√©rica do usu√°rio para o endere√ßo de mem√≥ria da fun√ß√£o de _callback_ correspondente.

```{.c filename=calculator.c}
Operation select_operation_int() {
    int option = 0;
    printf("Escolha sua opera√ß√£o:\n");
    printf("1. Soma\n");
    printf("2. Multiplica√ß√£o\n");
    printf("Digite: ");
    scanf("%d", &option);

    if (option == 1) return add_int;
    else if (option == 2) return multiply_int;
    else return NULL; // Retorna NULL como ponteiro de fun√ß√£o inv√°lido
}
```

O bloco de controle de fluxo `if-else` √© a parte central da fun√ß√£o. Ele mapeia o inteiro `c` diretamente para o **endere√ßo de mem√≥ria** da fun√ß√£o de _callback_ desejada. Dessa forma, a fun√ß√£o est√° pronta para ser usada no nosso `main` para selecionar dinamicamente a opera√ß√£o!

Do mesmo modo, a fun√ß√£o `select_operation_double()` √© implementada.

## Uso da API

Nossa calculadora simples est√° finalmente finalizada. Prosseguiremos exemplificando o uso da mesma.

```{.c filename=main_calculator.c}
#include "calculator.h"
#include <stdio.h>
#include <stdlib.h>

int main() {
    
    Operation operations[] = {add_int, multiply_int};
    size_t n_operations = sizeof(operations) / sizeof(operations[0]); 
    
    // 1. CRIA√á√ÉO E TRATAMENTO DE ERRO
    Calculator* calculator_int = calculator_create(sizeof(int), 
                                                   n_operations, 
                                                   operations);
    
    if (calculator_int == NULL) {
        fprintf(stderr, "Erro: Falha ao alocar a estrutura Calculator.\n");
        return 1;
    }
    
    // Dados para teste
    int a = 10;
    int b = 2;
    
    // 2. SELE√á√ÉO E EXECU√á√ÉO
    Operation selected_op = select_operation_int(); 
    
    if (selected_op == NULL) {
        fprintf(stderr, "Erro: Opera√ß√£o inv√°lida selecionada.\n");
        calculator_destroy(calculator_int); // Limpa o que foi criado
        return 1;
    }

    // Chama evaluation, que aloca o resultado na heap
    void *result_ptr = evaluation(&a, &b, selected_op);
    
    if (result_ptr == NULL) {
        fprintf(stderr, "Erro: Falha ao alocar mem√≥ria para o resultado.\n");
        calculator_destroy(calculator_int); // Limpa o que foi criado
        return 1;
    }
    
    printf("Resultado: %d\n", *(int*)result_ptr);

    // 3. LIMPEZA DA MEM√ìRIA
    
    // 3.1 Libera a mem√≥ria alocada DENTRO do callback
    free(result_ptr); 
    
    // 3.2 Libera a estrutura Calculator e suas opera√ß√µes internas
    calculator_destroy(calculator_int); 
    calculator_int = NULL; // Boa pr√°tica: anular o ponteiro
    
    return 0;
}
```

Lembrando que para compilar nossa calculadora, garantindo que ambos os arquivos de implementa√ß√£o sejam processado, devemos executar o seguinte comando no terminal:

```{.console code-line-numbers="false"}
$ gcc calculator.c main_calculator.c -o calc
```
Isso ir√° gerar um execut√°vel chamado `calc` na sua pasta.

Finalizamos a implementa√ß√£o da nossa **Calculadora Gen√©rica**. Ela pode n√£o estar perfeita, mas conseguimos aplicar e solidificar conceitos avan√ßados que d√£o um grande _up_ em nossa jornada na programa√ß√£o C. Em particular, a manipula√ß√£o de **ponteiros gen√©ricos** (`void*`) e o uso de **ponteiros para fun√ß√µes** como _callbacks_ s√£o ferramentas poderos√≠ssimas que devem ser exploradas com afinco.

Como sugest√£o de aprimoramento e pr√°tica adicional, voc√™ pode tentar modularizar o sistema e refinar a interface do usu√°rio:

::: {.callout-note icon="false" title="üéØ Desafio de C√≥digo"}

**Modulariza√ß√£o**

- Mova as fun√ß√µes `select_operation_int` e `select_operation_double` para um novo par de arquivos de utilit√°rio (por exemplo, `ui.c`/`ui.h`). Isso ajuda a manter o arquivo principal (`calculator.c`) focado apenas na l√≥gica de c√°lculo, separando a **interface do usu√°rio** da **l√≥gica de neg√≥cios**.

**Refinamento do Tipo**

- Refine a **interface do usu√°rio** criando uma fun√ß√£o inicial que permita ao usu√°rio escolher entre os tipos (`int` ou `double`) antes de chamar as fun√ß√µes de sele√ß√£o de opera√ß√£o.

:::


---

Nesta unidade, voc√™ aprendeu

‚úÖ a criar um projeto gen√©rico com interface, implementa√ß√£o e uso

‚úÖ a aplicar os conceitos de fun√ß√£o de ordem superior e _callback_

‚úÖ a gerenciar o ciclo de vida dos objetos na mem√≥ria alocando e desalocando 

‚úÖ a compilar um projeto com mais de um arquivo `.c`


```quizdown
# Qual √© o principal prop√≥sito do projeto da calculadora?

> Pense na aplica√ß√£o dos conceitos anteriores.

1. [ ] Criar uma calculadora apenas para inteiros.
1. [ ] Demonstrar heran√ßa e polimorfismo em C.
1. [x] Consolidar o uso de ponteiros gen√©ricos e ponteiros para fun√ß√µes.
1. [ ] Implementar opera√ß√µes matem√°ticas complexas.


# O que o tipo `Operation` representa no c√≥digo?

> Ele √© um dos pilares da arquitetura da calculadora.

1. [ ] Um tipo gen√©rico de vari√°vel num√©rica.
1. [x] Um ponteiro para fun√ß√£o que recebe dois argumentos gen√©ricos.
1. [ ] Uma estrutura auxiliar de armazenamento.
1. [ ] Um alias para `void*` usado para resultados.


# Qual √© a fun√ß√£o do campo `data_size` na estrutura `Calculator`?

> Lembre-se da import√¢ncia do `size_t`.

1. [x] Indicar o tamanho em bytes do tipo de dado que ser√° manipulado.
1. [ ] Controlar o n√∫mero m√°ximo de opera√ß√µes executadas.
1. [ ] Armazenar o resultado da √∫ltima opera√ß√£o.
1. [ ] Determinar o n√∫mero de callbacks dispon√≠veis.


# Sobre o uso de `const` em `Operation`, qual √© a alternativa correta?

> A palavra-chave tem papel importante na seguran√ßa do c√≥digo.

1. [x] Garante que os par√¢metros passados n√£o ser√£o modificados internamente.
1. [ ] Impede a fun√ß√£o de retornar um valor.
1. [ ] Indica que a fun√ß√£o deve ser inline.
1. [ ] Torna o ponteiro de fun√ß√£o imut√°vel.


# Quais fun√ß√µes fazem parte do gerenciamento de ciclo de vida da calculadora?

> Pense em aloca√ß√£o e libera√ß√£o de mem√≥ria.

- [x] `calculator_create`
- [x] `calculator_destroy`
- [ ] `evaluation`
- [ ] `select_operation_int`


# Coloque na ordem as etapas executadas dentro de `calculator_create`.

> Observe o processo de cria√ß√£o e inicializa√ß√£o.

1. Verificar pr√©-condi√ß√µes com `assert`.
2. Alocar mem√≥ria para `Calculator`.
3. Alocar mem√≥ria para o array `operations`.
4. Copiar o conte√∫do das opera√ß√µes com `memcpy`.
5. Retornar o ponteiro da nova calculadora.


# Qual √© o papel da fun√ß√£o `calculator_destroy`?

> Pense na ordem correta da libera√ß√£o.

1. [ ] Limpar apenas os dados dos resultados.
1. [x] Liberar o array de opera√ß√µes e depois a estrutura principal.
1. [ ] Encerrar o programa e exibir mensagem de sucesso.
1. [ ] Apenas definir todos os ponteiros como `NULL`.


# Quais pr√°ticas de seguran√ßa de mem√≥ria s√£o usadas em `calculator_destroy`?

> Observe o padr√£o de boas pr√°ticas.

- [x] Verifica√ß√£o de ponteiro nulo antes de liberar.
- [x] Libera√ß√£o dos recursos na ordem inversa da aloca√ß√£o.
- [x] Atribui√ß√£o de `NULL` ap√≥s `free` para evitar ponteiros pendentes.
- [ ] Reutiliza√ß√£o autom√°tica da estrutura ap√≥s libera√ß√£o.


# O que a fun√ß√£o `evaluation` faz?

> Ela √© o ponto de coordena√ß√£o da execu√ß√£o.

1. [ ] Calcula e imprime o resultado diretamente.
1. [x] Chama a fun√ß√£o de callback adequada, repassando os par√¢metros.
1. [ ] Faz a sele√ß√£o autom√°tica da opera√ß√£o.
1. [ ] Libera os ponteiros ap√≥s a execu√ß√£o.


# Qual √© o comportamento comum √†s fun√ß√µes `add_int` e `add_double`?

> Elas seguem o mesmo protocolo de implementa√ß√£o.

- [x] Fazem cast dos ponteiros gen√©ricos para o tipo correto.
- [x] Alocam mem√≥ria dinamicamente para o resultado.
- [x] Retornam um `void*` apontando para o resultado.
- [ ] Escrevem o resultado diretamente em `stdout`.


# Qual seria o problema se as fun√ß√µes de callback n√£o alocassem mem√≥ria?

> Pense no tempo de vida dos dados retornados.

1. [ ] A fun√ß√£o n√£o conseguiria imprimir o resultado.
1. [x] O ponteiro retornado apontaria para uma vari√°vel local inv√°lida.
1. [ ] O compilador n√£o aceitaria o retorno do tipo `void*`.
1. [ ] O programa entraria em loop infinito.


# Sobre as fun√ß√µes `multiply_int` e `multiply_double`, assinale o correto.

> Elas espelham a l√≥gica das fun√ß√µes de soma.

1. [ ] Fazem casting incorreto para `float*`.
1. [x] Seguem o mesmo padr√£o de aloca√ß√£o, casting e retorno das fun√ß√µes de soma.
1. [ ] S√£o implementadas com recurs√£o.
1. [ ] Liberam automaticamente o resultado ap√≥s a execu√ß√£o.


# Qual √© a fun√ß√£o principal de `select_operation_int`?

> Veja o papel do menu interativo.

1. [x] Retornar o endere√ßo da fun√ß√£o correspondente √† opera√ß√£o escolhida.
1. [ ] Executar diretamente a opera√ß√£o selecionada.
1. [ ] Criar uma nova estrutura de calculadora.
1. [ ] Exibir o resultado na tela.


# Coloque em ordem as etapas principais da execu√ß√£o em `main_calculator.c`.

> Elas seguem o fluxo do programa principal.

1. Criar a calculadora com `calculator_create`.
2. Selecionar a opera√ß√£o via `select_operation_int`.
3. Chamar `evaluation` para obter o resultado.
4. Exibir o resultado na tela.
5. Liberar os recursos com `free` e `calculator_destroy`.


# Quais verifica√ß√µes de erro s√£o realizadas em `main_calculator.c`?

> Seguran√ßa sempre vem primeiro.

- [x] Verifica se `calculator_create` retornou `NULL`.
- [x] Verifica se a opera√ß√£o selecionada √© v√°lida.
- [x] Verifica se houve falha na aloca√ß√£o do resultado.
- [ ] Verifica se o usu√°rio digitou um n√∫mero negativo.


# Por que `calculator_int` √© definido como `NULL` ao final do programa?

> Uma boa pr√°tica de limpeza.

1. [x] Para evitar ponteiros pendentes ap√≥s `free`.
1. [ ] Porque o compilador exige inicializa√ß√£o nula.
1. [ ] Para permitir o reuso autom√°tico da mem√≥ria.
1. [ ] Porque `free` n√£o libera o ponteiro corretamente.


# Coloque em ordem o ciclo de vida da mem√≥ria nesta aplica√ß√£o.

> Do in√≠cio ao final da execu√ß√£o.

1. Aloca√ß√£o de `Calculator` com `malloc`.
2. Aloca√ß√£o de `operations`.
3. Aloca√ß√£o do resultado dentro do callback.
4. Libera√ß√£o do resultado com `free`.
5. Libera√ß√£o de `operations` e da estrutura principal.


# Quais melhorias s√£o sugeridas no desafio de c√≥digo?

> Elas visam modulariza√ß√£o e clareza.

- [x] Separar a interface do usu√°rio em arquivos `ui.c` e `ui.h`.
- [x] Permitir que o usu√°rio escolha entre `int` e `double`.
- [ ] Adicionar suporte a opera√ß√µes de subtra√ß√£o.
- [ ] Mudar toda a estrutura para C++.


# Quais conceitos fundamentais s√£o refor√ßados neste projeto?

> Ele consolida a base da programa√ß√£o modular em C.

- [x] Uso de ponteiros gen√©ricos (`void*`).
- [x] Ponteiros para fun√ß√µes como callbacks.
- [x] Modulariza√ß√£o com m√∫ltiplos arquivos `.c`.
- [ ] Programa√ß√£o orientada a objetos nativa.

```

{{< include /_includes/progress-bar.qmd >}}
