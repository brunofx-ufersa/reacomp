<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="pt" xml:lang="pt"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.24">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Função Hash – REAComp</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../../">
<link href="../../../../disciplinas/aed2/academic/unidade2/8-colisoes.html" rel="next">
<link href="../../../../disciplinas/aed2/academic/unidade2/6-introhash.html" rel="prev">
<link href="../../../../img/logo.png" rel="icon" type="image/png">
<script src="../../../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../site_libs/quarto-html/quarto-syntax-highlighting-f54fa83ccd8f86fe7238c9291c42d766.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../../../site_libs/quarto-html/quarto-syntax-highlighting-dark-8f4e3aabaa80e3e650ae20f2c24f966b.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="../../../../site_libs/quarto-html/quarto-syntax-highlighting-f54fa83ccd8f86fe7238c9291c42d766.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../site_libs/bootstrap/bootstrap-5507107efa3b558344c9681f4ca7970d.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../../../site_libs/bootstrap/bootstrap-dark-023439531b09c5d34e467d9e2f831cae.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<link href="../../../../site_libs/bootstrap/bootstrap-5507107efa3b558344c9681f4ca7970d.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "Nenhum resultado",
    "search-matching-documents-text": "documentos correspondentes",
    "search-copy-link-title": "Copiar link para a busca",
    "search-hide-matches-text": "Esconder correspondências adicionais",
    "search-more-match-text": "mais correspondência neste documento",
    "search-more-matches-text": "mais correspondências neste documento",
    "search-clear-button-title": "Limpar",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancelar",
    "search-submit-button-title": "Enviar",
    "search-label": "Procurar"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../../../styles.css">
<link rel="stylesheet" href="../styles/academic.css">
</head>

<body class="nav-fixed quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const darkModeDefault = authorPrefersDark;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../../../index.html" class="navbar-brand navbar-brand-logo">
    </a>
    <a class="navbar-brand" href="../../../../index.html">
    <span class="navbar-title">REAComp</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Procurar"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Alternar de navegação" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../../disciplinas/aed2/academic/index.html"> 
<span class="menu-text">Recursos</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../../contribuicao.html"> 
<span class="menu-text">Participe</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../../blog.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../../about.html"> 
<span class="menu-text">Sobre</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Alternar modo escuro"><i class="bi"></i></a>
  <a href="" class="quarto-reader-toggle quarto-navigation-tool px-1" onclick="window.quartoToggleReader(); return false;" title="Alternar modo de leitor">
  <div class="quarto-reader-toggle-btn">
  <i class="bi"></i>
  </div>
</a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content">


<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Função Hash</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="características-da-função-hash" class="level2">
<h2 class="anchored" data-anchor-id="características-da-função-hash">Características da Função Hash</h2>
<ul>
<li>Fácil de ser calculada;</li>
<li>Distribuição uniforme dos dados;</li>
<li>Minimiza as colisões;</li>
<li>Capaz de resolver possíveis colisões.</li>
</ul>
<p>A vantagem da tabela hash é a velocidade de busca, uma função muito complicada para calcular é incoveniente, pois pode demorar mais que uma busca em uma árvore binária, por exemplo. Além disso, se a função não distribui as chaves de maneira uniforme, muitas delas irão se concentrar em um local do vetor, aumentando a probabilidade de colisões.</p>
</section>
<section id="método-da-divisão" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="método-da-divisão">Método da Divisão</h2>
<p>No método da divisão, usamos o resultado do resto da divisão do valor da chave pelo tamanho da tabela. <span class="math display">\[h(k) = k \bmod m\]</span></p>
<p>O ideal é que <span class="math inline">\(m\)</span> seja um número primo e não muito próximo de potências de <span class="math inline">\(2\)</span>.</p>
<p>Por exemplo, se <span class="math inline">\(k=12345\)</span> e <span class="math inline">\(m=101\)</span>, então <span class="math display">\[h(k) = h(12345)= 12345 \bmod 101 = 22\]</span></p>
<p>A chave <span class="math inline">\(12345\)</span> deve ser alocada na posição <span class="math inline">\(22\)</span> do vetor de <span class="math inline">\(101\)</span> posições.</p>

<div class="no-row-height column-margin column-container"><div class="">
<p><strong><span class="text-warning">Se liga!</span></strong> Nem sempre trateremos com chaves inteiras simples como as vistas até aqui. Nesses casos, precisamos de um mecanismo para transformar em um valor inteiro antes de processar a função hash. Veremos isso à frente.</p>
</div></div><p>Este é o método mais simples e fácil de gerar um valor de hash. A função hash divide o valor <span class="math inline">\(k\)</span> (chave) por <span class="math inline">\(m\)</span> (tamanho da tabela) e, em seguida, usa o resto obtido. É mais adequado que <span class="math inline">\(m\)</span> seja um número primo, pois isso pode garantir que as chaves sejam distribuídas de forma mais uniforme.</p>
<p>Embora simples, o método da divisão leva a um desempenho ruim, uma vez que chaves consecutivas mapeiam para valores de hash consecutivos na tabela de hash.</p>
<div class="callout callout-style-default callout-note no-icon callout-titled" title="Exercício">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Nota</span>Exercício
</div>
</div>
<div class="callout-body-container callout-body">
<p>Dada a função hash <span class="math inline">\(h(k) = k^2\bmod 7\)</span>, calcule os valores hash para as chaves <span class="math display">\[4, 17, 13, 35, 25, 11, 2, 10, 32\]</span>.</p>
</div>
</div>
<div class="callout callout-style-default callout-tip callout-titled" title="Solução (clique para ver)">
<div class="callout-header d-flex align-content-center collapsed" data-bs-toggle="collapse" data-bs-target=".callout-2-contents" aria-controls="callout-2" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Dica</span>Solução (clique para ver)
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-2" class="callout-2-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<ul>
<li><span class="math inline">\(h(4)\,\,\,=\,\,\,4^2\bmod 7=16\bmod 7\,\,\,\,\,\,=2\)</span></li>
<li><span class="math inline">\(h(17)=17^2\bmod 7=289\bmod 7\,\,\,=2\)</span></li>
<li><span class="math inline">\(h(13)=13^2\bmod 7=169\bmod 7\,\,\,=1\)</span></li>
<li><span class="math inline">\(h(35)=35^2\bmod 7=1225\bmod 7=0\)</span></li>
<li><span class="math inline">\(h(25)=25^2\bmod 7=625\bmod 7\,\,\,=2\)</span></li>
<li><span class="math inline">\(h(11)=11^2\bmod 7=121\bmod 7\,\,\,=2\)</span></li>
<li><span class="math inline">\(h(2)\,\,\,=\,\,\,2^2\bmod 7=4\bmod 7\,\,\,\,\,\,\,\,\,=4\)</span></li>
<li><span class="math inline">\(h(10)=10^2\bmod 7=100\bmod 7\,\,\,=2\)</span></li>
<li><span class="math inline">\(h(32)=32^2\bmod 7=1024\bmod 7=2\)</span></li>
</ul>
<p>Muitas colisões ocorreram! Era evidente que haveria sobreposição de chaves, pois temos somentes sete espaços.</p>
</div>
</div>
</div>
</section>
<section id="método-da-multiplicação" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="método-da-multiplicação">Método da Multiplicação</h2>
<p>No método da multiplicação, realizamos os seguintes passos:</p>
<ul>
<li>Multiplicamos a chave (<span class="math inline">\(k\)</span>) por uma constante <span class="math inline">\(A\)</span> entre <span class="math inline">\(0\)</span> e <span class="math inline">\(1\)</span>;</li>
<li>Extraímos a parte fracionária de <span class="math inline">\(kA\)</span>;</li>
<li>Multiplicamos esse valor por <span class="math inline">\(m\)</span> (tamanho da tabela);</li>
<li>Arredondamos para baixo;</li>
</ul>
<p>Ou seja,</p>
<p><span class="math display">\[h(k) = \lfloor m (kA \bmod 1) \rfloor, \text{ com } 0 &lt; A &lt; 1\]</span></p>
<p>Por exemplo, considere <span class="math inline">\(k = 123\)</span>, <span class="math inline">\(m = 1000\)</span>, e <span class="math inline">\(A \approx 0,618\)</span>.</p>
<p><span class="math display">\[h(k) = \lfloor 1000 (123 \cdot 0,618 \bmod 1) \rfloor=\lfloor 1000 (76,014 \bmod 1) \rfloor=\lfloor 1000\cdot 0,014 \rfloor=14\]</span></p>
<p>A vantagem do método de multiplicação é que ele pode trabalhar com qualquer valor entre 0 e 1.</p>

<div class="no-row-height column-margin column-container"><div class="">
<p><strong><span class="text-warning">Se liga!</span></strong> O método de multiplicação é geralmente adequado quando o tamanho da tabela é uma potência de dois.</p>
</div></div><div class="callout callout-style-default callout-note no-icon callout-titled" title="Exercício">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Nota</span>Exercício
</div>
</div>
<div class="callout-body-container callout-body">
<p>Seja a chave <span class="math inline">\(k = 12345\)</span>, a constante <span class="math inline">\(A = 0,357840\)</span> e o tamanho da tabela <span class="math inline">\(m = 100\)</span>, calcule o valor hash usando o método da multiplicação.</p>
</div>
</div>
<div class="callout callout-style-default callout-tip callout-titled" title="Solução (clique para ver)">
<div class="callout-header d-flex align-content-center collapsed" data-bs-toggle="collapse" data-bs-target=".callout-4-contents" aria-controls="callout-4" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Dica</span>Solução (clique para ver)
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-4" class="callout-4-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p><span class="math display">\[h(k) = \lfloor m (kA \bmod 1) \rfloor\]</span> <span class="math inline">\(h(12345) = \lfloor 100 (12345\cdot 0,357840 \bmod 1) \rfloor=\lfloor 100 (4417,5348 \bmod 1) \rfloor=\lfloor 100 (0,5348) \rfloor=\lfloor 53,48 \rfloor=53\)</span></p>
</div>
</div>
</div>
</section>
<section id="hashing-universal" class="level2">
<h2 class="anchored" data-anchor-id="hashing-universal">Hashing Universal</h2>
<p>O hash universal tenta resolver o problema das colisões usando uma família de funções de hash, <span class="math inline">\(\mathcal{H}\)</span>, que possui uma propriedade matemática crucial:</p>
<blockquote class="blockquote">
<p>Para quaisquer duas chaves distintas, <span class="math inline">\(k_1\)</span> e <span class="math inline">\(k_2\)</span>, a probabilidade de que a função de hash <span class="math inline">\(h \in \mathcal{H}\)</span> escolhida aleatoriamente cause uma colisão é no máximo igual à probabilidade de colisão aleatória, que é <span class="math inline">\(1/m\)</span>, onde <span class="math inline">\(m\)</span> é o número de posições na tabela hash.</p>
</blockquote>
<p>Uma das famílias universais mais usadas para chaves que são números inteiros e uma tabela de tamanho <span class="math inline">\(m\)</span> é definida da seguinte forma:</p>
<p>Seja <span class="math inline">\(p\)</span> um número primo maior que qualquer chave possível, e <span class="math inline">\(m\)</span> o tamanho da tabela hash. A família <span class="math inline">\(\mathcal{H}\)</span> é o conjunto de funções <span class="math inline">\(h_{a,b}\)</span> dadas pela fórmula: <span class="math display">\[h_{a,b}(k) = ((ak + b) \bmod p) \bmod m\]</span></p>
<p>Onde <span class="math inline">\(a\)</span> e <span class="math inline">\(b\)</span> são parâmetros <strong>inteiros</strong> aleatórios escolhidos no início, com <span class="math inline">\(a\in[1, p-1]\)</span> e <span class="math inline">\(b\in[0, p-1]\)</span>.</p>
<p>Os parâmetros aleatórios ajudam a dispersar o valor da chave. Já a operação de módulo por um primo <span class="math inline">\(p\)</span> ajuda a garantir que a distribuição do resultado seja uniforme no intervalo <span class="math inline">\([0, p-1]\)</span>. Finalmente, o resultado final é mapeado para o índice da tabela hash, no intervalo <span class="math inline">\([0, m-1]\)</span>.</p>
<p>Por exemplo, digamos uma tabela com <span class="math inline">\(m=10\)</span> slots e escolhamos <span class="math inline">\(p=103\)</span>.</p>
<ul>
<li>Sorteamos <span class="math inline">\(a\)</span> entre <span class="math inline">\(1\)</span> e <span class="math inline">\(p-1\)</span>, ou seja, no intervalo <span class="math inline">\([1, 102]\)</span></li>
<li>Sorteamos <span class="math inline">\(b\)</span> entre <span class="math inline">\(0\)</span> e <span class="math inline">\(p-1\)</span>, ou seja, no intervalo <span class="math inline">\([0, 102]\)</span></li>
</ul>
<p>Digamos que <span class="math inline">\(a=5\)</span> e <span class="math inline">\(b=13\)</span>, então nossa função sorteada da família universal será: <span class="math display">\[h_{5,13}(k)=((5k+13)\bmod103)\bmod 10\]</span></p>
<p>Vamos calcular alguns valores de hash para fixação.</p>
<ul>
<li><span class="math inline">\(h(4)\,\,\,=\,\,\,((5\cdot4+13)\bmod103)\bmod 10=\,\,\,(33\bmod103)\bmod 10=33 \bmod 10=3\)</span></li>
<li><span class="math inline">\(h(17)=((5\cdot17+13)\bmod103)\bmod 10=\,\,\,(98\bmod103)\bmod 10= 98\bmod 10=8\)</span></li>
<li><span class="math inline">\(h(25)=((5\cdot25+13)\bmod103)\bmod 10=(138\bmod103)\bmod 10=35\bmod 10=5\)</span></li>
<li><span class="math inline">\(h(32)=((5\cdot32+13)\bmod103)\bmod 10=(173\bmod103)\bmod 10=70\bmod 10=0\)</span></li>
</ul>
<p>Mesmo com os melhores métodos, é impossível evitar colisões. Quando acontece, devemos tratá-la de modo que o desempenho da busca não seja muito afetado. No entanto, antes de estudarmos os tratamentos de colições, iremos abordar as estratégias para mapeamento de chaves em inteiros.</p>
</section>
<section id="estratégias-para-mapeamento" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="estratégias-para-mapeamento">Estratégias para Mapeamento</h2>
<p>Quando falamos em mapeamento de chaves em inteiros, estamos nos referindo a um pré-processamento que transforma uma chave (como uma string ou um número muito grande) em um inteiro mais adequado para ser usado por uma função de hash.</p>
<p>Embora seja possível criar suas próprias estratégias, apresentamos a seguir alguns métodos clássicos encontrados na literatura.</p>
<section id="chaves-do-tipo-string" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="chaves-do-tipo-string">Chaves do tipo <em>string</em></h3>
<p>Os métodos clássicos para tratar strings usam o fato de cada letra ter um inteiro correspondente na tabela ASCII.</p>
<section id="soma" class="level4">
<h4 class="anchored" data-anchor-id="soma">Soma</h4>
<p>Muitas vezes, as chaves que estamos trabalhando são <em>strings</em>. Uma forma simples de convertê-las em inteiros é somar os valores ASCII de cada caractere: <span class="math display">\[k=\sum_{i=0}^{n-1}s[i]=s[0]+s[1]+s[2]+\cdots+s[n-1]\]</span></p>
<p>onde <span class="math inline">\(n\)</span> é o tamanho da palavra.</p>
<p>Por exemplo, a palavra “PAI” (P = 80, A = 65 e I = 73): <span class="math display">\[k=\sum_{i=0}^{3-1}s[i]=\sum_{i=0}^{2}s[i]=s[0]+s[1]+s[2]=80+65+73=218\]</span></p>
<p>Esse método é simples, mas apresenta má distribuição, ou seja, palavras com as mesmas letras em ordem diferente geram o mesmo valor.</p>
</section>
<section id="multiplicação-polinomial" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="multiplicação-polinomial">Multiplicação Polinomial</h4>
<p>Um método mais robusto é o da <strong>multiplicação polinomial</strong>. Aqui, tratamos a <em>string</em> como um número em uma base <span class="math inline">\(\beta\)</span> (β (geralmente um número primo pequeno): <span class="math display">\[k=s[0]\cdot\beta^{n-1}+s[1]\cdot\beta^{n-2}+\cdots+s[n-1]\cdot\beta^{0}\]</span></p>
<p>Por exemplo, a palavra “PAI” (P = 80, A = 65 e I = 73) e <span class="math inline">\(\beta=13\)</span>: <span class="math display">\[k=s[0]\cdot 13^{3-1}+s[1]\cdot 13^{3-2}+\cdots+s[2]\cdot 13^{0}=80\cdot13^2+65\cdot13^1+73\cdot13^0=14438\]</span></p>

<div class="no-row-height column-margin column-container"><div class="">
<p><strong><span class="text-warning">Se liga!</span></strong> A multiplicação por um número primo ajuda a espalhar os valores de forma mais uniforme do que se usássemos um número composto.</p>
</div></div><p>Essa técnica é superior à soma simples, pois considera a ordem dos caracteres. Para palavras como “cama” e “maca”, a soma simples irá retornar os mesmos valores, enquanto que a multiplicação polinomial não.</p>
<p>Exemplo simples:</p>
<ul>
<li><span class="math inline">\(BA : 66\cdot13^1 + 65\cdot13^0 = 923\)</span>.</li>
<li><span class="math inline">\(AB : 65\cdot13^1 + 66\cdot13^0 = 911\)</span>.</li>
</ul>
<p>Dessa forma, “BA” e “AB” produzem resultados distintos, evitando colisões triviais.</p>
</section>
</section>
<section id="chaves-do-tipo-int-grandes" class="level3">
<h3 class="anchored" data-anchor-id="chaves-do-tipo-int-grandes">Chaves do tipo <em>int</em> grandes</h3>
<p>Quando lidamos com inteiros muito grandes, precisamos reduzi-los para evitar estouro de capacidade (overflow) ou para encaixá-los em um intervalo menor. A seguir, apresentamos três métodos comuns: dobramento (folding), XOR e quadrado central (mid-square).</p>
<section id="dobramento-folding" class="level4">
<h4 class="anchored" data-anchor-id="dobramento-folding">Dobramento (Folding)</h4>
<p>Consiste em dividir a chave em partes menores e, em seguida, somá-las ou aplicar XOR entre elas para gerar um número reduzido. Por exemplo, suponha <span class="math inline">\(k = 83.529.170\)</span>, vamos dividir a chave assim:</p>
<ul>
<li><span class="math inline">\(k_1 = 835\)</span></li>
<li><span class="math inline">\(k_2 = 291\)</span></li>
<li><span class="math inline">\(k_3 = 70\)</span></li>
</ul>
<p>O dobramento por soma resulta em <span class="math inline">\(k_1+k_2+k_3=835+291+70=1196\)</span>.</p>
<p>No dobramento por XOR, as partes são combinadas usando a operação lógica OU exclusivo (XOR), muito comum em funções de hash criptográficas. Primeiro, convertemos as partes para binário (aqui, usando 10 bits para simplificar):</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Parte</th>
<th>Decimal</th>
<th>Binário (10 bits)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(k_1\)</span></td>
<td>835</td>
<td>1101000011</td>
</tr>
<tr class="even">
<td><span class="math inline">\(k_2\)</span></td>
<td>291</td>
<td>0100100011</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(k_3\)</span></td>
<td>70</td>
<td>0001000110</td>
</tr>
</tbody>
</table>
<p>Realizamos a operação XOR bit a bit entre as partes. <span class="math display">\[k_1 \oplus k_2 \oplus k_3\]</span><span class="math display">\[\begin{array}{r l l} &amp; 1101000011 &amp; (k_1) \\ \oplus &amp; 0100100011 &amp; (k_2) \\ \hline &amp; 1001100000 &amp; (k_1 \oplus k_2) \\ \oplus &amp; 0001000110 &amp; (k_3) \\ \hline &amp; \mathbf{1000100110} &amp; (\text{Resultado}) \end{array}\]</span></p>
<p>Transformando 1000100110 de volta para decimal: <span class="math display">\[1000100110_2=512+64+8+4+2=590\]</span></p>
<p>O método XOR tende a preservar melhor as características de todas as partes da chave, ainda que seja um pouco mais complexo de implementar do que a soma simples.</p>
</section>
<section id="mid-square" class="level4">
<h4 class="anchored" data-anchor-id="mid-square">Mid-Square</h4>
<p>O método do quadrado central é uma técnica clássica de extração. A chave é elevada ao quadrado, e então o hash é formado pelos dígitos centrais do resultado. A quantidade de dígitos extraídos é indicada por <span class="math inline">\(d\)</span>.</p>
<p>Apesar de ser simples, ele pode gerar um código hash razoavelmente bem distribuído. Como exemplo, considere uma <span class="math inline">\(k=931\)</span> e <span class="math inline">\(d=3\)</span>. <span class="math display">\[k^2=931^2=866761\]</span> Assim, podemos selecionar <span class="math inline">\(676\)</span>, ou até <span class="math inline">\(667\)</span>.</p>
<p>Esses métodos apresentados podem ser combinados ou até mesmo utilizados como substitutos de uma função hash. Em sistemas mais complexos, essas abordagens costumam ser empregadas como etapas auxiliares dentro de funções de hash mais sofisticadas.</p>
<hr>
<p>Nesta unidade, você aprendeu</p>
<p>✅ quais características uma função <em>hash</em> deve possuir</p>
<p>✅ metódos clássicos para definir funções <em>hash</em></p>
<p>✅ como mapear palavras e grandes números em chaves</p>
<div class="progress-bar" id="progressBar"></div>

<script>
window.addEventListener("scroll", function() {
  const scrollTop = window.scrollY;
  const docHeight = document.body.scrollHeight - window.innerHeight;
  const scrollPercent = (scrollTop / docHeight) * 100;
  document.getElementById("progressBar").style.width = scrollPercent + "%";
});
</script>


</section>
</section>
</section>

<a onclick="window.scrollTo(0, 0); return false;" role="button" id="quarto-back-to-top"><i class="bi bi-arrow-up"></i> De volta ao topo</a></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copiada");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copiada");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/brunofx-ufersa\.github\.io\/reacomp\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../../../../disciplinas/aed2/academic/unidade2/6-introhash.html" class="pagination-link" aria-label="Tabela de Dispersão">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">Tabela de Dispersão</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../../../../disciplinas/aed2/academic/unidade2/8-colisoes.html" class="pagination-link" aria-label="Tratamento de Colisões">
        <span class="nav-page-text">Tratamento de Colisões</span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
 Licença
  </li>  
    <li class="nav-item">
    <a class="nav-link" href="http://creativecommons.org/licenses/by-sa/4.0/">
<p>CC BY-SA 4.0</p>
</a>
  </li>  
    <li class="nav-item">
 — Portal construído com
  </li>  
    <li class="nav-item">
    <a class="nav-link" href="https://quarto.org/">
<p>Quarto</p>
</a>
  </li>  
</ul>
    </div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>