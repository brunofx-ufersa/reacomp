---
title: "Tratamento de Colis√µes"
toc-title: Conte√∫do
toc: false
sidebar: false
format: 
  html:
    reference-location: margin
    css: ../styles/academic.css 
filters: 
    - quizdown
---


Sabemos que uma colis√£o ocorre quando a fun√ß√£o _hash_ produz o mesmo valor para duas ou mais chaves
distintas. Isto √©:
$$h(k1) = h(k2)$$

Colis√µes s√£o praticamente inevit√°veis, por isso devemos trat√°-las. As principais
abordagens s√£o endere√ßamento aberto e encadeamento separado.

- **Endere√ßamento aberto**: percorrer a tabela em busca de um local n√£o ocupado.
- **Encadeamento separado**: uso de listas ligadas para armazenar as colis√µes.

::: {.column-margin}
**[Se liga!]{.text-warning}**
Endere√ßamento aberto: procura um endere√ßo aberto, um slot vazio.
Encadeamento separado: usa listas encadeadas separadas, uma para cada slot.
:::

## Endere√ßamento aberto

A t√©cnica de endere√ßamento aberto tenta resolver o problema de colis√£o buscando
um outro lugar vazio para armazenar a chave que colidiu. As maneiras principais de sondar um espa√ßo vazio s√£o:

- Sondagem linear;
- Sondagem quadr√°tica;
- Duplo hash

### Sondagem linear

A sondagem linear procura pela pr√≥xima posi√ß√£o vazia do vetor. A fun√ß√£o de hash possui uma nova vari√°vel iterativa que permitir√° a procura por esse lugar vazio:
$$h(k,i) = (h'(k)+i)\bmod m$$
onde $i=0,1,2,3,\ldots$

Sempre que ocorre uma colis√£o, esta vari√°vel ($i$) √© incrementada em uma unidade.

Por exemplo, considere o vetor abaixo:

::: {style="width: 60%; margin: auto;"}
|slot | 0   | 1    |  2   | 3  | 4  | 5   | 6   | 7   | 8   | 9  |
|-----| :----: | :-----: | :-----: | :---: | :---: | :----: | :----: | :----: | :----: | :---: |
| chave  | ‚ùå | 21  | 42  | 63 | ‚ùå | ‚ùå | ‚ùå | ‚ùå | ‚ùå | 69 |
:::

E a fun√ß√£o de _hash_ auxiliar $h'(k)=k\bmod 10$.

Vamos adicionar a chave 81:

- $h(81,0) = (h'(81) + 0) \bmod 10 = (1+0) \bmod 10 = 1$, colis√£o com 21
- $h(81,1) = (h'(81) + 1) \bmod 10 = (1+1) \bmod 10 = 2$, colis√£o com 42
- $h(81,2) = (h'(81) + 2) \bmod 10 = (1+2) \bmod 10 = 3$, colis√£o com 63
- $h(81,3) = (h'(81) + 3) \bmod 10 = (1+3) \bmod 10 = 4$

Como a posi√ß√£o 4 est√° vazia, a chave 81 ser√° alocada l√°.

::: {style="width: 60%; margin: auto;"}
|slot | 0   | 1    |  2   | 3  | 4  | 5   | 6   | 7   | 8   | 9  |
|-----| :----: | :-----: | :-----: | :---: | :---: | :----: | :----: | :----: | :----: | :---: |
| chave  | ‚ùå | 21  | 42  | 63 | 81 | ‚ùå | ‚ùå | ‚ùå | ‚ùå | 69 |
:::


### Sondagem quadr√°tica

A sondagem quadr√°tica procura pela pr√≥xima posi√ß√£o vazia usando uma fun√ß√£o quadr√°tica. 
$$h(k,i) = (h'(k)+c_1i+c_2i^2)\bmod m$$
onde $c_1 e c_2$ s√£o constantes escolhidas e $i=0,1,2,3,\ldots$

Considere o exemplo anterior com sondagem quadr√°tica. Vamos escolher $c_1=0$ e $c_2=1$.

- $h(81,0) = (h'(81) + 0^2) \bmod 10 = (1+0) \bmod 10 = 1$, colis√£o com 21
- $h(81,1) = (h'(81) + 1^2) \bmod 10 = (1+1) \bmod 10 = 2$, colis√£o com 42
- $h(81,2) = (h'(81) + 2^2) \bmod 10 = (1+4) \bmod 10 = 5$


Como a posi√ß√£o 5 est√° vazia, a chave 81 ser√° alocada l√°.

::: {style="width: 60%; margin: auto;"}
|slot | 0   | 1    |  2   | 3  | 4  | 5   | 6   | 7   | 8   | 9  |
|-----| :----: | :-----: | :-----: | :---: | :---: | :----: | :----: | :----: | :----: | :---: |
| chave  | ‚ùå | 21  | 42  | 63 | ‚ùå | 81 | ‚ùå | ‚ùå | ‚ùå | 69 |
:::

### Duplo hash

Como o nome sugere, o tratamento de colis√£o usa duas fun√ß√µes hash ($h_1$ e $h_2$). 
$$h(k,i) = (h_1(k) + i\cdot h_2(k)) \bmod m$$
onde $i=0,1,2,3,\ldots$

Por exemplo, suponha
$h_1(k) = k \bmod 10$ e $h_2(k) = 5 ‚àí (k \bmod 5)$. 

No exemplo anterior teremos:

- $h(81,0) = (h_1(81) + 0 \cdot h_2(81)) \bmod 10 = (1+0) \bmod 10 = 1$, colis√£o com 21
- $h(81,1) = (h_1(81) + 1 \cdot h_2(81)) \bmod 10 = (1 + 4) \bmod 10 = 5$

Ou seja,

::: {style="width: 60%; margin: auto;"}
|slot | 0   | 1    |  2   | 3  | 4  | 5   | 6   | 7   | 8   | 9  |
|-----| :----: | :-----: | :-----: | :---: | :---: | :----: | :----: | :----: | :----: | :---: |
| chave  | ‚ùå | 21  | 42  | 63 | ‚ùå | 81 | ‚ùå | ‚ùå | ‚ùå | 69 |
:::

Abaixo, listamos mais um exemplo considerando as tr√™s abordagens apresentadas:

- chaves: 15, 22, 7, 13, 25 e 14
- tamanho: 7 slots

::: {.panel-tabset}

## Linear

$$h'(k)=k \bmod 7$$
$$h(k,i)=(h'(k)+i) \bmod 7$$


**Chave 15** $\rightarrow h'(15)=15 \bmod 7=1$

- $h(15,0)=(h'(15)+0) \bmod 7=(1+0) \bmod 7=1$

---

**Chave 22** $\rightarrow h'(22)=22 \bmod 7=1$

- $h(22,0)=(h'(22)+0) \bmod 7=(1+0) \bmod 7=1$, ocupado
- $h(22,1)=(h'(22)+1) \bmod 7=(1+1) \bmod 7=2$

---

**Chave 7** $\rightarrow h'(7)=7 \bmod 7=0$

- $h(7,0)=(h'(7)+0) \bmod 7=(0+0) \bmod 7=0$

---

**Chave 13** $\rightarrow h'(13)=13 \bmod 7=6$

- $h(13,0)=(h'(13)+0) \bmod 7=(6+0) \bmod 7=6$

---

**Chave 25** $\rightarrow h'(25)=25 \bmod 7=4$

- $h(25,0)=(h'(25)+0) \bmod 7=(4+0) \bmod 7=4$

---

**Chave 14** $\rightarrow h'(14)=14 \bmod 7=0$

- $h(14,0)=(h'(14)+0) \bmod 7=(0+0) \bmod 7=0$, ocupado
- $h(14,1)=(h'(14)+1) \bmod 7=(0+1) \bmod 7=1$, ocupado
- $h(14,2)=(h'(14)+2) \bmod 7=(0+2) \bmod 7=2$, ocupado
- $h(14,3)=(h'(14)+3) \bmod 7=(0+3) \bmod 7=3$

---

Resultado:

::: {style="width: 60%; margin: auto;"}
|slot | 0   | 1    |  2   | 3  | 4  | 5   | 6   | 
|-----| :----: | :-----: | :-----: | :---: | :---: | :----: | :----: |
| chave  | 7 | 15  | 22  | 14 | 25 | ‚ùå | 13 |
:::


## Quadr√°tico


$$h'(k)=k \bmod 7$$
$$h(k,i)=(h'(k)+i+i^2) \bmod 7$$

**Chave 15** $\rightarrow h'(15)=15 \bmod 7=1$

- $h(15,0)=(h'(15)+0+0^2) \bmod 7=(1+0) \bmod 7=1$

---

**Chave 22** $\rightarrow h'(22)=22 \bmod 7=1$

- $h(22,0)=(h'(22)+0+0^2) \bmod 7=(1+0) \bmod 7=1$, ocupado
- $h(22,1)=(h'(22)+1+1^2) \bmod 7=(1+2) \bmod 7=3$

---

**Chave 7** $\rightarrow h'(7)=7 \bmod 7=0$

- $h(7,0)=(h'(7)+0+0^2) \bmod 7=(0+0) \bmod 7=0$

---

**Chave 13** $\rightarrow h'(13)=13 \bmod 7=6$

- $h(13,0)=(h'(13)+0+0^2) \bmod 7=(6+0) \bmod 7=6$

---

**Chave 25** $\rightarrow h'(25)=25 \bmod 7=4$

- $h(25,0)=(h'(25)+0+0^2) \bmod 7=(4+0) \bmod 7=4$

---

**Chave 14** $\rightarrow h'(14)=14 \bmod 7=0$

- $h(14,0)=(h'(14)+0+0^2) \bmod 7=(0+0) \bmod 7=0$, ocupado
- $h(14,1)=(h'(14)+1+1^2) \bmod 7=(0+2) \bmod 7=2$

---

Resultado:

::: {style="width: 60%; margin: auto;"}
|slot | 0   | 1    |  2   | 3  | 4  | 5   | 6   |  
|-----| :----: | :-----: | :-----: | :---: | :---: | :----: | :----: | 
| chave  | 7 | 15  | 14  | 22 | 25 | ‚ùå | 13 |
:::

## Duplo Hash


$$h_1(k)=k \bmod 7 \qquad h_2(k) = 1 + (k \bmod 6)$$
$$h(k,i)=(h_1(k)+ih_2(k)) \bmod 7$$

**Chave 15** $\rightarrow h_1(15)=15 \bmod 7=1$

- $h(15,0)=(h_1(15)+0\cdot h_2(15)) \bmod 7=(1+0) \bmod 7=1$

---

**Chave 22** $\rightarrow h_1(22)=22 \bmod 7=1$ e $h_2(22)=1+(22 \bmod 6)=5$ 

- $h(22,0)=(h_1(22)+0\cdot h_2(22)) \bmod 7=(1+0) \bmod 7=1$, ocupado
- $h(22,1)=(h_1(22)+1\cdot h_2(22)) \bmod 7=(1+5) \bmod 7=6$

---

**Chave 7** $\rightarrow h_1(7)=7 \bmod 7=0$

- $h(7,0)=(h_1(7)+0\cdot h_2(7)) \bmod 7=(0+0) \bmod 7=0$

---

**Chave 13** $\rightarrow h_1(13)=13 \bmod 7=6$ e $h_2(13)=1+(13 \bmod 6)=2$

- $h(13,0)=(h_1(13)+0\cdot h_2(13)) \bmod 7=(6+0) \bmod 7=6$, ocupado
- $h(13,1)=(h_1(13)+1\cdot h_2(13)) \bmod 7=(6+2) \bmod 7=1$, ocupado
- $h(13,2)=(h_1(13)+2\cdot h_2(13)) \bmod 7=(6+4) \bmod 7=3$

---

**Chave 25** $\rightarrow h_1(25)=25 \bmod 7=4$

- $h(25,0)=(h_1(25)+0\cdot h_2(25)) \bmod 7=(4+0) \bmod 7=4$

---

**Chave 14** $\rightarrow h_1(14)=14 \bmod 7=0$ e $h_2(14)=1+(14 \bmod 6)=3$

- $h(14,0)=(h_1(14)+0\cdot h_2(14)) \bmod 7=(0+0) \bmod 7=0$, ocupado
- $h(14,1)=(h_1(14)+1\cdot h_2(14)) \bmod 7=(0+3) \bmod 7=3$, ocupado
- $h(14,2)=(h_1(14)+2\cdot h_2(14)) \bmod 7=(0+6) \bmod 7=6$, ocupado
- $h(14,3)=(h_1(14)+3\cdot h_2(14)) \bmod 7=(0+9) \bmod 7=2$

---

Resultado:

::: {style="width: 60%; margin: auto;"}
|slot | 0   | 1    |  2   | 3  | 4  | 5   | 6   |  
|-----| :----: | :-----: | :-----: | :---: | :---: | :----: | :----: | 
| chave  | 7 | 15  | 14  | 13 | 25 | ‚ùå | 22 |
:::


:::

## Encadeamento separado

A t√©cnica de encadeamento separado √© bastante simples. Ao inv√©s de tratar a colis√£o procurando um lugar vazio, iremos colocar as colis√µes em uma lista encadeada. Logo, n√£o teremos um vetor de chaves, mas sim um vetor de ponteiros que apontam para listas encadeadas separadamente. 

```{mermaid}
flowchart LR
 subgraph s1["üîë Chaves"]
        A0@{ label: "'ma√ß√£'" }
        B0@{ label: "'uva'" }
        C0@{ label: "'laranja'" }
        D0@{ label: "'banana'" }
        E0@{ label: "'morango'" }
  end
 subgraph s2["‚öôÔ∏è Fun√ß√£o Hash"]
  end
 subgraph s3["üìä Tabela Hash"]
        A2["√çndice 0: ‚ùå"]
        B2["√çndice 1: üîó"]
        C2["√çndice 2: üîó"]
        D2["√çndice 3: üîó"]
        E2["√çndice 4: üîó"]
  end
 subgraph s4[" "]
        C1@{ label: "üéØ 'uva'" }
        B1@{ label: "üéØ 'laranja'" }
        A1@{ label: "üéØ 'ma√ß√£'" }
        D1@{ label: "üéØ 'banana'" }
        E1@{ label: "üéØ 'morango'" }
        n1["NULL"]
        n2["NULL"]
        n3["NULL"]
        n4["NULL"]
  end
    A0 ==> s2
    B0 ==> s2
    C0 ==> s2
    D0 ==> s2
    E0 ==> s2
    s2 ==> B2 & C2 & D2 & E2
    B2 -.- C1
    C2 -.- B1
    D2 -.- A1
    E2 -.- D1
    A1 --> E1
    C1 --> n1
    B1 --> n2
    E1 --> n3
    D1 --> n4

    A0@{ shape: rect}
    B0@{ shape: rect}
    C0@{ shape: rect}
    D0@{ shape: rect}
    E0@{ shape: rect}
    B2@{ shape: rect}
    C2@{ shape: rect}
    D2@{ shape: rect}
    E2@{ shape: rect}
    C1@{ shape: subproc}
    B1@{ shape: subproc}
    A1@{ shape: subproc}
    D1@{ shape: subproc}
    E1@{ shape: subproc}
    n1@{ shape: subproc}
    n2@{ shape: subproc}
    n3@{ shape: subproc}
    n4@{ shape: subproc}
     A0:::box
     B0:::box
     C0:::box
     D0:::box
     E0:::box
     A2:::box
     B2:::box
     C2:::box
     D2:::box
     E2:::box
     n1:::NULL_NODE
     n2:::NULL_NODE
     n3:::NULL_NODE
     n4:::NULL_NODE
    classDef box fill:#fff,stroke:#000,color:#000,stroke-width:1px
    classDef NULL_NODE fill:#F5F5F5, stroke:#BDBDBD, color:#757575, stroke-dasharray: 5 5
    style s2 stroke:none,fill:#BBDEFB
    style s1 stroke:none,fill:#FFE0B2
    style s3 stroke:none,fill:#FFE0B2
    style s4 stroke:none,fill:transparent
    linkStyle 0 stroke:#D50000,fill:none
    linkStyle 1 stroke:#00C853,fill:none
    linkStyle 2 stroke:#2962FF,fill:none
    linkStyle 4 stroke:#D50000,fill:none
    linkStyle 5 stroke:#00C853,fill:none
    linkStyle 6 stroke:#2962FF,fill:none
    linkStyle 7 stroke:#D50000,fill:none
```


No exemplo anterior, quando houve a colis√£o da chave 81 com 21, a posi√ß√£o 1 iria apontar para uma lista ligada com dois componentes.

```{mermaid}
%%| label: fig-mermaid
%%| fig-cap: |
%%|   Ilustra√ß√£o de tratamento de colis√£o usando listas ligadas. 
%%|   Cada slot aponta para a cabe√ßa de uma lista.  
%%|   Quando uma colis√£o ocorre, o elemento √© adicionado √† lista correspondente.
flowchart TD
 subgraph s1["Array"]
        A0["‚ùå"]
        A1["prt_1"]
        A2["prt_2"]
        A3["prt_3"]
        A4["‚ùå"]
        A5["‚ùå"]
        A6["‚ùå"]
        A7["‚ùå"]
        A8["‚ùå"]
        A9["prt_9"]
  end
    A1 -.-> B1["21"]
    B1 --> B2["81"]
    A2 -.-> B3["42"]
    A3 -.-> B4["63"]
    A9 -.-> B5["69"]
    B2 --> n1["Filled Circle"]
    B3 --> n2["Filled Circle"]
    B4 --> n3["Filled Circle"]
    B5 --> n4["Filled Circle"]

    n1@{ shape: f-circ}
    n2@{ shape: f-circ}
    n3@{ shape: f-circ}
    n4@{ shape: f-circ}
    style A1 fill:#fff
    style A2 fill:#fff
    style A3 fill:#fff
    style A9 fill:#fff
    style B1 fill:#fff
    style B2 fill:#fff
    style B3 fill:#fff
    style B4 fill:#fff
    style B5 fill:#fff
```

::: {.callout-note icon="false" title="Exerc√≠cio"}

Use a abordagem de encadeamento separado para criar uma tabela _hash_ com as chaves $$k = \{15, 22, 7, 13, 25, 14, 1, 8, 2, 9, 3, 10, 4, 11, 5, 6, 20, 21, 28\}.$$ Considere a fun√ß√£o de _hash_ $h(k)=k\bmod m$, onde $m=7$ √© o tamanho do vetor.
:::


<!-- mermaid n√£o renderiza dentro deum callout collapsable -->
<!-- A solu√ß√£o consiste em instalar o chromium para tranformar em um figura
     quarto install tool chromium -->
<!-- N√£o √© poss√≠vel fazer isso no WSL, ent√£o a solu√ß√£o foi fazer:
     - cd /tmp
     - wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb
     - sudo apt install -f ./google-chrome-stable_current_amd64.deb  -->

::: {.callout-tip title="Solu√ß√£o (clique para ver)" collapse="true"}
```{mermaid}
%%| fig-align: center
%%| mermaid-format: svg
flowchart TD
 subgraph s1[" "]
        A0["prt_0"]
        A1["prt_1"]
        A2["prt_2"]
        A3["prt_3"]
        A4["prt_4"]
        A5["prt_5"]
        A6["prt_6"]
  end
    A0 -.-> K7[07]
    K7 --> K14[14]
    K14 --> K21[21]
    K21 --> K28[28]
    K28 --> n0["Filled Circle"]
   

    A1 -.-> K15[15]
    K15 --> K22[22]
    K22 --> K1[01]
    K1 --> K8[08]
    K8 --> n1["Filled Circle"]
   

    A2 -.-> K2[02]
    K2 --> K9[09]
    K9 --> n2["Filled Circle"]
   

    A3 -.-> K3[03]
    K3 --> K10[10]
    K10 --> n3["Filled Circle"]
   
    A4 -.-> K25[25]
    K25 --> K4[04]
    K4 --> K11[11]
    K11 --> n4["Filled Circle"]
   
    A5 -.-> K5[05]
    K5 --> n5["Filled Circle"]
   
    A6 -.-> K13[13]
    K13 --> K6[06]
    K6 --> K20[20]
    K20 --> n6["Filled Circle"]
   
    n0@{ shape: f-circ}
    n1@{ shape: f-circ}
    n2@{ shape: f-circ}
    n3@{ shape: f-circ}
    n4@{ shape: f-circ}
    n5@{ shape: f-circ}
    n6@{ shape: f-circ}

```
:::

---

Nesta unidade, voc√™ aprendeu

‚úÖ a identificar quando uma colis√£o ocorre 

‚úÖ os principais met√≥dos para tratar colis√µes
 

```quizdown

# Quando ocorre uma colis√£o em uma tabela hash?

> Pense no resultado da fun√ß√£o hash para chaves diferentes.

1. [ ] Quando duas chaves s√£o id√™nticas.  
1. [x] Quando duas chaves diferentes produzem o mesmo valor hash.  
1. [ ] Quando o vetor est√° totalmente vazio.  
1. [ ] Quando a fun√ß√£o hash retorna sempre zero.  


# Quais s√£o as principais t√©cnicas para tratamento de colis√µes?

> Existem duas abordagens gerais descritas no texto.

- [x] Endere√ßamento aberto  
- [x] Encadeamento separado  
- [ ] Sondagem aleat√≥ria  
- [ ] Redimensionamento din√¢mico  


# Complete a ordem correta das sondagens no endere√ßamento aberto!

> Considere o modo como o algoritmo busca novas posi√ß√µes vazias.

1. Sondagem linear  
2. Sondagem quadr√°tica  
3. Duplo hash  

# Como funciona a sondagem linear?

> Veja a f√≥rmula $h(k,i) = (h'(k) + i) \bmod m$.

1. [ ] Utiliza duas fun√ß√µes hash diferentes.  
1. [x] Incrementa o √≠ndice em uma unidade at√© encontrar posi√ß√£o vazia.  
1. [ ] Usa pot√™ncias de $i$ para procurar posi√ß√µes.  
1. [ ] Usa listas encadeadas para armazenar colis√µes.  

# Na sondagem quadr√°tica, a fun√ß√£o hash usa quais termos?

> Observe a f√≥rmula $h(k,i) = (h'(k) + c_1 i + c_2 i^2) \bmod m$.

- [x] Um termo linear ($c_1 i$)  
- [x] Um termo quadr√°tico ($c_2 i^2$)  
- [ ] Um termo c√∫bico ($c_3 i^3$)  
- [ ] Um termo logar√≠tmico ($\log i$)  

# No duplo hash, o c√°lculo depende de duas fun√ß√µes hash. Quais delas s√£o usadas?

> Elas aparecem como $h_1(k)$ e $h_2(k)$.

- [x] $h_1(k)$  
- [x] $h_2(k)$  
- [ ] $h_3(k)$  
- [ ] Nenhuma, √© uma sondagem linear disfar√ßada  

# Coloque em ordem os tr√™s m√©todos de endere√ßamento aberto apresentados!

> Do mais simples ao mais sofisticado.

1. Sondagem linear  
2. Sondagem quadr√°tica  
3. Duplo hash  

# Qual √© a ideia principal do encadeamento separado?

> Considere o uso de ponteiros e listas encadeadas.

1. [ ] Procurar um slot vazio no vetor.  
1. [ ] Remover elementos duplicados automaticamente.  
1. [x] Manter listas encadeadas separadas para cada posi√ß√£o da tabela.  
1. [ ] Usar fun√ß√µes hash aleat√≥rias para evitar colis√µes.  
```

{{< include /_includes/progress-bar.qmd >}}



