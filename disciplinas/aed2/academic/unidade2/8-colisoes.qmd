---
title: "Tratamento de Colisões"
toc-title: Conteúdo
toc: false
sidebar: false
format: 
  html:
    reference-location: margin
    css: ../styles/academic.css 
---


Sabemos que uma colisão ocorre quando a função _hash_ produz o mesmo valor para duas ou mais chaves
distintas. Isto é:
$$h(k1) = h(k2)$$

Colisões são praticamente inevitáveis, por isso devemos tratá-las. As principais
abordagens são endereçamento aberto e encadeamento separado.

- **Endereçamento aberto**: percorrer a tabela em busca de um local não ocupado.
- **Encadeamento separado**: uso de listas ligadas para armazenar as colisões.

::: {.column-margin}
**[Se liga!]{.text-warning}**
Endereçamento aberto: procura um endereço aberto, um slot vazio.
Encadeamento separado: usa listas encadeadas separadas, uma para cada slot.
:::

## Endereçamento aberto

A técnica de endereçamento aberto tenta resolver o problema de colisão buscando
um outro lugar vazio para armazenar a chave que colidiu. As maneiras principais de sondar um espaço vazio são:

- Sondagem linear;
- Sondagem quadrática;
- Duplo hash

### Sondagem linear

A sondagem linear procura pela próxima posição vazia do vetor. A função de hash possui uma nova variável iterativa que permitirá a procura por esse lugar vazio:
$$h(k,i) = (h'(k)+i)\bmod m$$
onde $i=0,1,2,3,\ldots$

Sempre que ocorre uma colisão, esta variável ($i$) é incrementada em uma unidade.

Por exemplo, considere o vetor abaixo:

::: {style="width: 60%; margin: auto;"}
|slot | 0   | 1    |  2   | 3  | 4  | 5   | 6   | 7   | 8   | 9  |
|-----| :----: | :-----: | :-----: | :---: | :---: | :----: | :----: | :----: | :----: | :---: |
| chave  | ❌ | 21  | 42  | 63 | ❌ | ❌ | ❌ | ❌ | ❌ | 69 |
:::

E a função de _hash_ auxiliar $h'(k)=k\bmod 10$.

Vamos adicionar a chave 81:

- $h(81,0) = (h'(81) + 0) \bmod 10 = (1+0) \bmod 10 = 1$, colisão com 21
- $h(81,1) = (h'(81) + 1) \bmod 10 = (1+1) \bmod 10 = 2$, colisão com 42
- $h(81,2) = (h'(81) + 2) \bmod 10 = (1+2) \bmod 10 = 3$, colisão com 63
- $h(81,3) = (h'(81) + 3) \bmod 10 = (1+3) \bmod 10 = 4$

Como a posição 4 está vazia, a chave 81 será alocada lá.

::: {style="width: 60%; margin: auto;"}
|slot | 0   | 1    |  2   | 3  | 4  | 5   | 6   | 7   | 8   | 9  |
|-----| :----: | :-----: | :-----: | :---: | :---: | :----: | :----: | :----: | :----: | :---: |
| chave  | ❌ | 21  | 42  | 63 | 81 | ❌ | ❌ | ❌ | ❌ | 69 |
:::


### Sondagem quadrática

A sondagem quadrática procura pela próxima posição vazia usando uma função quadrática. 
$$h(k,i) = (h'(k)+c_1i+c_2i^2)\bmod m$$
onde $c_1 e c_2$ são constantes escolhidas e $i=0,1,2,3,\ldots$

Considere o exemplo anterior com sondagem quadrática. Vamos escolher $c_1=0$ e $c_2=1$.

- $h(81,0) = (h'(81) + 0^2) \bmod 10 = (1+0) \bmod 10 = 1$, colisão com 21
- $h(81,1) = (h'(81) + 1^2) \bmod 10 = (1+1) \bmod 10 = 2$, colisão com 42
- $h(81,2) = (h'(81) + 2^2) \bmod 10 = (1+4) \bmod 10 = 5$


Como a posição 5 está vazia, a chave 81 será alocada lá.

::: {style="width: 60%; margin: auto;"}
|slot | 0   | 1    |  2   | 3  | 4  | 5   | 6   | 7   | 8   | 9  |
|-----| :----: | :-----: | :-----: | :---: | :---: | :----: | :----: | :----: | :----: | :---: |
| chave  | ❌ | 21  | 42  | 63 | ❌ | 81 | ❌ | ❌ | ❌ | 69 |
:::

### Duplo hash

Como o nome sugere, o tratamento de colisão usa duas funções hash ($h_1$ e $h_2$). 
$$h(k,i) = (h_1(k) + i\cdot h_2(k)) \bmod m$$
onde $i=0,1,2,3,\ldots$

Por exemplo, suponha
$h_1(k) = k \bmod 10$ e $h_2(k) = 5 − (k \bmod 5)$. 

No exemplo anterior teremos:

- $h(81,0) = (h_1(81) + 0 \cdot h_2(81)) \bmod 10 = (1+0) \bmod 10 = 1$, colisão com 21
- $h(81,1) = (h_1(81) + 1 \cdot h_2(81)) \bmod 10 = (1 + 4) \bmod 10 = 5$

Ou seja,

::: {style="width: 60%; margin: auto;"}
|slot | 0   | 1    |  2   | 3  | 4  | 5   | 6   | 7   | 8   | 9  |
|-----| :----: | :-----: | :-----: | :---: | :---: | :----: | :----: | :----: | :----: | :---: |
| chave  | ❌ | 21  | 42  | 63 | ❌ | 81 | ❌ | ❌ | ❌ | 69 |
:::

Abaixo, listamos mais um exemplo considerando as três abordagens apresentadas:

- chaves: 15, 22, 7, 13, 25 e 14
- tamanho: 7 slots

::: {.panel-tabset}

## Linear

$$h'(k)=k \bmod 7$$
$$h(k,i)=(h'(k)+i) \bmod 7$$


**Chave 15** $\rightarrow h'(15)=15 \bmod 7=1$

- $h(15,0)=(h'(15)+0) \bmod 7=(1+0) \bmod 7=1$

---

**Chave 22** $\rightarrow h'(22)=22 \bmod 7=1$

- $h(22,0)=(h'(22)+0) \bmod 7=(1+0) \bmod 7=1$, ocupado
- $h(22,1)=(h'(22)+1) \bmod 7=(1+1) \bmod 7=2$

---

**Chave 7** $\rightarrow h'(7)=7 \bmod 7=0$

- $h(7,0)=(h'(7)+0) \bmod 7=(0+0) \bmod 7=0$

---

**Chave 13** $\rightarrow h'(13)=13 \bmod 7=6$

- $h(13,0)=(h'(13)+0) \bmod 7=(6+0) \bmod 7=6$

---

**Chave 25** $\rightarrow h'(25)=25 \bmod 7=4$

- $h(25,0)=(h'(25)+0) \bmod 7=(4+0) \bmod 7=4$

---

**Chave 14** $\rightarrow h'(14)=14 \bmod 7=0$

- $h(14,0)=(h'(14)+0) \bmod 7=(0+0) \bmod 7=0$, ocupado
- $h(14,1)=(h'(14)+1) \bmod 7=(0+1) \bmod 7=1$, ocupado
- $h(14,2)=(h'(14)+2) \bmod 7=(0+2) \bmod 7=2$, ocupado
- $h(14,3)=(h'(14)+3) \bmod 7=(0+3) \bmod 7=3$

---

Resultado:

::: {style="width: 60%; margin: auto;"}
|slot | 0   | 1    |  2   | 3  | 4  | 5   | 6   | 
|-----| :----: | :-----: | :-----: | :---: | :---: | :----: | :----: |
| chave  | 7 | 15  | 22  | 14 | 25 | ❌ | 13 |
:::


## Quadrático


$$h'(k)=k \bmod 7$$
$$h(k,i)=(h'(k)+i+i^2) \bmod 7$$

**Chave 15** $\rightarrow h'(15)=15 \bmod 7=1$

- $h(15,0)=(h'(15)+0+0^2) \bmod 7=(1+0) \bmod 7=1$

---

**Chave 22** $\rightarrow h'(22)=22 \bmod 7=1$

- $h(22,0)=(h'(22)+0+0^2) \bmod 7=(1+0) \bmod 7=1$, ocupado
- $h(22,1)=(h'(22)+1+1^2) \bmod 7=(1+2) \bmod 7=3$

---

**Chave 7** $\rightarrow h'(7)=7 \bmod 7=0$

- $h(7,0)=(h'(7)+0+0^2) \bmod 7=(0+0) \bmod 7=0$

---

**Chave 13** $\rightarrow h'(13)=13 \bmod 7=6$

- $h(13,0)=(h'(13)+0+0^2) \bmod 7=(6+0) \bmod 7=6$

---

**Chave 25** $\rightarrow h'(25)=25 \bmod 7=4$

- $h(25,0)=(h'(25)+0+0^2) \bmod 7=(4+0) \bmod 7=4$

---

**Chave 14** $\rightarrow h'(14)=14 \bmod 7=0$

- $h(14,0)=(h'(14)+0+0^2) \bmod 7=(0+0) \bmod 7=0$, ocupado
- $h(14,1)=(h'(14)+1+1^2) \bmod 7=(0+2) \bmod 7=2$

---

Resultado:

::: {style="width: 60%; margin: auto;"}
|slot | 0   | 1    |  2   | 3  | 4  | 5   | 6   |  
|-----| :----: | :-----: | :-----: | :---: | :---: | :----: | :----: | 
| chave  | 7 | 15  | 14  | 22 | 25 | ❌ | 13 |
:::

## Duplo Hash


$$h_1(k)=k \bmod 7 \qquad h_2(k) = 1 + (k \bmod 6)$$
$$h(k,i)=(h_1(k)+ih_2(k)) \bmod 7$$

**Chave 15** $\rightarrow h_1(15)=15 \bmod 7=1$

- $h(15,0)=(h_1(15)+0\cdot h_2(15)) \bmod 7=(1+0) \bmod 7=1$

---

**Chave 22** $\rightarrow h_1(22)=22 \bmod 7=1$ e $h_2(22)=1+(22 \bmod 6)=5$ 

- $h(22,0)=(h_1(22)+0\cdot h_2(22)) \bmod 7=(1+0) \bmod 7=1$, ocupado
- $h(22,1)=(h_1(22)+1\cdot h_2(22)) \bmod 7=(1+5) \bmod 7=6$

---

**Chave 7** $\rightarrow h_1(7)=7 \bmod 7=0$

- $h(7,0)=(h_1(7)+0\cdot h_2(7)) \bmod 7=(0+0) \bmod 7=0$

---

**Chave 13** $\rightarrow h_1(13)=13 \bmod 7=6$ e $h_2(13)=1+(13 \bmod 6)=2$

- $h(13,0)=(h_1(13)+0\cdot h_2(13)) \bmod 7=(6+0) \bmod 7=6$, ocupado
- $h(13,1)=(h_1(13)+1\cdot h_2(13)) \bmod 7=(6+2) \bmod 7=1$, ocupado
- $h(13,2)=(h_1(13)+2\cdot h_2(13)) \bmod 7=(6+4) \bmod 7=3$

---

**Chave 25** $\rightarrow h_1(25)=25 \bmod 7=4$

- $h(25,0)=(h_1(25)+0\cdot h_2(25)) \bmod 7=(4+0) \bmod 7=4$

---

**Chave 14** $\rightarrow h_1(14)=14 \bmod 7=0$ e $h_2(14)=1+(14 \bmod 6)=3$

- $h(14,0)=(h_1(14)+0\cdot h_2(14)) \bmod 7=(0+0) \bmod 7=0$, ocupado
- $h(14,1)=(h_1(14)+1\cdot h_2(14)) \bmod 7=(0+3) \bmod 7=3$, ocupado
- $h(14,2)=(h_1(14)+2\cdot h_2(14)) \bmod 7=(0+6) \bmod 7=6$, ocupado
- $h(14,3)=(h_1(14)+3\cdot h_2(14)) \bmod 7=(0+9) \bmod 7=2$

---

Resultado:

::: {style="width: 60%; margin: auto;"}
|slot | 0   | 1    |  2   | 3  | 4  | 5   | 6   |  
|-----| :----: | :-----: | :-----: | :---: | :---: | :----: | :----: | 
| chave  | 7 | 15  | 14  | 13 | 25 | ❌ | 22 |
:::


:::

## Encadeamento separado

A técnica de encadeamento separado é bastante simples. Ao invés de tratar a colisão procurando um lugar vazio, iremos colocar as colisões em uma lista encadeada. Logo, não teremos um vetor de chaves, mas sim um vetor de ponteiros que apontam para listas encadeadas separadamente. 

No exemplo anterior, quando houve a colisão da chave 81 com 21, a posição 1 iria apontar para uma lista ligada com dois componentes.

```{mermaid}
%%| label: fig-mermaid
%%| fig-cap: |
%%|   Ilustração de tratamento de colisão usando listas ligadas. 
%%|   Cada slot aponta para a cabeça de uma lista.  
%%|   Quando uma colisão ocorre, o elemento é adicionado à lista correspondente.
flowchart TD
 subgraph s1["Array"]
        A0["❌"]
        A1["prt_1"]
        A2["prt_2"]
        A3["prt_3"]
        A4["❌"]
        A5["❌"]
        A6["❌"]
        A7["❌"]
        A8["❌"]
        A9["prt_9"]
  end
    A1 -.-> B1["21"]
    B1 --> B2["81"]
    A2 -.-> B3["42"]
    A3 -.-> B4["63"]
    A9 -.-> B5["69"]
    B2 --> n1["Filled Circle"]
    B3 --> n2["Filled Circle"]
    B4 --> n3["Filled Circle"]
    B5 --> n4["Filled Circle"]

    n1@{ shape: f-circ}
    n2@{ shape: f-circ}
    n3@{ shape: f-circ}
    n4@{ shape: f-circ}
    style A1 fill:#fff
    style A2 fill:#fff
    style A3 fill:#fff
    style A9 fill:#fff
    style B1 fill:#fff
    style B2 fill:#fff
    style B3 fill:#fff
    style B4 fill:#fff
    style B5 fill:#fff
```

::: {.callout-note icon="false" title="Exercício"}

Use a abordagem de encadeamento separado para criar uma tabela _hash_ com as chaves $$k = \{15, 22, 7, 13, 25, 14, 1, 8, 2, 9, 3, 10, 4, 11, 5, 6, 20, 21, 28\}.$$ Considere a função de _hash_ $h(k)=k\bmod m$, onde $m=7$ é o tamanho do vetor.
:::

<!-- mermaid não renderiza dentro deum callout collapsable -->
<!-- A solução consiste em instalar o chromium para tranformar em um figura
     quarto install tool chromium -->
<!-- Não é possível fazer isso no WSL, então a solução foi fazer:
     - cd /tmp
     - wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb
     - sudo apt install -f ./google-chrome-stable_current_amd64.deb  -->

::: {.callout-tip title="Solução (clique para ver)" collapse="true"}
```{mermaid}
%%| fig-align: center
%%| mermaid-format: svg
flowchart TD
 subgraph s1[" "]
        A0["prt_0"]
        A1["prt_1"]
        A2["prt_2"]
        A3["prt_3"]
        A4["prt_4"]
        A5["prt_5"]
        A6["prt_6"]
  end
    A0 -.-> K7[07]
    K7 --> K14[14]
    K14 --> K21[21]
    K21 --> K28[28]
    K28 --> n0["Filled Circle"]
   

    A1 -.-> K15[15]
    K15 --> K22[22]
    K22 --> K1[01]
    K1 --> K8[08]
    K8 --> n1["Filled Circle"]
   

    A2 -.-> K2[02]
    K2 --> K9[09]
    K9 --> n2["Filled Circle"]
   

    A3 -.-> K3[03]
    K3 --> K10[10]
    K10 --> n3["Filled Circle"]
   
    A4 -.-> K25[25]
    K25 --> K4[04]
    K4 --> K11[11]
    K11 --> n4["Filled Circle"]
   
    A5 -.-> K5[05]
    K5 --> n5["Filled Circle"]
   
    A6 -.-> K13[13]
    K13 --> K6[06]
    K6 --> K20[20]
    K20 --> n6["Filled Circle"]
   
    n0@{ shape: f-circ}
    n1@{ shape: f-circ}
    n2@{ shape: f-circ}
    n3@{ shape: f-circ}
    n4@{ shape: f-circ}
    n5@{ shape: f-circ}
    n6@{ shape: f-circ}

```
:::

---

Nesta unidade, você aprendeu

✅ a identificar quando uma colisão ocorre 

✅ os principais metódos para tratar colisões
 

{{< include /_includes/progress-bar.qmd >}}



