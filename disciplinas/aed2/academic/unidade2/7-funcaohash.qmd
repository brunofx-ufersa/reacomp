---
title: "Fun√ß√£o Hash"
lang: pt
toc-title: Conte√∫do
toc: false
sidebar: false
format:
  html:
    reference-location: margin
    css: ../styles/academic.css
filters: 
    - quizdown    
---

A fun√ß√£o _hash_ √© usada para mapear uma chave para um valor, gerando um c√≥digo hash que, por sua vez, √© usado para encontrar a localiza√ß√£o de um item em uma estrutura de dados como uma tabela hash.



```{mermaid}
%%| fig-width: 6.5
flowchart LR
 subgraph s1["üîë Chaves"]
        A0["'ma√ß√£'"]
        B0["'uva'"]
        C0["'laranja'"]
        D0["'banana'"]
  end
 subgraph s2["‚öôÔ∏è Fun√ß√£o Hash"]
  end
 subgraph s3["üìä Tabela Hash"]
        A2["√çndice 0: ‚ùå      "]
        B2["√çndice 1: 'laranja'"]
        C2["√çndice 2: 'uva'"]
        D2["√çndice 3: 'ma√ß√£'"]
        E2["√çndice 4: 'banana'"]
  end
    A0 ==> s2
    B0 ==> s2
    C0 ==> s2
    D0 ==> s2
    s2 =="h('laranja')=1"==> B2
    s2 =="h('uva')=2"==> C2
    s2 =="h('ma√ß√£')=3"==> D2
    s2 =="h('banana')=4"==> E2

    classDef box fill:#fff,stroke:#000,color:#000,stroke-width:1px;
    
    class A0 box
    class B0 box
    class C0 box
    class D0 box
    class A2 box
    class B2 box
    class C2 box
    class D2 box
    class E2 box
    
    style s2 stroke:none,fill:#BBDEFB
    style s1 stroke:none,fill:#FFE0B2
    style s3 stroke:none,fill:#FFE0B2
    
    linkStyle 0 stroke:#D50000,fill:none
    linkStyle 1 stroke:#00C853,fill:none
    linkStyle 2 stroke:#2962FF,fill:none
    linkStyle 4 stroke:#2962FF
    linkStyle 5 stroke:#00C853,fill:none
    linkStyle 6 stroke:#D50000,fill:none
```

## Caracter√≠sticas da Fun√ß√£o Hash
	
√â desej√°vel que a fun√ß√£o _hash_ possua as seguintes caracter√≠sticas.

- F√°cil de ser calculada;
- Distribui√ß√£o uniforme dos dados;
- Minimiza as colis√µes;
- Capaz de resolver poss√≠veis colis√µes.

A vantagem da tabela hash √© a velocidade de busca, uma fun√ß√£o muito complicada para calcular √© incoveniente, pois pode demorar mais que uma busca em uma √°rvore bin√°ria, por exemplo. Al√©m disso, se a fun√ß√£o n√£o distribui as chaves de maneira uniforme, muitas delas ir√£o se concentrar em um local do vetor, aumentando a probabilidade de colis√µes.

::: {.column-margin}
**[Se liga!]{.text-warning}**
Quando muitas chaves se concentram um lugar, dizemos que se formou um _cluster_ (aglomerado).
:::

A seguir, vamos estudar os m√©todos cl√°ssicos para cria√ß√£o de fun√ß√µes _hash_.

## M√©todo da Divis√£o
	
No m√©todo da divis√£o, usamos o resultado do resto da divis√£o do valor da chave pelo tamanho da tabela.
 $$h(k) = k \bmod m$$

O ideal √© que $m$ seja um n√∫mero primo e n√£o muito pr√≥ximo de pot√™ncias de $2$.
	
Por exemplo, se $k=12345$ e $m=101$, ent√£o
$$h(k) = h(12345)= 12345 \bmod 101 = 22$$

A chave $12345$ deve ser alocada na posi√ß√£o $22$ do vetor de $101$ posi√ß√µes.	
	
::: {.column-margin}
**[Se liga!]{.text-warning}**
Nem sempre trateremos com chaves inteiras simples como as vistas at√© aqui. Nesses casos, precisamos de um mecanismo para transformar em um valor inteiro antes de processar a fun√ß√£o hash. Veremos isso √† frente.
:::


Este √© o m√©todo mais simples e f√°cil de gerar um valor de hash. A fun√ß√£o hash divide o valor $k$ (chave) por $m$ (tamanho da tabela) e, em seguida, usa o resto obtido. √â mais adequado que $m$ seja um n√∫mero primo, pois isso pode garantir que as chaves sejam distribu√≠das de forma mais uniforme. 

Embora simples, o m√©todo da divis√£o leva a um desempenho ruim, uma vez que chaves consecutivas mapeiam para valores de hash consecutivos na tabela de hash.
	
::: {.callout-note icon="false" title="Exerc√≠cio"}
Dada a fun√ß√£o hash $h(k) = k^2\bmod 7$, calcule os valores hash para as chaves $$4, 17, 13, 35, 25, 11, 2, 10, 32$$.
:::

::: {.callout-tip title="Solu√ß√£o (clique para ver)" collapse="true"}
- $h(4)\,\,\,=\,\,\,4^2\bmod 7=16\bmod 7\,\,\,\,\,\,=2$
- $h(17)=17^2\bmod 7=289\bmod 7\,\,\,=2$
- $h(13)=13^2\bmod 7=169\bmod 7\,\,\,=1$
- $h(35)=35^2\bmod 7=1225\bmod 7=0$
- $h(25)=25^2\bmod 7=625\bmod 7\,\,\,=2$
- $h(11)=11^2\bmod 7=121\bmod 7\,\,\,=2$
- $h(2)\,\,\,=\,\,\,2^2\bmod 7=4\bmod 7\,\,\,\,\,\,\,\,\,=4$
- $h(10)=10^2\bmod 7=100\bmod 7\,\,\,=2$
- $h(32)=32^2\bmod 7=1024\bmod 7=2$

Muitas colis√µes ocorreram! Era evidente que haveria sobreposi√ß√£o de chaves, pois temos somentes sete espa√ßos. 
:::

## M√©todo da Multiplica√ß√£o

No m√©todo da multiplica√ß√£o, realizamos os seguintes passos:

- Multiplicamos a chave ($k$) por uma constante $A$ entre $0$ e $1$;
- Extra√≠mos a parte fracion√°ria de $kA$;
- Multiplicamos esse valor por $m$ (tamanho da tabela);
- Arredondamos para baixo;

Ou seja,
$$h(k) = \lfloor m (kA \bmod 1) \rfloor, \text{ com } 0 < A < 1$$

Por exemplo, considere $k = 123$, $m = 1000$, e $A \approx 0,618$.

\begin{align*}
h(k) &= \lfloor 1000 (123 \cdot 0,618 \bmod 1) \rfloor \\
&=\lfloor 1000 (76,014 \bmod 1) \rfloor \\ &=\lfloor 1000\cdot 0,014 \rfloor=14
\end{align*}
	
A vantagem deste m√©todo √© que ele pode trabalhar com qualquer valor entre 0 e 1. 

::: {.column-margin}
**[Se liga!]{.text-warning}**
O m√©todo de multiplica√ß√£o √© geralmente adequado quando o tamanho da tabela √© uma pot√™ncia de dois.	
:::

::: {.callout-note icon="false" title="Exerc√≠cio"}
Seja a chave $k = 12345$, a constante $A = 0,357840$ e o tamanho da tabela $m = 100$, calcule o valor hash usando o m√©todo da multiplica√ß√£o.
:::

::: {.callout-tip title="Solu√ß√£o (clique para ver)" collapse="true"}
$$h(k) = \lfloor m (kA \bmod 1) \rfloor$$
$h(12345) = \lfloor 100 (12345\cdot 0,357840 \bmod 1) \rfloor=\lfloor 100 (4417,5348 \bmod 1) \rfloor=\lfloor 100 (0,5348) \rfloor=\lfloor 53,48 \rfloor=53$
:::

## Hashing Universal

O hash universal tenta resolver o problema das colis√µes usando uma fam√≠lia de fun√ß√µes de hash, $\mathcal{H}$, que possui uma propriedade matem√°tica crucial:

> Para quaisquer duas chaves distintas, $k_1$ e $k_2$, a probabilidade de que a fun√ß√£o de hash $h \in \mathcal{H}$ escolhida aleatoriamente cause uma colis√£o √© no m√°ximo igual √† probabilidade de colis√£o aleat√≥ria, que √© $1/m$, onde $m$ √© o n√∫mero de posi√ß√µes na tabela hash.

Uma das fam√≠lias universais mais usadas para chaves que s√£o n√∫meros inteiros e uma tabela de tamanho $m$ √© definida da seguinte forma:

Seja $p$ um n√∫mero primo maior que qualquer chave poss√≠vel, e $m$ o tamanho da tabela hash. A fam√≠lia $\mathcal{H}$ √© o conjunto de fun√ß√µes $h_{a,b}$ dadas pela f√≥rmula:
$$h_{a,b}(k) = ((ak + b) \bmod p) \bmod m$$

Onde $a$ e $b$ s√£o par√¢metros **inteiros** aleat√≥rios escolhidos no in√≠cio, com $a\in[1, p-1]$ e $b\in[0, p-1]$.
  
Os par√¢metros aleat√≥rios ajudam a dispersar o valor da chave. J√° a opera√ß√£o de m√≥dulo por um primo $p$ ajuda a garantir que a distribui√ß√£o do resultado seja uniforme no intervalo $[0, p-1]$. Finalmente, o resultado final √© mapeado para o √≠ndice da tabela hash, no intervalo $[0, m-1]$. 
  
Por exemplo, digamos uma tabela com $m=10$ slots e escolhamos $p=103$.

- Sorteamos $a$ entre $1$ e $p-1$, ou seja, no intervalo $[1, 102]$ 
- Sorteamos $b$ entre $0$ e $p-1$, ou seja, no intervalo $[0, 102]$ 

Digamos que $a=5$ e $b=13$, ent√£o nossa fun√ß√£o sorteada da fam√≠lia universal ser√°:
$$h_{5,13}(k)=((5k+13)\bmod103)\bmod 10$$

Vamos calcular alguns valores de hash para fixa√ß√£o.

- $h(4)\,\,\,=\,\,\,((5\cdot4+13)\bmod103)\bmod 10=\,\,\,(33\bmod103)\bmod 10=33 \bmod 10=3$
- $h(17)=((5\cdot17+13)\bmod103)\bmod 10=\,\,\,(98\bmod103)\bmod 10= 98\bmod 10=8$
- $h(25)=((5\cdot25+13)\bmod103)\bmod 10=(138\bmod103)\bmod 10=35\bmod 10=5$
- $h(32)=((5\cdot32+13)\bmod103)\bmod 10=(173\bmod103)\bmod 10=70\bmod 10=0$


Mesmo com os melhores m√©todos, √© imposs√≠vel evitar colis√µes. Quando acontece, devemos trat√°-la de modo que o desempenho da busca n√£o seja muito afetado. No entanto, antes de estudarmos os tratamentos de coli√ß√µes, iremos abordar as estrat√©gias para mapeamento de chaves em inteiros.


## Estrat√©gias para Mapeamento

Quando falamos em mapeamento de chaves em inteiros, estamos nos referindo a um pr√©-processamento que transforma uma chave (como uma string ou um n√∫mero muito grande) em um inteiro mais adequado para ser usado por uma fun√ß√£o de hash.

Embora seja poss√≠vel criar suas pr√≥prias estrat√©gias, apresentamos a seguir alguns m√©todos cl√°ssicos encontrados na literatura.

### Chaves do tipo _string_

Os m√©todos cl√°ssicos para tratar strings usam o fato de cada letra ter um inteiro correspondente na tabela ASCII.

#### Soma

Muitas vezes, as chaves que estamos trabalhando s√£o _strings_. Uma forma simples de convert√™-las em inteiros √© somar os valores ASCII de cada caractere:
$$k=\sum_{i=0}^{n-1}s[i]=s[0]+s[1]+s[2]+\cdots+s[n-1]$$

onde $n$ √© o tamanho da palavra.

Por exemplo, a palavra "PAI" (P = 80, A = 65 e I = 73):
$$k=\sum_{i=0}^{3-1}s[i]=\sum_{i=0}^{2}s[i]=s[0]+s[1]+s[2]=80+65+73=218$$

Esse m√©todo √© simples, mas apresenta m√° distribui√ß√£o, ou seja, palavras com as mesmas letras em ordem diferente geram o mesmo valor.

#### Multiplica√ß√£o Polinomial

Um m√©todo mais robusto √© o da **multiplica√ß√£o polinomial**. Aqui, tratamos a _string_ como um n√∫mero em uma base $\beta$ (geralmente um n√∫mero primo pequeno):
$$k=\sum_{i=0}^{n-1}s[i]\beta^{(n-1)-i}=s[0]\cdot\beta^{n-1}+s[1]\cdot\beta^{n-2}+\cdots+s[n-1]\cdot\beta^{0}$$

Por exemplo, a palavra "PAI" (P = 80, A = 65 e I = 73) e $\beta=13$:
\begin{align*}
k&=s[0]\cdot 13^{3-1}+s[1]\cdot 13^{3-2}+s[2]\cdot 13^{3-3}\\
&=80\cdot13^2+65\cdot13^1+73\cdot13^0\\
&=14438
\end{align*}

::: {.column-margin}
**[Se liga!]{.text-warning}**
A multiplica√ß√£o por um n√∫mero primo ajuda a espalhar os valores de forma mais uniforme do que se us√°ssemos um n√∫mero composto.
:::

Essa t√©cnica √© superior √† soma simples, pois considera a ordem dos caracteres. Para palavras como "cama" e "maca", a soma simples ir√° retornar os mesmos valores, enquanto que a multiplica√ß√£o polinomial n√£o.

Exemplo simples: 

- $BA : 66\cdot13^1 + 65\cdot13^0 = 923$.
- $AB : 65\cdot13^1 + 66\cdot13^0 = 911$.

Dessa forma, "BA" e "AB" produzem resultados distintos, evitando colis√µes triviais.

### Chaves do tipo _int_ grandes

Quando lidamos com inteiros muito grandes, precisamos reduzi-los para evitar estouro de capacidade (overflow) ou para encaix√°-los em um intervalo menor. A seguir, apresentamos tr√™s m√©todos comuns: dobramento (folding), XOR e quadrado central (mid-square).

#### Dobramento (Folding)

Consiste em dividir a chave em partes menores e, em seguida, som√°-las ou aplicar XOR entre elas para gerar um n√∫mero reduzido. Por exemplo, suponha $k = 83.529.170$, vamos dividir a chave assim:

- $k_1 = 835$
- $k_2 = 291$
- $k_3 = 70$

O dobramento por soma resulta em $k_1+k_2+k_3=835+291+70=1196$.

No dobramento por XOR, as partes s√£o combinadas usando a opera√ß√£o l√≥gica OU exclusivo (XOR), muito comum em fun√ß√µes de hash criptogr√°ficas. Primeiro, convertemos as partes para bin√°rio (aqui, usando 10 bits para simplificar):


::: {style="width: 60%; margin: auto;"}
| Parte | Decimal | Bin√°rio (10 bits)|
| -----| -----| -----|  
| $k_1$ | 835 | 1101000011| 
| $k_2$ | 291 | 0100100011| 
| $k_3$ | 70  | 0001000110| 
:::

Realizamos a opera√ß√£o XOR bit a bit entre as partes.
$$k_1 \oplus k_2 \oplus k_3$$$$\begin{array}{r l l} & 1101000011 & (k_1) \\ \oplus & 0100100011 & (k_2) \\ \hline & 1001100000 & (k_1 \oplus k_2) \\ \oplus & 0001000110 & (k_3) \\ \hline & \mathbf{1000100110} & (\text{Resultado}) \end{array}$$

Transformando o resultado de volta para decimal:
$$1000100110_2=512+64+8+4+2=590$$

O m√©todo XOR tende a preservar melhor as caracter√≠sticas de todas as partes da chave, ainda que seja um pouco mais complexo de implementar do que a soma simples.

#### Mid-Square

O m√©todo do quadrado central √© uma t√©cnica cl√°ssica de extra√ß√£o. A chave √© elevada ao quadrado, e ent√£o o hash √© formado pelos d√≠gitos centrais do resultado. A quantidade de d√≠gitos extra√≠dos √© indicada por $d$.

Apesar de ser simples, ele pode gerar um c√≥digo hash razoavelmente bem distribu√≠do. Como exemplo, considere uma $k=931$ e $d=3$.
$$k^2=931^2=866761$$
Assim, podemos selecionar $676$, ou at√© $667$.

Esses m√©todos apresentados podem ser combinados ou at√© mesmo utilizados como substitutos de uma fun√ß√£o hash. Em sistemas mais complexos, essas abordagens costumam ser empregadas como etapas auxiliares dentro de fun√ß√µes de hash mais sofisticadas.


---

Nesta unidade, voc√™ aprendeu

‚úÖ quais caracter√≠sticas uma fun√ß√£o _hash_ deve possuir 

‚úÖ met√≥dos cl√°ssicos para definir fun√ß√µes _hash_ 

‚úÖ como mapear palavras e grandes n√∫meros em chaves


```quizdown
# O que √© uma fun√ß√£o hash?

> Pense no papel dela dentro de uma tabela de dispers√£o.

1. [ ] Um algoritmo que ordena elementos de forma crescente.
1. [x] Uma fun√ß√£o que transforma uma chave em um √≠ndice de armazenamento.
1. [ ] Uma t√©cnica de compress√£o de dados.
1. [ ] Uma estrutura de dados hier√°rquica.


# Quais s√£o caracter√≠sticas desej√°veis de uma boa fun√ß√£o hash? 

> Elas influenciam diretamente na efici√™ncia e distribui√ß√£o das chaves.

- [x] Ser f√°cil de calcular.
- [x] Produzir distribui√ß√£o uniforme dos dados.
- [x] Minimizar colis√µes.
- [ ] Depender de opera√ß√µes aleat√≥rias complexas.


# No m√©todo da divis√£o, qual das op√ß√µes expressa corretamente a fun√ß√£o hash? 

> Observe a opera√ß√£o usada para gerar o √≠ndice.

1. [x] $h(k) = k \bmod m$
1. [ ] $h(k) = k / m$
1. [ ] $h(k) = k^2 \bmod m$
1. [ ] $h(k) = \sqrt{k} \bmod m$


# Por que √© ideal escolher $m$ como um n√∫mero primo no m√©todo da divis√£o? 

> Isso afeta a forma como os valores se espalham na tabela.

1. [x] Porque ajuda a distribuir as chaves de forma mais uniforme.
1. [ ] Porque facilita o c√°lculo de ra√≠zes quadradas.
1. [ ] Porque garante que n√£o ocorram colis√µes.
1. [ ] Porque simplifica a implementa√ß√£o de XOR.


# Considere $h(k) = k \bmod 101$. Qual o valor de $h(12345)$?

> Aplique o operador m√≥dulo diretamente.

1. [ ] 12
1. [x] 22
1. [ ] 45
1. [ ] 99


# Quais s√£o as etapas do m√©todo da multiplica√ß√£o?

> Relembre a ordem dos c√°lculos realizados.

1. Multiplicar a chave ($k$) por uma constante $A$ entre 0 e 1.  
2. Extrair a parte fracion√°ria de $kA$.  
3. Multiplicar o resultado por $m$.  
4. Arredondar para baixo.


# No m√©todo da multiplica√ß√£o, qual √© uma vantagem importante? 

> Observe a observa√ß√£o sobre o tamanho da tabela.

1. [ ] √â ideal quando $m$ √© primo.  
1. [x] √â adequado quando o tamanho da tabela √© uma pot√™ncia de dois.  
1. [ ] Garante aus√™ncia total de colis√µes.  
1. [ ] Dispensa o uso do operador m√≥dulo.


# O que caracteriza o hashing universal? 

> Est√° relacionado √† escolha aleat√≥ria de fun√ß√µes.

1. [ ] Usa apenas o m√©todo da divis√£o.  
1. [ ] Calcula o hash como a m√©dia de v√°rias fun√ß√µes.  
1. [x] Escolhe aleatoriamente uma fun√ß√£o de uma fam√≠lia de fun√ß√µes que minimiza colis√µes.  
1. [ ] Utiliza constantes irracionais para dispers√£o.


# A f√≥rmula do hashing universal $h_{a,b}(k)=((ak+b)\bmod p)\bmod m$ cont√©m quais par√¢metros aleat√≥rios?

> Eles s√£o escolhidos no in√≠cio do processo.

- [x] $a$
- [x] $b$
- [ ] $p$
- [ ] $m$


# Quais s√£o m√©todos cl√°ssicos para transformar _strings_ em inteiros? 

> Pense nos dois tipos mencionados no texto.

- [x] Soma dos valores ASCII.  
- [x] Multiplica√ß√£o polinomial.  
- [ ] Hashing universal.  
- [ ] M√©todo da divis√£o.


# Por que a multiplica√ß√£o polinomial √© superior √† soma simples? 

> Compare o que cada m√©todo considera.

1. [x] Porque considera a ordem dos caracteres.  
1. [ ] Porque ignora os valores ASCII.  
1. [ ] Porque usa n√∫meros compostos.  
1. [ ] Porque sempre gera n√∫meros primos.


# Se $\beta = 13$, qual √© o valor de $k$ para a palavra "BA"? 

> Use a f√≥rmula da multiplica√ß√£o polinomial.

1. [ ] 911  
1. [x] 923  
1. [ ] 1213  
1. [ ] 1001  


# No m√©todo de dobramento (folding), o que fazemos com a chave?

> Veja como ela √© reduzida.

1. [x] Dividimos em partes menores e as combinamos por soma ou XOR.  
1. [ ] Multiplicamos por um n√∫mero primo e aplicamos m√≥dulo.  
1. [ ] Extra√≠mos os d√≠gitos centrais do quadrado da chave.  
1. [ ] Aplicamos o logaritmo da chave.


# No exemplo do m√©todo XOR, qual foi o resultado decimal final? 

> Observe a convers√£o final do n√∫mero bin√°rio.

1. [ ] 512  
1. [ ] 5900  
1. [x] 590  
1. [ ] 676


# O m√©todo do quadrado central (mid-square) consiste em:

> Ele √© simples, mas eficaz.

1. [ ] Somar as partes da chave.  
1. [x] Elevar a chave ao quadrado e extrair os d√≠gitos centrais.  
1. [ ] Dividir a chave por um n√∫mero primo.  
1. [ ] Converter a chave em bin√°rio e aplicar XOR.


# Quais m√©todos s√£o indicados para mapear inteiros muito grandes? 

> Lembre dos tr√™s apresentados no texto.

- [x] Dobramento (folding)  
- [x] XOR  
- [x] Quadrado central (mid-square)  
- [ ] Divis√£o inteira simples

```

{{< include /_includes/progress-bar.qmd >}}

