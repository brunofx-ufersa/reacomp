---
title: "Ponteiros (Revis√£o)"
lang: pt
toc-title: Conte√∫do
toc: false
sidebar: false
format:
  html:
    reference-location: margin
    css: ../styles/academic.css
filters: 
    - quizdown
---



Por muito tempo, construir estruturas de dados exigia que os desenvolvedores as reescrevessem para cada tipo de dado. Era uma batalha constante: uma lista para n√∫meros inteiros, outra para textos, outra para dados de usu√°rios, e assim por diante. Essa repeti√ß√£o n√£o apenas consumia tempo, mas tamb√©m abria portas para erros e inconsist√™ncias.

A ideia central de estruturas gen√©ricas √© poder construir estruturas universais que podem ser aplicadas em qualquer projeto. Embora a linguagem C n√£o tenha suporte nativo a "gen√©ricos", como C++ ou Java, a solu√ß√£o tradicional e elegante √© usar ponteiros `void*` e fun√ß√µes de _callback_. 

Antes de explorarmos essas estruturas, √© fundamental revisar e aprofundar dois conceitos cruciais: **ponteiros** e **ponteiros de fun√ß√£o**.

Como voc√™ deve ter visto em Algoritmos e Estruturas de Dados 1, um ponteiro √© uma vari√°vel que armazena o endere√ßo de mem√≥ria de outra vari√°vel. Essa capacidade √© a base para criar estruturas de dados com tamanho din√¢mico (que crescem ou diminuem em tempo de execu√ß√£o).


## Declara√ß√£o {#sec-dec}

Quando declaramos uma vari√°vel e atribu√≠mos um valor, esse valor √© armazenado em um endere√ßo de mem√≥ria. Quando escrevemos `int x = 10;`, por exemplo, ocorrem dois passos conceituais:

- **Declara√ß√£o**: o programa reserva um espa√ßo na mem√≥ria para armazenar um inteiro.
- **Atribui√ß√£o**: o valor `10` √© gravado nesse espa√ßo de mem√≥ria, que possui um endere√ßo.

A vari√°vel `x` √© apenas um r√≥tulo usado pelo programador.


::: {style="width: 60%; margin: auto;"}
| Vari√°vel | Endere√ßo | Conte√∫do |
|----------|----------|----------|
|   `x`    |   0x75   |  10      |

: Ilustra√ß√£o da mem√≥ria para uma vari√°vel do tipo `int`
:::


Para se obter o endere√ßo da vari√°vel `x` escrevemos `&x`. O resultado √© modificado toda vez que voc√™ roda o programa. Como um ponteiro armazena um endere√ßo de mem√≥ria, um ponteiro para `x` seria declarado como `int* x_ptr = &x`.

::: {.column-margin}
**[Se liga!]{.text-warning}**
A mem√≥ria em si √© ilustrada pelo endere√ßo e conte√∫do armazenado. A vari√°vel √© apenas um r√≥tulo que representa este par.
:::

O princ√≠pio b√°sico de um ponteiro √© a compatibilidade de tipo, ou seja, um ponteiro deve ser do mesmo tipo do dado que ele aponta.

```{.c}
double meta = 7.5;
double *meta_ptr = &meta; // O operador & retorna o endere√ßo na mem√≥ria
```

Na linha 2, `meta_ptr` guarda o endere√ßo da vari√°vel `meta`. 

O quadro abaixo ilustra a mem√≥ria depois das declara√ß√µes do trecho de c√≥digo anterior.

::: {style="width: 60%; margin: auto;"}
| Vari√°vel	| Endere√ßo	| Conte√∫do | 
|------|----------|-------|
| `meta`	| [0x55]{.mark} | 7.5 |
| `meta_ptr`	| 0x58 |	[0x55]{.mark} |

: Ilustra√ß√£o da mem√≥ria para um ponteiro
:::

Estamos usando endere√ßos fict√≠cios. Note que `meta_ptr` guarda o endere√ßo de `meta`. Neste caso, dizemos que `meta_ptr` aponta para `meta`. 

Vamos explorar outro exemplo usando um diagrama que ilustra uma mem√≥ria. 

```{mermaid}
flowchart RL
    %% N√≥s de vari√°veis e ponteiros
    X["üì¶ <b>x</b><br/>Endere√ßo: <code>0x100</code><br/>Conte√∫do: <b>42</b>"]
    Y["üì¶ <b>y</b><br/>Endere√ßo: <code>0x200</code><br/>Conte√∫do: <b>137</b>"]
    P["üéØ <b>p</b><br/>Endere√ßo: <code>0x300</code><br/>Conte√∫do: <code>0x100</code>"]
    PP["üéØ <b>pp</b><br/>Endere√ßo: <code>0x400</code><br/>Conte√∫do: <code>0x300</code>"]

    %% Conex√µes
    PP -->|"aponta para"| P
    P -->|"aponta para"| X
    P ~~~ Y
    Y ~~~ X

    %% Estilos de formata√ß√£o
    classDef var fill:#A8E6CF,stroke:#2E7D32,color:#000,stroke-width:1px;
    classDef ptr fill:#FFD3B6,stroke:#E65100,color:#000,stroke-width:1px;
    class X,Y var
    class P,PP ptr
```

::: {.column-margin}
**[Se liga!]{.text-warning}**
Cada quadro √© um bloco de mem√≥ria que possui um endere√ßo e um valor. Os ponteiros est√£o em laranja.
:::


As vari√°veis `x` e `y` carregam dados que est√£o armazenados nos endere√ßos `0x100` e `0x200`, respectivamente. A vari√°vel `p` √© um ponteiro cujo conte√∫do √© `0x100`, portanto aponta para `x`. A vari√°vel `pp` √© outro ponteiro, mas com conte√∫do `0x300`, ou seja, aponta para o local com endere√ßo `0x300`, que seria `p`. Isso mesmo que voc√™ pensou, um ponteiro de ponteiro. 

```{.c code-line-numbers="false"}
int x = 42;
int y = 137;
int *p = &x;
int **pp = &p;
```

Resumindo

- `x` cont√©m `42` e est√° no endere√ßo `0x100`;
- `y` cont√©m `137` e est√° no endere√ßo `0x200`;
- `p` cont√©m `0x100` (o endere√ßo de `x`);
- `pp` cont√©m `0x300` (o endere√ßo de `p`).


Vale salientar que h√° tr√™s declara√ß√µes de ponteiros ligeiramente diferentes:

```{.c code-line-numbers="false"}
double *meta_ptr = &meta;
double* meta_ptr = &meta;
double * meta_ptr = &meta;
```

::: {.column-margin}
**[Se liga!]{.text-warning}**
Essas declara√ß√µes dizem respeito ao local do s√≠mbolo `*`. 
:::

No entanto, a primeira √© mais recomendada: `tipo *ponteiro = &variavel`.


## Desreferencia√ß√£o {#sec-des}

Uma opera√ß√£o importante com ponteiros √© a **desreferencia√ß√£o** (ou dereferencing). Ela ocorre quando acessamos o conte√∫do armazenado no endere√ßo que o ponteiro aponta. Por exemplo,

```{.c}
double meta = 7.5;
double *meta_ptr = &meta; // O operador & retorna o endere√ßo na mem√≥ria
printf("*meta_ptr: %.2f\n", *meta_ptr); // *meta_ptr: 7.50
```

Na segunda linha, criamos um ponteiro que aponta para `meta`. Na linha 3, o operador `*` serve para desreferenciar, ou seja, ao usar `*meta_ptr` na impress√£o, o C acessa o valor armazenado no endere√ßo que `meta_ptr` aponta, isto √©, `7.5`. 

::: {.callout-tip}

O `*` tem dupla fun√ß√£o:

- Declarar um ponteiro (`double *p`)
- Desreferenciar um ponteiro (`*p`)
:::

::: {.column-margin}
**[Se liga!]{.text-warning}**
Os operadores `*` e `&` se anulam, ou seja, `*&p` ou `&*p` √© o mesmo que `p`. 
:::

√â v√°lido mencionar que, em uma vari√°vel que guarda um dado, podemos acessar o dado e o endere√ßo. J√° em um ponteiro, podemos acessar seu endere√ßo, o conte√∫do (outro endere√ßo) e o dado armazenado pela vari√°vel que ele aponta:

```{.c code-line-numbers="false"}
int idade = 12;
int *idade_ptr = &idade;

printf("idade: %d\n", idade);
printf("&idade: %x\n", &idade);

printf("&idade_ptr: %x\n", &idade_ptr); // Endere√ßo do ponteiro
printf("idade_ptr: %x\n", idade_ptr);   // Endere√ßo de idade
printf("*idade_ptr: %d\n", *idade_ptr); // Conte√∫do de idade
```

Para fixa√ß√£o, observe o diagrama de sequ√™ncia que ilustra os processos de decla√ß√£o e desreferencia√ß√£o. 


```{.c code-line-numbers="false"}
int x = 10;
int *ptr = &x;
int y = *ptr;  // desreferencia√ß√£o
```


```{mermaid}
sequenceDiagram
    participant Stack as Mem√≥ria (Stack)
    participant X as Vari√°vel x
    participant Ptr as Ponteiro ptr
    participant CPU as CPU/Programa

    Note over CPU,Stack: Declara√ß√£o e atribui√ß√£o inicial
    CPU->>Stack: Aloca espa√ßo para x = 10
    Stack->>X: Cria x (valor=10, endere√ßo=0x1000)

    Note over CPU,Ptr: Ponteiro recebe o endere√ßo de x
    CPU->>Ptr: ptr = &x
    Ptr->>Stack: Guarda endere√ßo 0x1000

    Note over CPU,Stack: Desreferencia√ß√£o
    CPU->>Ptr: l√™ conte√∫do de ptr
    Ptr-->>Stack: endere√ßo 0x1000
    Stack-->>CPU: retorna valor armazenado (10)
    CPU->>Stack: y = 10

    Note right of CPU: *ptr l√™ o valor armazenado em x
```


Al√©m de ler o conte√∫do de uma vari√°vel, tamb√©m podemos modific√°-lo **indiretamente** usando ponteiros:

```{.c code-line-numbers="false"}
double meta = 7.5;
double *meta_ptr = &meta; 

*meta_ptr = 10;
printf("meta: %.2f\n", meta); // meta: 10.00
```
Mudamos o valor de `meta` sem acess√°-la diretamente. Isso √© o poder dos ponteiros!



::: {.callout-note icon="false" title="üéØ Desafio de C√≥digo"}

- Crie um ponteiro `p` que aponte para uma vari√°vel `int x = 5`.
- Use o ponteiro para alterar `x` para `42`.
- Depois, exiba o valor e o endere√ßo de `x` no console.
:::


::: {.callout-tip title="Solu√ß√£o (clique para ver)" collapse="true"}
```{.c}
#include <stdio.h> 

int main(){
    int x = 5;   
    int *p = &x; // Ponteiro apontando para x (ambos do mesmo tipo)
    *p = 42;     // Modifica√ß√£o indireta

    printf("x: %d\n", x);
    printf("&x: %p\n", &x);

    return 0;
}
```
:::

::: {.callout-note icon="false" title="üéØ Desafio de C√≥digo"}

- Passo 1: Declare um ponteiro `chave_ptr` que aponte para a `chave_secreta`.
- Passo 2: Mude o valor da `chave_secreta` para 99 usando o ponteiro.
- Passo 3: Imprima o valor da chave secreta.
    
```{.c}
#include <stdio.h>

int main() {
    int chave_secreta = 10;
    // SEU C√ìDIGO

    return 0;
}
```
:::

::: {.callout-tip title="Solu√ß√£o (clique para ver)" collapse="true"}
```{.c}
#include <stdio.h> 

int main() {
    int chave_secreta = 10;
    int *chave_ptr = &chave_secreta;
    *chave_ptr = 99;

    printf("chave_secreta: %d\n", chave_secreta);
    return 0;
}
```
:::


## Ponteiros como par√¢metros {#sec-par}


Em C, os par√¢metros s√£o passados por valor. Portanto, a fun√ß√£o recebe uma c√≥pia do argumento.

```{.c code-line-numbers="false"}
void dobrar_meta (double meta){ 
    meta = 2*meta; 
}
```

Na `main`:

```{.c code-line-numbers="false"}
double meta = 7.5;
printf("meta: %.2f\n", meta);
dobrar_meta(meta);
printf("meta: %.2f\n", meta);
```

Sa√≠da:

```{.console code-line-numbers="false"}
meta: 7.50
meta: 7.50
```

Esperav√°mos que no exemplo acima, o valor de `meta` tivesse sido dobrado, mas nada mudou. A raz√£o √© que a fun√ß√£o alterou apenas a c√≥pia local. A vari√°vel `meta` na fun√ß√£o `main` √© global, j√° na fun√ß√£o `dobrar_meta` √© local. Significa que quando esta fun√ß√£o termina, as vari√°veis s√£o descartadas.[^sidenote]

[^sidenote]: Se voc√™ declarar uma vari√°vel local com o mesmo nome de uma vari√°vel global, a vari√°vel local prevalece dentro do seu escopo, ocultando temporariamente a global.

Imprimindo os endere√ßos, vamos constatar que trata-se de vari√°veis diferentes.

```{.c code-line-numbers="false"}
void dobrar_meta (double meta){ 
    printf("local &meta: %x\n", &meta);
    meta = 2*meta; 
}
```

Na `main`:

```{.c code-line-numbers="false"}
double meta = 7.5;
printf("main &meta: %x\n", &meta);
dobrar_meta(meta);
```

Sa√≠da:

```{.console code-line-numbers="false"}
main &meta: 0xe8
local &meta: 0xc0
```
Os endere√ßos s√£o diferentes. Logo, n√£o s√£o as mesmas vari√°veis que estamos manipulando

A vari√°vel interna em `dobrar_meta` √© criada em outra regi√£o de mem√≥ria e recebe uma c√≥pia do valor passado como argumento. Esse valor √© dobrado em seguida, mas n√£o reflete na vari√°vel da fun√ß√£o `main`, pois ela est√° alocada em outra posi√ß√£o.


```{mermaid}
flowchart LR
 subgraph s1[" "]
        X["üì¶ <b>meta</b><br>Endere√ßo: <code>0xe8</code><br>Conte√∫do: <b>7.5</b>"]
        Y["üì¶ <b>meta</b><br>Endere√ßo: <code>0xc0</code><br>Conte√∫do: <b>7.5</b>"]
  end

 subgraph s2[" "]
        A["üì¶ <b>meta</b><br>Endere√ßo: <code>0xe8</code><br>Conte√∫do: <b>7.5</b>"]
        B["üì¶ <b>meta</b><br>Endere√ßo: <code>0xc0</code><br>Conte√∫do: <b>15</b>"]
  end

    s1 --dobrar_meta--> s2
    
     X:::var
     Y:::var
     A:::var
     B:::var
    classDef var fill:#A8E6CF,stroke:#2E7D32,color:#000,stroke-width:1px
    style s1 fill:transparent
    style s2 fill:transparent

```


Para solucionar isso, ao inv√©s de passarmos o conte√∫do armazenado, podemos passar o endere√ßo. Isso √© conhecido como passagem por refer√™ncia. Na verdade, ainda ser√° feita uma c√≥pia do valor passado, mas como esse valor copiado √© um endere√ßo (o ponteiro), esse artif√≠cio ser√° suficiente para manipularmos os dados originais. 

```{.c}
#include <stdio.h>

void dobrar_meta (double *meta){ 
    *meta = 2*(*meta); // Desreferencia√ß√£o 
}

int main (){
    double meta = 7.5;
    
    printf("meta: %.2f\n", meta);
    dobrar_meta(&meta); // Passando o endere√ßo
    printf("meta: %.2f\n", meta);

    return 0;
}
```

Sa√≠da:

```{.console code-line-numbers="false"}
meta: 7.50
meta: 15.00
```

Dessa vez, a fun√ß√£o modificou a vari√°vel original, pois passamos a refer√™ncia. Vamos ilustrar como isso aconteceu.

::: {style="width: 60%; margin: auto;"}
| Vari√°vel	| Endere√ßo	| Conte√∫do |
| ----------|-----------|-------|
| _main_ `meta` | [0xe8]{.mark}	| 7.5 |
| local `meta` | 0xc0	| [0xe8]{.mark} |
:::

Dentro da fun√ß√£o, quando fazemos `*meta`, o C faz a desreferencia√ß√£o, ou seja, retorna o conte√∫do do local cujo o endere√ßo √© 0xe8. Neste local, a opera√ß√£o de dobrar √© efetuada.

::: {style="width: 60%; margin: auto;"}
| Vari√°vel	| Endere√ßo	| Conte√∫do |
| ----------|-----------|-------|
| _main_ `meta` | [0xe8]{.mark}	| 15 |
| local `meta` | 0xc0	| [0xe8]{.mark} |
:::

Ao finalizar, a vari√°vel `meta` da fun√ß√£o `main` sofreu a altera√ß√£o.

```{mermaid}
flowchart LR
 subgraph s1[" "]
        X["üì¶ <b>meta</b><br>Endere√ßo: <code>0xe8</code><br>Conte√∫do: <b>7.5</b>"]
        Y["üéØ <b>meta</b><br>Endere√ßo: <code>0xc0</code><br>Conte√∫do: <b>0xe8</b>"]
  end
 subgraph s2[" "]
        A["üì¶ <b>meta</b><br>Endere√ßo: <code>0xe8</code><br>Conte√∫do: <b>15</b>"]
        B["üéØ <b>meta</b><br>Endere√ßo: <code>0xc0</code><br>Conte√∫do: <b>0xe8</b>"]
  end
    s1 -- dobrar_meta --> s2

     X:::var
     Y:::ptr
     A:::var
     B:::ptr
    classDef var fill:#A8E6CF,stroke:#2E7D32,color:#000,stroke-width:1px
    classDef ptr fill:#FFD3B6,stroke:#E65100,color:#000,stroke-width:1px;
    style s1 fill:transparent
    style s2 fill:transparent
```


::: {.callout-important}
Quando passamos o endere√ßo (`&meta`) para a fun√ß√£o `dobrar_meta`, a vari√°vel `meta` interna vai armazenar em seu conte√∫do um endere√ßo de mem√≥ria. Ou seja, ela √© um ponteiro e, portanto, podemos desreferenciar. Por exemplo, considere as seguintes assinaturas de fun√ß√µes:

```{.c code-line-numbers="false"}
void foo(int a);
void bar(int* a);
void baz(int** a);
```

Quando fazemos `foo(x)`, internamente √© feita uma c√≥pia do valor de `x`, ou seja, √© criado `int a = x`.
Do mesmo modo, quando fazemos `bar(&x)`, ent√£o √© criado `int *a = &x`. J√° para a fun√ß√£o `baz`, devemos passar um endere√ßo de um ponteiro, por exemplo, `baz(&p)` (onde `p` √© um `int*`). Se usarmos os mesmos nomes, o C consegue diferenciar a vari√°vel da fun√ß√£o da que vem como argumento. Resumindo:

Considere

```{.c code-line-numbers="false"}
int x = 10;
int *p = &x;
```

| Se a fun√ß√£o √©...	| Ela espera receber...	| Como voc√™ chama | O que pode fazer |
|---|----|---|---|
| `foo(int a)`	| Um valor inteiro |	`foo(x)` | Pode fazer c√°lculos com o 10, mas n√£o toca no `x` original |
| `bar(int* a)`	| Um endere√ßo de um inteiro	| `bar(&x)` | Pode fazer c√°lculos com o 10 e alterar `x` |
| `baz(int** a)`	| Um endere√ßo de um ponteiro	| `baz(&p)` | Pode fazer c√°lculos com o 10 e alterar `x` e o ponteiro `p` |

> Se voc√™ quer alterar o valor, passe um ponteiro.
> Se voc√™ quer alterar para onde o ponteiro aponta, passe o endere√ßo do ponteiro.
:::

::: {.callout-note icon="false" title="üéØ Desafio de C√≥digo"}
Implemente uma fun√ß√£o `swap` que troque os valores de duas vari√°veis.
Teste na `main` com:

```{.c code-line-numbers="false"}
int x = 10, y = 20;
swap(&x, &y);
printf("x = %d, y = %d\n", x, y);
```

Sa√≠da esperada: `x = 20, y = 10`
:::


::: {.callout-tip title="Solu√ß√£o (clique para ver)" collapse="true"}
```{.c}
#include <stdio.h> 

void swap(int *a, int *b){
    int aux = *a;
    a* = *b;
    b* = aux;
}

int main(){
    int x = 10, y = 20;
    swap(&x, &y);
    printf("x = %d, y = %d\n", x, y);

    return 0;
}
```
:::


::: {.callout-note icon="false" title="Exerc√≠cio de Fixa√ß√£o"}
Considere o c√≥digo base abaixo:

```c
#include <stdio.h>

int main() {
    int x = 5;
    int y = 10;
    int *p = &x;

    printf("x = %d\n", x);
    printf("y = %d\n", y);
    printf("*p = %d\n", *p);

    return 0;
}
```

Considere as fun√ß√µes a seguir independentemente.

```{.c code-line-numbers="false"}
void f1(int a) { a = a + 10; }
```
a) Qual chamada √© v√°lida?

- `f1(x)`
- `f1(&x)`
- `f1(p)`

b) Ap√≥s a chamada correta, qual ser√° o valor de `x`?


```{.c code-line-numbers="false"}
void f2(int *a) { *a = *a + 10; }
```
c) Qual chamada √© v√°lida?

- `f2(x)`
- `f2(&x)`
- `f2(p)`

d) Ap√≥s a chamada correta, qual ser√° o valor de `x`?

```{.c code-line-numbers="false"}
void f3(int **a) { **a = 99; }
```
e) Qual chamada √© v√°lida?

- `f3(&x)`
- `f3(p)`
- `f3(&p)`

f) Ap√≥s a chamada correta, qual ser√° o valor de `x`?

```{.c code-line-numbers="false"}
void f4(int **a, int *b) { *a = b; }
```

g) Qual chamada faz `p` passar a apontar para `y`?

- `f4(p, &y)`
- `f4(&p, y)`
- `f4(&p, &y)`

h) Ap√≥s a chamada correta, qual ser√° o valor impresso por `*p`?

```{.c code-line-numbers="false"}
void f5(int *a) {
    int z = 50;
    a = &z;
}
```

i) Ap√≥s a chamada `f5(p)`, `p` passa a apontar para `z`?

:::


---

Nesta unidade, voc√™ aprendeu

‚úÖ a declarar e desreferenciar ponteiros;

‚úÖ a modificar valores via ponteiros;

‚úÖ a passar vari√°veis por refer√™ncia;

‚úÖ a modificar ponteiros.


::: {.callout-tip}
Se voc√™ quiser aprofundar mais seu conhecimento sobre ponteiros, revise materiais sobre ponteiros para _structs_, aritm√©tica de ponteiros, ponteiros para _strings_ e a rela√ß√£o entre _arrays_ e ponteiros.
:::



```quizdown

# O que melhor descreve um ponteiro em C?

1. [ ] Uma vari√°vel que armazena o valor de outra vari√°vel.  
1. [x] Uma vari√°vel que armazena o endere√ßo de mem√≥ria de outra vari√°vel.  
1. [ ] Uma fun√ß√£o que manipula endere√ßos de mem√≥ria.  
1. [ ] Um tipo especial usado apenas para arrays.  

# Por que um ponteiro deve ser do mesmo tipo da vari√°vel para a qual aponta?

1. [x] Para garantir a interpreta√ß√£o correta dos dados armazenados na mem√≥ria.  
1. [ ] Para permitir convers√£o impl√≠cita de tipos.  
1. [ ] Porque o C faz o casting autom√°tico de ponteiros.  
1. [ ] N√£o √© necess√°rio; qualquer ponteiro pode apontar para qualquer tipo de dado com seguran√ßa.  


# O que acontece ao usar o operador `*` sobre um ponteiro?

1. [ ] Ele recupera o endere√ßo de mem√≥ria armazenado no ponteiro.  
1. [x] Ele acessa o valor armazenado no endere√ßo de mem√≥ria apontado pelo ponteiro.  
1. [ ] Ele declara uma nova vari√°vel ponteiro.  
1. [ ] Ele libera a mem√≥ria associada ao ponteiro.  


# Quais das declara√ß√µes abaixo s√£o **equivalentes e v√°lidas** em C?

- [x] `double *meta_ptr = &meta;`  
- [x] `double* meta_ptr = &meta;` 
- [ ] `double meta_ptr* = &meta;`  
- [x] `double * meta_ptr = &meta;` 


# Por que a fun√ß√£o `dobrar_meta(double meta)` n√£o altera o valor da vari√°vel `meta` na fun√ß√£o `main`?

1. [x] Porque o C passa argumentos por valor, criando uma c√≥pia da vari√°vel.  
1. [ ] Porque vari√°veis do tipo `double` s√£o imut√°veis.  
1. [ ] Porque a fun√ß√£o n√£o tem retorno (`void`).  
1. [ ] Porque a vari√°vel `meta` √© constante.  


# O que faz a express√£o `*meta = 2 * (*meta);`?

1. [ ] Declara um novo ponteiro.  
1. [x] Dobra o valor armazenado na vari√°vel original, desreferenciando o endere√ßo recebido.  
1. [ ] Altera o endere√ßo armazenado no ponteiro.  
1. [ ] Cria uma c√≥pia do ponteiro.  


# Marque as afirmativas verdadeiras sobre o exemplo `swap(&x, &y)`.

- [x] S√£o passados os endere√ßos das vari√°veis `x` e `y`.  
- [x] Os valores de `x` e `y` s√£o modificados diretamente.  
- [ ] A fun√ß√£o troca apenas c√≥pias das vari√°veis.  
- [ ] A fun√ß√£o utiliza passagem por valor.  


```

{{< include /_includes/progress-bar.qmd >}}
