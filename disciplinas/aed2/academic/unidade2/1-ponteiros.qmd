---
title: "Ponteiros (Revis√£o)"
lang: pt
toc-title: Conte√∫do
format:
  html:
    css: ../styles/academic.css
---

Por muito tempo, construir estruturas de dados, como listas e √°rvores, exigia que os desenvolvedores as reescrevessem para cada tipo de dado. Era uma batalha constante: uma lista para n√∫meros inteiros, outra para textos, outra para dados de usu√°rios, e assim por diante. Essa repeti√ß√£o n√£o apenas consumia tempo, mas tamb√©m abria portas para erros e inconsist√™ncias.

A ideia de estruturas gen√©ricas √© poder construir estruturas universais que podem ser aplicadas em qualquer projeto. Embora a linguagem C n√£o tenha suporte nativo a "gen√©ricos", como C++ ou Java, a solu√ß√£o tradicional e elegante √© usar ponteiros `void*` e fun√ß√µes de _callback_. 

Antes de explorarmos essas estruturas, √© fundamental revisar e aprofundar dois conceitos cruciais: **ponteiros** e **ponteiros de fun√ß√£o**.

Como voc√™ deve ter visto em **Algoritmos e Estruturas de Dados 1**, um **ponteiro** √© uma vari√°vel que armazena o **endere√ßo de mem√≥ria** de outra vari√°vel. Essa capacidade √© a base para criar estruturas de dados com tamanho din√¢mico (que crescem ou diminuem em tempo de execu√ß√£o).


## Declara√ß√£o {#sec-dec}

Quando declaramos uma vari√°vel e atribu√≠mos um valor, esse valor √© armazenado em um endere√ßo de mem√≥ria. Quando escrevemos `int x = 10;`, ocorrem dois passos conceituais:

- **Declara√ß√£o**: o programa reserva um espa√ßo na mem√≥ria para armazenar um inteiro.
- **Atribui√ß√£o**: o valor `10` √© gravado nesse espa√ßo de mem√≥ria, que possui um endere√ßo.

A vari√°vel `x` √© apenas um r√≥tulo usado pelo programador.

| Vari√°vel | Endere√ßo | Conte√∫do |
|--------|----------|-------|
|   `x`    |   0x75   |  10   |


O princ√≠pio b√°sico de um ponteiro √© a **compatibilidade de tipo**, ou seja, um ponteiro deve ser do mesmo tipo do dado que ele aponta.

```{.c}
double meta = 7.5;
double *meta_ptr = &meta; // O operador & retorna o endere√ßo na mem√≥ria
```

Na linha 2, `meta_ptr` guarda o endere√ßo da vari√°vel `meta`. 

O quadro abaixo ilustra a mem√≥ria depois das declara√ß√µes do trecho de c√≥digo anterior.

| Vari√°vel	| Endere√ßo	| Conte√∫do | 
|------|----------|-------|
| `meta`	| [0x55]{.mark} | 7.5 |
| `meta_ptr`	| 0x58 |	[0x55]{.mark} |

Estamos usando endere√ßos fict√≠cios. Note que `meta_ptr` guarda o endere√ßo de `meta`. Neste caso, dizemos que `meta_ptr` **aponta** para `meta`. 

Vamos explorar outro exemplo usando um diagrama que ilustra uma mem√≥ria.

```{mermaid}
flowchart RL
    %% N√≥s de vari√°veis e ponteiros
    X["üì¶ <b>x</b><br/>Endere√ßo: <code>0x100</code><br/>Conte√∫do: <b>42</b>"]
    Y["üì¶ <b>y</b><br/>Endere√ßo: <code>0x200</code><br/>Conte√∫do: <b>137</b>"]
    P["üéØ <b>p</b><br/>Endere√ßo: <code>0x300</code><br/>Conte√∫do: <code>0x100</code>"]
    PP["üéØ <b>pp</b><br/>Endere√ßo: <code>0x400</code><br/>Conte√∫do: <code>0x300</code>"]

    %% Conex√µes
    PP -->|"aponta para"| P
    P -->|"aponta para"| X
    P ~~~ Y
    Y ~~~ X

    %% Estilos de formata√ß√£o
    classDef var fill:#A8E6CF,stroke:#2E7D32,color:#000,stroke-width:1px;
    classDef ptr fill:#FFD3B6,stroke:#E65100,color:#000,stroke-width:1px;
    class X,Y var
    class P,PP ptr
```

As vari√°veis `x` e `y` carregam dados que est√£o armazenados nos endere√ßos `0x100` e `0x200`, respectivamente. A vari√°vel `p` √© um ponteiro cujo conte√∫do √© `0x100`, portanto aponta para `x`. A vari√°vel `pp` √© outro ponteiro, mas com conte√∫do `0x300`, ou seja, aponta para o local com endere√ßo `0x300`, que seria `p`. Isso mesmo um ponteiro de ponteiro. O c√≥digo que representa esse diagrama poder ser o seguinte.

```{.c code-line-numbers="false"}
int x = 42;
int y = 137;
int *p = &x;
int **pp = &p;
```

Resumindo

- x ‚Üí cont√©m 42 e est√° no endere√ßo `0x100`;
- y ‚Üí cont√©m 137 e est√° no endere√ßo `0x200`;
- p ‚Üí cont√©m `0x100` (o endere√ßo de x);
- pp ‚Üí cont√©m `0x300` (o endere√ßo de p).


H√° declara√ß√µes de ponteiros ligeiramente diferentes:

```{.c code-line-numbers="false"}
double *meta_ptr = &meta;
double* meta_ptr = &meta;
double * meta_ptr = &meta;
```

No entanto, a primeira √© mais recomendada: `tipo *ponteiro = &variavel`.


## Desreferencia√ß√£o {#sec-des}

Uma opera√ß√£o importante com ponteiros √© a **desreferencia√ß√£o** (ou dereferencing). Ela ocorre quando acessamos o conte√∫do armazenado no endere√ßo que o ponteiro aponta. Por exemplo,

```{.c}
double meta = 7.5;
double *meta_ptr = &meta; // O operador & retorna o endere√ßo na mem√≥ria
printf("*meta_ptr: %.2f\n", *meta_ptr); // *meta_ptr: 7.50
```

Na linha 3, o operador `*` serve para desreferenciar. Ao usar `*meta_ptr` na impress√£o, o C acessa o valor armazenado nesse endere√ßo (7.5). 

::: {.callout-tip}

O `*` tem dupla fun√ß√£o:

- Declarar um ponteiro (`double *p`)
- Desreferenciar um ponteiro (`*p`)
:::

√â v√°lido mencionar que, em uma vari√°vel que guarda um dado, podemos acessar o dado e o endere√ßo. J√° em um ponteiro, podemos acessar seu endere√ßo, o conte√∫do (outro endere√ßo) e o dado armazenado pela vari√°vel que ele aponta:

```{.c code-line-numbers="false"}
int idade = 12;
int *idade_ptr = &idade;

printf("idade: %d\n", idade);
printf("&idade: %x\n", &idade);

printf("&idade_ptr: %x\n", &idade_ptr); // Endere√ßo do ponteiro
printf("idade_ptr: %x\n", idade_ptr);   // Endere√ßo de idade
printf("*idade_ptr: %d\n", *idade_ptr); // Conte√∫do de idade
```

Al√©m de ler o conte√∫do de uma vari√°vel, tamb√©m podemos modific√°-lo indiretamente usando ponteiros:

```{.c code-line-numbers="false"}
double meta = 7.5;
double *meta_ptr = &meta; 

*meta_ptr = 10;
printf("meta: %.2f\n", meta); // meta: 10.00
```
Mudamos o valor de `meta` sem acess√°-la diretamente. Isso √© o poder dos ponteiros!


::: {.callout-note icon="false" title="üéØ Desafio de C√≥digo"}

- Crie um ponteiro `int *p` que aponte para uma vari√°vel `x = 5`.
- Use `*p` para alterar `x` para `42`.
- Depois, exiba o valor e o endere√ßo de `x` no console.
:::


::: {.callout-tip title="Solu√ß√£o (clique para ver)" collapse="true"}
```{.c}
#include <stdio.h> 

int main(){
    int x = 5;
    int *p = &x;
    *p = 42;

    printf("x: %d\n", x);
    printf("&x: %p\n", &x);

    return 0;
}
```
:::

::: {.callout-note icon="false" title="üéØ Desafio de C√≥digo"}

- Passo 1: Declare um ponteiro `ponteiro_chave` que aponte para a `chave_secreta`.
- Passo 2: Mude o valor da `chave_secreta` para 99 usando o ponteiro.
- Passo 3: Imprima o valor da chave secreta.
    
```{.c}
#include <stdio.h>

int main() {
    int chave_secreta = 10;
    // SEU C√ìDIGO

    return 0;
}
```
:::

::: {.callout-tip title="Solu√ß√£o (clique para ver)" collapse="true"}
```{.c}
#include <stdio.h> 

int main() {
    int chave_secreta = 10;
    int *ponteiro_chave = &chave_secreta;
    *ponteiro_chave = 99;

    printf("chave_secreta: %d\n", chave_secreta);
    return 0;
}
```
:::


## Ponteiros como par√¢metros {#sec-par}


Em C, os par√¢metros s√£o passados por valor. Portanto, a fun√ß√£o recebe uma c√≥pia do argumento.

```{.c code-line-numbers="false"}
void dobrar_meta (double meta){ 
    meta = 2*meta; 
}
```

Na `main`:

```{.c code-line-numbers="false"}
double meta = 7.5;
printf("meta: %.2f\n", meta);
dobrar_meta(meta);
printf("meta: %.2f\n", meta);
```

Sa√≠da:

```{.console code-line-numbers="false"}
meta: 7.50
meta: 7.50
```

Esperav√°mos que no exemplo acima, o valor de `meta` tivesse sido dobrado, mas nada mudou. A raz√£o √© que a fun√ß√£o alterou apenas a c√≥pia local. A vari√°vel `meta` na fun√ß√£o `main` √© global, j√° na fun√ß√£o `dobrar_meta` √© local. Significa que quando esta fun√ß√£o termina, as vari√°veis s√£o descartadas.

Imprimindo os endere√ßos, vamos constatar que trata-se de vari√°veis diferentes.

```{.c code-line-numbers="false"}
void dobrar_meta (double meta){ 
    printf("local &meta: %x\n", &meta);
    meta = 2*meta; 
}
```

Na `main`:

```{.c code-line-numbers="false"}
double meta = 7.5;
printf("main &meta: %x\n", &meta);
dobrar_meta(meta);
```

Sa√≠da:

```{.console code-line-numbers="false"}
main &meta: 0xe8
local &meta: 0xc0
```
Os endere√ßos s√£o diferentes. Logo, n√£o s√£o as mesmas vari√°veis que estamos manipulando

A vari√°vel interna em `dobrar_meta` √© criada em outra regi√£o de mem√≥ria e recebe uma c√≥pia do valor passado como argumento. Esse valor √© dobrado em seguida, mas n√£o reflete na vari√°vel da fun√ß√£o `main`, pois ela est√° alocada em outra posi√ß√£o.


```{mermaid}
flowchart LR
 subgraph s1[" "]
        X["üì¶ <b>meta</b><br>Endere√ßo: <code>0xe8</code><br>Conte√∫do: <b>7.5</b>"]
        Y["üì¶ <b>meta</b><br>Endere√ßo: <code>0xc0</code><br>Conte√∫do: <b>7.5</b>"]
  end

 subgraph s2[" "]
        A["üì¶ <b>meta</b><br>Endere√ßo: <code>0xe8</code><br>Conte√∫do: <b>7.5</b>"]
        B["üì¶ <b>meta</b><br>Endere√ßo: <code>0xc0</code><br>Conte√∫do: <b>15</b>"]
  end

    s1 --dobrar_meta--> s2
    
     X:::var
     Y:::var
     A:::var
     B:::var
    classDef var fill:#A8E6CF,stroke:#2E7D32,color:#000,stroke-width:1px
    style s1 fill:transparent
    style s2 fill:transparent

```


Para solucionar isso, inv√©s de passarmos o conte√∫do armazenado, podemos passar o endere√ßo. Isso √© conhecido como passagem por refer√™ncia. Na verdade, ainda ser√° feita uma c√≥pia do valor passado, mas como esse valor copiado √© um endere√ßo (o ponteiro), esse artif√≠cio ser√° suficiente para manipularmos os dados originais. 

```{.c}
#include <stdio.h>

void dobrar_meta (double *meta){ 
    *meta = 2*(*meta); // Desreferencia√ß√£o 
}

int main (){
    double meta = 7.5;
    
    printf("meta: %.2f\n", meta);
    dobrar_meta(&meta); // Passando o endere√ßo
    printf("meta: %.2f\n", meta);

    return 0;
}
```

Sa√≠da:

```{.console code-line-numbers="false"}
meta: 7.50
meta: 15.00
```

Dessa vez, a fun√ß√£o modificou a vari√°vel original, pois passamos a refer√™ncia. Vamos ilustrar como isso aconteceu.

| Vari√°vel	| Endere√ßo	| Conte√∫do |
| ----------|-----------|-------|
| main `meta` | [0xe8]{.mark}	| 7.5 |
| local `meta` | 0xc0	| [0xe8]{.mark} |

Dentro da fun√ß√£o, quando fazemos `*meta`, o C faz a desreferencia√ß√£o, ou seja, retorna o conte√∫do do local cujo o endere√ßo √© 0xe8. Neste local, a opera√ß√£o de dobrar √© efetuada.

| Vari√°vel	| Endere√ßo	| Valor |
| ----------|-----------|-------|
| main `meta` | [0xe8]{.mark}	| 15 |
| local `meta` | 0xc0	| [0xe8]{.mark} |

Ao finalizar, a vari√°vel `meta` da fun√ß√£o `main` sofreu a altera√ß√£o.

```{mermaid}
flowchart LR
 subgraph s1[" "]
        X["üì¶ <b>meta</b><br>Endere√ßo: <code>0xe8</code><br>Conte√∫do: <b>7.5</b>"]
        Y["üéØ <b>meta</b><br>Endere√ßo: <code>0xc0</code><br>Conte√∫do: <b>0xe8</b>"]
  end
 subgraph s2[" "]
        A["üì¶ <b>meta</b><br>Endere√ßo: <code>0xe8</code><br>Conte√∫do: <b>15</b>"]
        B["üéØ <b>meta</b><br>Endere√ßo: <code>0xc0</code><br>Conte√∫do: <b>0xe8</b>"]
  end
    s1 -- dobrar_meta --> s2

     X:::var
     Y:::ptr
     A:::var
     B:::ptr
    classDef var fill:#A8E6CF,stroke:#2E7D32,color:#000,stroke-width:1px
    classDef ptr fill:#FFD3B6,stroke:#E65100,color:#000,stroke-width:1px;
    style s1 fill:transparent
    style s2 fill:transparent
```


::: {.callout-important}
Quando passamos o endere√ßo (`&meta`) para a fun√ß√£o `dobrar_meta`, a vari√°vel `meta` interna vai armazenar em seu conte√∫do um endere√ßo de mem√≥ria. Ou seja, ela √© um ponteiro e, portanto, podemos desreferenciar.
:::

::: {.callout-note icon="false" title="üéØ Desafio de C√≥digo"}
Implemente uma fun√ß√£o `swap` que troque os valores de duas vari√°veis.
Teste na `main` com:

```{.c code-line-numbers="false"}
int x = 10, y = 20;
swap(&x, &y);
printf("x = %d, y = %d\n", x, y);
```

Sa√≠da esperada: `x = 20, y = 10`
:::


::: {.callout-tip title="Solu√ß√£o (clique para ver)" collapse="true"}
```{.c}
#include <stdio.h> 

void swap(int *a, int *b){
    int aux = *a;
    a* = *b;
    b* = aux;
}

int main(){
    int x = 10, y = 20;
    swap(&x, &y);
    printf("x = %d, y = %d\n", x, y);

    return 0;
}
```
:::


Nesta unidade, voc√™ aprendeu

‚úÖ a declarar e desreferenciar ponteiros

‚úÖ a modificar valores via ponteiros

‚úÖ a passar vari√°veis por refer√™ncia



::: {.callout-tip}
Se voc√™ quiser aprofundar mais seu conhecimento sobre ponteiros, revise materiais sobre aritm√©tica de ponteiros e a rela√ß√£o entre _arrays_ e ponteiros.
:::

### Ponteiros de Fun√ß√£o

A boa not√≠cia √© que um ponteiro tamb√©m pode armazenar o endere√ßo de uma fun√ß√£o. O racioc√≠nio √© o mesmo, mas a sintaxe para a declara√ß√£o √© mais espec√≠fica, pois ela precisa descrever a assinatura completa da fun√ß√£o: seu tipo de retorno e seus par√¢metros.

Vamos tomar a fun√ß√£o `media` como exemplo:

```{.c code-line-numbers="false"}
double media (double n1, double n2){
  return (n1+n2)/2
};

// Declara√ß√£o de um ponteiro de fun√ß√£o:
double (*mediaPtr)(double, double) = media;
```

A sintaxe de declara√ß√£o deve ser lida da seguinte forma:

- `double`: O tipo de retorno da fun√ß√£o que ser√° apontada.

- `(*mediaPtr)`: Declara mediaPtr como um ponteiro. Os par√™nteses s√£o obrigat√≥rios para diferenci√°-lo de uma fun√ß√£o que retorna um ponteiro.

- `(double, double)`: Os tipos dos par√¢metros de entrada da fun√ß√£o.

::: {.callout-note }
Diferentemente das vari√°veis, ao atribuir o endere√ßo de uma fun√ß√£o a um ponteiro de fun√ß√£o, n√£o √© necess√°rio usar o operador & (o nome da fun√ß√£o sozinho j√° representa seu endere√ßo).
:::

Note que a fun√ß√£o `media` obedece ao **contrato** estabelecido pelo ponteiro de fun√ß√£o `mediaPtr`, ou seja, possui o mesmo **tipo de retorno** e os mesmos **tipos de par√¢metros de entrada** (`double, double`) Portanto, devemos manter a **compatibilidade** de tipos.

Com esse art√≠ficio, podemos contruir fun√ß√µes param√©tricas. 

### Fun√ß√µes Param√©tricas

O verdadeiro poder dos ponteiros de fun√ß√£o reside na capacidade de passar uma fun√ß√£o como argumento para outra. Essa t√©cnica, conhecida como **fun√ß√µes de ordem superior** ou _callbacks_, permite criar um c√≥digo **param√©trico** e **flex√≠vel**.

Abaixo, um exemplo de uma calculadora de inteiros. A fun√ß√£o `operacao` √© o nosso _callback_ que decide qual opera√ß√£o aritm√©tica ser√° executada:

```{.c filename=calculadora_param.c}
#include <stdio.h>

// Fun√ß√µes concretas
int soma (int a, int b)     { return a + b; }
int subtracao (int a, int b){ return a - b; }
int produto (int a, int b)  { return a * b; }
int divisao (int a, int b)  { return a / b; }

// Fun√ß√£o Coordenadora (param√©trica)
int calcular(int a, int b, int (*operacao)(int, int)) {
  // A fun√ß√£o 'operacao' passada como par√¢metro √© invocada aqui
  return operacao(a, b);
}

int main(){

  int n1 = 10;
  int n2 = 2;
  
  printf("Soma:      %d\n", calcular(n1, n2, soma));
  printf("Subtra√ß√£o: %d\n", calcular(n1, n2, subtracao));
  printf("Produto:   %d\n", calcular(n1, n2, produto));
  printf("Divis√£o:   %d\n", calcular(n1, n2, divisao));  
  
  return 0;
}
```

A sa√≠da desse programa ser√°

```{.console code-line-numbers="false"}
  Soma:      12
  Subtra√ß√£o: 8
  Produto:   20
  Divis√£o:   5 
```
Ao **passar a fun√ß√£o como par√¢metro**, tornamos o c√≥digo de C extremamente **poderoso e reutiliz√°vel**. A fun√ß√£o `calcular` n√£o se importa como o c√°lculo √© feito, apenas que a fun√ß√£o fornecida (o _callback_) respeite o contrato de tipos (`int` para retorno, e `int`, `int` para par√¢metros).

Ser√° que podemos melhorar essa reutiliza√ß√£o? Sim, mas atingimos o limite do **{{< glossary polimorfismo >}}** simples em C. Imagine que voc√™ queira adicionar uma opera√ß√£o com n√∫meros de ponto flutuante:


```{.c code-line-numbers="false"}
double somad (double a, double b) { return a + b; }
```

O problema √© que n√£o podemos passar `somad` para a fun√ß√£o `calcular` e nem a usar para operar com `double`, pois o _callback_ `int (*operacao)(int, int)` e os par√¢metros fixos em `calcular(int a, int b, ...)` tornam essa fun√ß√£o totalmente incompat√≠vel com o tipo `double`.

Para resolver esse problema e criar uma √∫nica fun√ß√£o verdadeiramente gen√©rica que aceite qualquer tipo de dado, precisamos abandonar os tipos concretos (`int`, `double`) e generalizar usando o ponteiro sem tipo (`void*`).


Antes de darmos o salto para o c√≥digo verdadeiramente gen√©rico usando `void*`, vamos usar o `typedef` para melhorar a legibilidade de nosso c√≥digo.

A sintaxe de um ponteiro de fun√ß√£o (`int (*operacao)(int, int)`) √© complexa e pode dificultar a leitura do c√≥digo. O `typedef` permite que voc√™ crie um apelido para essa assinatura complexa, tratando-a como um novo tipo de dado simples.

Ao definir o tipo do _callback_, tornamos a fun√ß√£o `calcular` muito mais limpa:


```c
// Definimos 'Operacao' como o tipo para qualquer fun√ß√£o
// que retorna int e aceita dois int como par√¢metros.
typedef int (*Operacao)(int, int);

// A fun√ß√£o 'calcular' agora usa o tipo 'Operacao', 
// simplificando sua assinatura.
int calcular(int a, int b, Operacao operacao); 
```
O c√≥digo final ficaria assim:

```{.c filename=calculadora_typedef.c}
#include <stdio.h>

// Defini√ß√£o do TIPO de ponteiro de fun√ß√£o
typedef int (*Operacao)(int, int);

// Fun√ß√µes concretas (omitidas para brevidade)
int soma (int a, int b) { return a + b; }
// ...

// A Fun√ß√£o Coordenadora agora √© mais leg√≠vel
int calcular(int a, int b, Operacao operacao) {
  return operacao(a, b);
}

int main(){

  int n1 = 10;
  int n2 = 2;
  
  printf("Soma: %d\n", calcular(n1, n2, soma));
  
  return 0;
}
```

### Fun√ß√µes Gen√©ricas

Agora que limpamos um pouco o c√≥digo, voltemos ao nosso problema principal. Lembre-se que a fun√ß√£o `calcular` e, por consequ√™ncia, o tipo `Operacao` que definimos, est√£o estritamente ligados ao tipo `int`.

Para que nossa calculadora suporte opera√ß√µes com qualquer tipo (como `double` ou at√© mesmo estruturas complexas), precisamos de um novo contrato. Esse novo contrato n√£o pode mais especificar `int` ou `double`. A solu√ß√£o para esse problema √© utilizar os ponteiros gen√©ricos (`void*`), que s√£o ponteiros sem tipo. O `void*` nos permitir√° criar um novo `typedef` e uma nova fun√ß√£o gen√©rica que aceitar√° qualquer tipo de dado.

Primeiramente, vamos definir um arquivo de cabe√ßalho (a interface). Isso √© uma pr√°tica fundamental em C e refor√ßa o conceito de que a fun√ß√£o `main` s√≥ precisa conhecer o contrato (a interface `.h`) para usar o c√≥digo gen√©rico, sem se preocupar com os detalhes da implementa√ß√£o.


```{.c filename=calculadora.h}
// O typedef agora define o contrato gen√©rico:
typedef void* (*Operacao)(void*, void*);

// O prot√≥tipo da fun√ß√£o coordenadora
void* calcular(void *a, void *b, Operacao operacao); 

// Prot√≥tipos das fun√ß√µes callback
void* soma (void *a, void *b);
void* somad (void *a, void *b);
```

Agora, partimos para a **implementa√ß√£o** da calculadora, onde a m√°gica dos ponteiros gen√©ricos acontece.

```{.c filename=calculadora.c}
#include "calculadora.h"
#include <stdlib.h>

// 1. Fun√ß√£o Coordenadora
// Ela apenas chama o callback (operacao) com os ponteiros de dados.
void* calcular(void *a, void *b, Operacao operacao){
  return operacao(a, b);
} 

// 2. Callbacks Gen√©ricos

// Callback para Soma de Inteiros 
void* soma (void *a, void *b){
    int *resultado = malloc(sizeof(int));
     *resultado = *(int*)a + *(int*)b;
 
    return (void*)resultado; 
}

// Callback para Soma de Ponto Flutuante
void* somad (void *a, void *b){
    double *resultado = malloc(sizeof(double));
     *resultado = *(double*)a + *(double*)b;
 
    return (void*)resultado; 
}
```

Por que essas fun√ß√µes precisam do `malloc`? √â fundamental notar que, nessa abordagem, as fun√ß√µes `soma` e `somad` n√£o podem simplesmente retornar o valor (como fizemos nas fun√ß√µes anteriores).

- Elas precisam retornar um endere√ßo de mem√≥ria (`void*`).
- Elas precisam garantir que esse endere√ßo de mem√≥ria **persista** ap√≥s o t√©rmino da fun√ß√£o.

O `malloc()` garante que o resultado seja armazenado na _heap_ (mem√≥ria din√¢mica), permitindo que a fun√ß√£o `calcular` e a fun√ß√£o `main` acessem esse resultado posteriormente. Isso, no entanto, torna a fun√ß√£o `main` respons√°vel por liberar essa mem√≥ria com `free()`, para evitar vazamento de mem√≥ria (_memory leak_).

Nas fun√ß√µes de _callback_, alocamos mem√≥ria para armazenar o NOVO resultado. Depois desreferenciamos (_cast_) os ponteiros `void*`, somamos os valores e armazenamos o resultado na nova √°rea de mem√≥ria. Por fim, retornamos o endere√ßo (`void*`) da nova mem√≥ria alocada.

Finalmente, a fun√ß√£o para testar nossa implementa√ß√£o pode ser constru√≠da.

```{.c filename=main.c}
#include "calculadora.h"
#include <stdio.h>
#include <stdlib.h>

int main() {
  int a = 10;
  int b = 2;
  double ad = 10.5;
  double bd = 2.2;
    
  // 1. Chamada Gen√©rica para Inteiros
  // Passamos os ENDERE√áOS (&a, &b) e a fun√ß√£o soma
  void *resultado_ptr = calcular(&a, &b, soma); 
  
  // 2. Chamada Gen√©rica para Doubles
  // Passamos os ENDERE√áOS (&ad, &bd) e a fun√ß√£o somad
  void *resultadod_ptr = calcular(&ad, &bd, somad); 

  // 3. Impress√£o e Desreferencia√ß√£o
  // Fazemos o CAST do ponteiro void* de volta para o tipo original
  printf("Soma Int: %d\n", *(int*)resultado_ptr);
  printf("Soma double: %.2f\n", *(double*)resultadod_ptr);
    
  // 4. Libera√ß√£o de Mem√≥ria (Crucial!)
  // Liberamos a mem√≥ria alocada dentro das fun√ß√µes soma e somad
  free(resultado_ptr);
  free(resultadod_ptr);

  return 0;
}
```

Para compilar nosso projeto execute o comando abaixo.

```{.console code-line-numbers="false"}
$ gcc calculadora.c main.c -o calculadora
```

Para executar o programa fa√ßa:

- Windows:

```{.console code-line-numbers="false"}
$ .\calculadora
```
- Linux/macOS

```{.console code-line-numbers="false"}
$ ./calculadora
```

O programa deve rodar e produzir a sa√≠da correta, provando que nossa implementa√ß√£o gen√©rica funciona:

```{.console code-line-numbers="false"}
  Soma Int: 12
  Soma double: 12.70
```

::: {.callout-important}
Se voc√™ foi com muita sede ao pote, apenas clicando no bot√£o de _play_ no seu ambiente de desenvolvimento, notou que deu tudo errado. O erro acontece porque, quando usamos mais de um arquivo `.c` (como no nosso caso, com `calculadora.c` e `main.c`), √© necess√°rio que o compilador realize a **linkagem** de todos os componentes para que a compila√ß√£o funcione.

√Ä medida que os projetos C crescem, digitar comandos de compila√ß√£o longos e repetir o processo ap√≥s cada pequena altera√ß√£o se torna ineficiente. Busque o conceito de `Makefile` e o utilit√°rio `make`. Essas ferramentas s√£o essenciais para automatizar a compila√ß√£o e garantir que apenas as partes alteradas do c√≥digo sejam recompiladas, acelerando drasticamente o seu ciclo de desenvolvimento.

Com `make`, voc√™ simplifica o processo de compila√ß√£o para um √∫nico comando no terminal.
:::

### Digress√£o

Neste momento, vamos mudar nosso foco para apresentar um estilo de programa√ß√£o mais profissional. A primeira boa pr√°tica √© usar a palavra-chave `const` para par√¢metros de fun√ß√µes que n√£o ser√£o modificados.

Por exemplo, sabemos que os par√¢metros de entrada da fun√ß√£o `soma` s√£o usados apenas para leitura. Por **seguran√ßa** e **clareza**, devemos adicionar o modificador `const`.

Ao aplicar `const` a ponteiros gen√©ricos (`void*`), indicamos que o conte√∫do da mem√≥ria apontada n√£o ser√° alterado:

```{.c code-line-numbers="false"}
void* soma (const void *a, const void *b){
    // implementa√ß√£o 
}
```

Usar a palavra-chave `const` em par√¢metros de fun√ß√µes em C melhora drasticamente a **seguran√ßa** e a **clareza** do seu c√≥digo. 

- **Seguran√ßa**: Voc√™ est√° prometendo ao compilador (e a outros programadores) que a fun√ß√£o n√£o modificar√° o conte√∫do do ponteiro que est√° sendo passado. O compilador refor√ßa essa promessa, impedindo modifica√ß√µes acidentais (prote√ß√£o de dados).

- **Clareza da Inten√ß√£o**: Fica imediatamente claro para quem l√™ a assinatura da fun√ß√£o quais par√¢metros s√£o apenas para leitura, reduzindo a necessidade de consultar a documenta√ß√£o interna da fun√ß√£o para entender seu comportamento.

- **Otimiza√ß√£o do Compilador**: O compilador pode usar essa informa√ß√£o de "somente leitura" para realizar otimiza√ß√µes de c√≥digo, como manter a vari√°vel em um registro do processador, o que pode levar a um desempenho marginalmente melhor.

Outra boa pr√°tica √© usar tipo `size_t` para representar tamanhos e contagens de objetos na mem√≥ria. Ele √© o tipo de dado inteiro sem sinal (_unsigned integer_) recomendado e padronizado em C. Podemos listar como raz√µes para a escolha de `size_t` ao inv√®s de `int`:

- **Garantia de N√£o-Negatividade**: Tamanhos e contagens (como o n√∫mero de elementos em uma lista ou o tamanho de um _buffer_) nunca podem ser negativos. O `size_t` √© um tipo sem sinal, o que elimina a possibilidade de erros causados por valores negativos acidentais.

- **Padr√£o de API**: Fun√ß√µes padr√£o da biblioteca C, como `malloc`, `sizeof`, `memcpy`, `strlen`, e `calloc`, usam e esperam argumentos do tipo `size_t` para tamanhos e contagens. Usar `size_t` garante consist√™ncia e evita avisos (_warnings_) ou _casts_ desnecess√°rios.

Em resumo, use `size_t` para qualquer vari√°vel que represente uma quantidade, um tamanho em _bytes_, ou um √≠ndice de _array_/estrutura. Por exemplo, em uma implementa√ß√£o de lista, podemos usar `size_t` para contagem dos n√≥s, tamanho em _bytes_ do dado que √© armazenado e para representar o indice de uma itera√ß√£o. 

Outro abordagem √© armazenar os _callbacks_ dentro da estrutura. Isso coloca nosso design de c√≥digo em um alto n√≠vel. Vamos modificar nosso projeto da calculadora para demonstrar como ficaria a implementa√ß√£o com tais mudan√ßas.


{{< include /_includes/progress-bar.qmd >}}
