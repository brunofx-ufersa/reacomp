---
title: "Ponteiros (Revis√£o)"
lang: pt
toc-title: Conte√∫do
format:
  html:
    css: ../styles/academic.css
---

Por muito tempo, construir estruturas de dados, como listas e √°rvores, exigia que os desenvolvedores as reescrevessem para cada tipo de dado. Era uma batalha constante: uma lista para n√∫meros inteiros, outra para textos, outra para dados de usu√°rios, e assim por diante. Essa repeti√ß√£o n√£o apenas consumia tempo, mas tamb√©m abria portas para erros e inconsist√™ncias.

A ideia de estruturas gen√©ricas √© poder construir estruturas universais que podem ser aplicadas em qualquer projeto. Embora a linguagem C n√£o tenha suporte nativo a "gen√©ricos", como C++ ou Java, a solu√ß√£o tradicional e elegante √© usar ponteiros `void*` e fun√ß√µes de _callback_. 

Antes de explorarmos essas estruturas, √© fundamental revisar e aprofundar dois conceitos cruciais: **ponteiros** e **ponteiros de fun√ß√£o**.

Como voc√™ deve ter visto em **Algoritmos e Estruturas de Dados 1**, um **ponteiro** √© uma vari√°vel que armazena o **endere√ßo de mem√≥ria** de outra vari√°vel. Essa capacidade √© a base para criar estruturas de dados com tamanho din√¢mico (que crescem ou diminuem em tempo de execu√ß√£o).


## Declara√ß√£o {#sec-dec}

Quando declaramos uma vari√°vel e atribu√≠mos um valor, esse valor √© armazenado em um endere√ßo de mem√≥ria. Quando escrevemos `int x = 10;`, ocorrem dois passos conceituais:

- **Declara√ß√£o**: o programa reserva um espa√ßo na mem√≥ria para armazenar um inteiro.
- **Atribui√ß√£o**: o valor `10` √© gravado nesse espa√ßo de mem√≥ria, que possui um endere√ßo.

A vari√°vel `x` √© apenas um r√≥tulo usado pelo programador.

| Vari√°vel | Endere√ßo | Conte√∫do |
|--------|----------|-------|
|   `x`    |   0x75   |  10   |


O princ√≠pio b√°sico de um ponteiro √© a **compatibilidade de tipo**, ou seja, um ponteiro deve ser do mesmo tipo do dado que ele aponta.

```{.c}
double meta = 7.5;
double *meta_ptr = &meta; // O operador & retorna o endere√ßo na mem√≥ria
```

Na linha 2, `meta_ptr` guarda o endere√ßo da vari√°vel `meta`. 

O quadro abaixo ilustra a mem√≥ria depois das declara√ß√µes do trecho de c√≥digo anterior.

| Vari√°vel	| Endere√ßo	| Conte√∫do | 
|------|----------|-------|
| `meta`	| [0x55]{.mark} | 7.5 |
| `meta_ptr`	| 0x58 |	[0x55]{.mark} |

Estamos usando endere√ßos fict√≠cios. Note que `meta_ptr` guarda o endere√ßo de `meta`. Neste caso, dizemos que `meta_ptr` **aponta** para `meta`. 

Vamos explorar outro exemplo usando um diagrama que ilustra uma mem√≥ria.

```{mermaid}
flowchart RL
    %% N√≥s de vari√°veis e ponteiros
    X["üì¶ <b>x</b><br/>Endere√ßo: <code>0x100</code><br/>Conte√∫do: <b>42</b>"]
    Y["üì¶ <b>y</b><br/>Endere√ßo: <code>0x200</code><br/>Conte√∫do: <b>137</b>"]
    P["üéØ <b>p</b><br/>Endere√ßo: <code>0x300</code><br/>Conte√∫do: <code>0x100</code>"]
    PP["üéØ <b>pp</b><br/>Endere√ßo: <code>0x400</code><br/>Conte√∫do: <code>0x300</code>"]

    %% Conex√µes
    PP -->|"aponta para"| P
    P -->|"aponta para"| X
    P ~~~ Y
    Y ~~~ X

    %% Estilos de formata√ß√£o
    classDef var fill:#A8E6CF,stroke:#2E7D32,color:#000,stroke-width:1px;
    classDef ptr fill:#FFD3B6,stroke:#E65100,color:#000,stroke-width:1px;
    class X,Y var
    class P,PP ptr
```

As vari√°veis `x` e `y` carregam dados que est√£o armazenados nos endere√ßos `0x100` e `0x200`, respectivamente. A vari√°vel `p` √© um ponteiro cujo conte√∫do √© `0x100`, portanto aponta para `x`. A vari√°vel `pp` √© outro ponteiro, mas com conte√∫do `0x300`, ou seja, aponta para o local com endere√ßo `0x300`, que seria `p`. Isso mesmo um ponteiro de ponteiro. O c√≥digo que representa esse diagrama poder ser o seguinte.

```{.c code-line-numbers="false"}
int x = 42;
int y = 137;
int *p = &x;
int **pp = &p;
```

Resumindo

- x ‚Üí cont√©m 42 e est√° no endere√ßo `0x100`;
- y ‚Üí cont√©m 137 e est√° no endere√ßo `0x200`;
- p ‚Üí cont√©m `0x100` (o endere√ßo de x);
- pp ‚Üí cont√©m `0x300` (o endere√ßo de p).


H√° declara√ß√µes de ponteiros ligeiramente diferentes:

```{.c code-line-numbers="false"}
double *meta_ptr = &meta;
double* meta_ptr = &meta;
double * meta_ptr = &meta;
```

No entanto, a primeira √© mais recomendada: `tipo *ponteiro = &variavel`.


## Desreferencia√ß√£o {#sec-des}

Uma opera√ß√£o importante com ponteiros √© a **desreferencia√ß√£o** (ou dereferencing). Ela ocorre quando acessamos o conte√∫do armazenado no endere√ßo que o ponteiro aponta. Por exemplo,

```{.c}
double meta = 7.5;
double *meta_ptr = &meta; // O operador & retorna o endere√ßo na mem√≥ria
printf("*meta_ptr: %.2f\n", *meta_ptr); // *meta_ptr: 7.50
```

Na linha 3, o operador `*` serve para desreferenciar. Ao usar `*meta_ptr` na impress√£o, o C acessa o valor armazenado nesse endere√ßo (7.5). 

::: {.callout-tip}

O `*` tem dupla fun√ß√£o:

- Declarar um ponteiro (`double *p`)
- Desreferenciar um ponteiro (`*p`)
:::

√â v√°lido mencionar que, em uma vari√°vel que guarda um dado, podemos acessar o dado e o endere√ßo. J√° em um ponteiro, podemos acessar seu endere√ßo, o conte√∫do (outro endere√ßo) e o dado armazenado pela vari√°vel que ele aponta:

```{.c code-line-numbers="false"}
int idade = 12;
int *idade_ptr = &idade;

printf("idade: %d\n", idade);
printf("&idade: %x\n", &idade);

printf("&idade_ptr: %x\n", &idade_ptr); // Endere√ßo do ponteiro
printf("idade_ptr: %x\n", idade_ptr);   // Endere√ßo de idade
printf("*idade_ptr: %d\n", *idade_ptr); // Conte√∫do de idade
```

Al√©m de ler o conte√∫do de uma vari√°vel, tamb√©m podemos modific√°-lo indiretamente usando ponteiros:

```{.c code-line-numbers="false"}
double meta = 7.5;
double *meta_ptr = &meta; 

*meta_ptr = 10;
printf("meta: %.2f\n", meta); // meta: 10.00
```
Mudamos o valor de `meta` sem acess√°-la diretamente. Isso √© o poder dos ponteiros!


::: {.callout-note icon="false" title="üéØ Desafio de C√≥digo"}

- Crie um ponteiro `int *p` que aponte para uma vari√°vel `x = 5`.
- Use `*p` para alterar `x` para `42`.
- Depois, exiba o valor e o endere√ßo de `x` no console.
:::


::: {.callout-tip title="Solu√ß√£o (clique para ver)" collapse="true"}
```{.c}
#include <stdio.h> 

int main(){
    int x = 5;
    int *p = &x;
    *p = 42;

    printf("x: %d\n", x);
    printf("&x: %p\n", &x);

    return 0;
}
```
:::

::: {.callout-note icon="false" title="üéØ Desafio de C√≥digo"}

- Passo 1: Declare um ponteiro `ponteiro_chave` que aponte para a `chave_secreta`.
- Passo 2: Mude o valor da `chave_secreta` para 99 usando o ponteiro.
- Passo 3: Imprima o valor da chave secreta.
    
```{.c}
#include <stdio.h>

int main() {
    int chave_secreta = 10;
    // SEU C√ìDIGO

    return 0;
}
```
:::

::: {.callout-tip title="Solu√ß√£o (clique para ver)" collapse="true"}
```{.c}
#include <stdio.h> 

int main() {
    int chave_secreta = 10;
    int *ponteiro_chave = &chave_secreta;
    *ponteiro_chave = 99;

    printf("chave_secreta: %d\n", chave_secreta);
    return 0;
}
```
:::


## Ponteiros como par√¢metros {#sec-par}


Em C, os par√¢metros s√£o passados por valor. Portanto, a fun√ß√£o recebe uma c√≥pia do argumento.

```{.c code-line-numbers="false"}
void dobrar_meta (double meta){ 
    meta = 2*meta; 
}
```

Na `main`:

```{.c code-line-numbers="false"}
double meta = 7.5;
printf("meta: %.2f\n", meta);
dobrar_meta(meta);
printf("meta: %.2f\n", meta);
```

Sa√≠da:

```{.console code-line-numbers="false"}
meta: 7.50
meta: 7.50
```

Esperav√°mos que no exemplo acima, o valor de `meta` tivesse sido dobrado, mas nada mudou. A raz√£o √© que a fun√ß√£o alterou apenas a c√≥pia local. A vari√°vel `meta` na fun√ß√£o `main` √© global, j√° na fun√ß√£o `dobrar_meta` √© local. Significa que quando esta fun√ß√£o termina, as vari√°veis s√£o descartadas.

Imprimindo os endere√ßos, vamos constatar que trata-se de vari√°veis diferentes.

```{.c code-line-numbers="false"}
void dobrar_meta (double meta){ 
    printf("local &meta: %x\n", &meta);
    meta = 2*meta; 
}
```

Na `main`:

```{.c code-line-numbers="false"}
double meta = 7.5;
printf("main &meta: %x\n", &meta);
dobrar_meta(meta);
```

Sa√≠da:

```{.console code-line-numbers="false"}
main &meta: 0xe8
local &meta: 0xc0
```
Os endere√ßos s√£o diferentes. Logo, n√£o s√£o as mesmas vari√°veis que estamos manipulando

A vari√°vel interna em `dobrar_meta` √© criada em outra regi√£o de mem√≥ria e recebe uma c√≥pia do valor passado como argumento. Esse valor √© dobrado em seguida, mas n√£o reflete na vari√°vel da fun√ß√£o `main`, pois ela est√° alocada em outra posi√ß√£o.


```{mermaid}
flowchart LR
 subgraph s1[" "]
        X["üì¶ <b>meta</b><br>Endere√ßo: <code>0xe8</code><br>Conte√∫do: <b>7.5</b>"]
        Y["üì¶ <b>meta</b><br>Endere√ßo: <code>0xc0</code><br>Conte√∫do: <b>7.5</b>"]
  end

 subgraph s2[" "]
        A["üì¶ <b>meta</b><br>Endere√ßo: <code>0xe8</code><br>Conte√∫do: <b>7.5</b>"]
        B["üì¶ <b>meta</b><br>Endere√ßo: <code>0xc0</code><br>Conte√∫do: <b>15</b>"]
  end

    s1 --dobrar_meta--> s2
    
     X:::var
     Y:::var
     A:::var
     B:::var
    classDef var fill:#A8E6CF,stroke:#2E7D32,color:#000,stroke-width:1px
    style s1 fill:transparent
    style s2 fill:transparent

```


Para solucionar isso, inv√©s de passarmos o conte√∫do armazenado, podemos passar o endere√ßo. Isso √© conhecido como passagem por refer√™ncia. Na verdade, ainda ser√° feita uma c√≥pia do valor passado, mas como esse valor copiado √© um endere√ßo (o ponteiro), esse artif√≠cio ser√° suficiente para manipularmos os dados originais. 

```{.c}
#include <stdio.h>

void dobrar_meta (double *meta){ 
    *meta = 2*(*meta); // Desreferencia√ß√£o 
}

int main (){
    double meta = 7.5;
    
    printf("meta: %.2f\n", meta);
    dobrar_meta(&meta); // Passando o endere√ßo
    printf("meta: %.2f\n", meta);

    return 0;
}
```

Sa√≠da:

```{.console code-line-numbers="false"}
meta: 7.50
meta: 15.00
```

Dessa vez, a fun√ß√£o modificou a vari√°vel original, pois passamos a refer√™ncia. Vamos ilustrar como isso aconteceu.

| Vari√°vel	| Endere√ßo	| Conte√∫do |
| ----------|-----------|-------|
| main `meta` | [0xe8]{.mark}	| 7.5 |
| local `meta` | 0xc0	| [0xe8]{.mark} |

Dentro da fun√ß√£o, quando fazemos `*meta`, o C faz a desreferencia√ß√£o, ou seja, retorna o conte√∫do do local cujo o endere√ßo √© 0xe8. Neste local, a opera√ß√£o de dobrar √© efetuada.

| Vari√°vel	| Endere√ßo	| Valor |
| ----------|-----------|-------|
| main `meta` | [0xe8]{.mark}	| 15 |
| local `meta` | 0xc0	| [0xe8]{.mark} |

Ao finalizar, a vari√°vel `meta` da fun√ß√£o `main` sofreu a altera√ß√£o.

```{mermaid}
flowchart LR
 subgraph s1[" "]
        X["üì¶ <b>meta</b><br>Endere√ßo: <code>0xe8</code><br>Conte√∫do: <b>7.5</b>"]
        Y["üéØ <b>meta</b><br>Endere√ßo: <code>0xc0</code><br>Conte√∫do: <b>0xe8</b>"]
  end
 subgraph s2[" "]
        A["üì¶ <b>meta</b><br>Endere√ßo: <code>0xe8</code><br>Conte√∫do: <b>15</b>"]
        B["üéØ <b>meta</b><br>Endere√ßo: <code>0xc0</code><br>Conte√∫do: <b>0xe8</b>"]
  end
    s1 -- dobrar_meta --> s2

     X:::var
     Y:::ptr
     A:::var
     B:::ptr
    classDef var fill:#A8E6CF,stroke:#2E7D32,color:#000,stroke-width:1px
    classDef ptr fill:#FFD3B6,stroke:#E65100,color:#000,stroke-width:1px;
    style s1 fill:transparent
    style s2 fill:transparent
```


::: {.callout-important}
Quando passamos o endere√ßo (`&meta`) para a fun√ß√£o `dobrar_meta`, a vari√°vel `meta` interna vai armazenar em seu conte√∫do um endere√ßo de mem√≥ria. Ou seja, ela √© um ponteiro e, portanto, podemos desreferenciar.
:::

::: {.callout-note icon="false" title="üéØ Desafio de C√≥digo"}
Implemente uma fun√ß√£o `swap` que troque os valores de duas vari√°veis.
Teste na `main` com:

```{.c code-line-numbers="false"}
int x = 10, y = 20;
swap(&x, &y);
printf("x = %d, y = %d\n", x, y);
```

Sa√≠da esperada: `x = 20, y = 10`
:::


::: {.callout-tip title="Solu√ß√£o (clique para ver)" collapse="true"}
```{.c}
#include <stdio.h> 

void swap(int *a, int *b){
    int aux = *a;
    a* = *b;
    b* = aux;
}

int main(){
    int x = 10, y = 20;
    swap(&x, &y);
    printf("x = %d, y = %d\n", x, y);

    return 0;
}
```
:::


Nesta unidade, voc√™ aprendeu

‚úÖ a declarar e desreferenciar ponteiros

‚úÖ a modificar valores via ponteiros

‚úÖ a passar vari√°veis por refer√™ncia



::: {.callout-tip}
Se voc√™ quiser aprofundar mais seu conhecimento sobre ponteiros, revise materiais sobre aritm√©tica de ponteiros e a rela√ß√£o entre _arrays_ e ponteiros.
:::


{{< include /_includes/progress-bar.qmd >}}
