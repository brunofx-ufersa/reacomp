<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="pt" xml:lang="pt"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.24">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Tabela de Dispersão – REAComp</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../../">
<link href="../../../../img/logo.png" rel="icon" type="image/png">
<script src="../../../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../site_libs/quarto-html/quarto-syntax-highlighting-dc55a5b9e770e841cd82e46aadbfb9b0.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../../../site_libs/quarto-html/quarto-syntax-highlighting-dark-b651517ce65839d647a86e2780455cfb.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="../../../../site_libs/quarto-html/quarto-syntax-highlighting-dc55a5b9e770e841cd82e46aadbfb9b0.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../site_libs/bootstrap/bootstrap-f27957d2c769e3c969afb3e6fade3360.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../../../site_libs/bootstrap/bootstrap-dark-a3508ca507676472fbcc2360244a2547.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<link href="../../../../site_libs/bootstrap/bootstrap-f27957d2c769e3c969afb3e6fade3360.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "Nenhum resultado",
    "search-matching-documents-text": "documentos correspondentes",
    "search-copy-link-title": "Copiar link para a busca",
    "search-hide-matches-text": "Esconder correspondências adicionais",
    "search-more-match-text": "mais correspondência neste documento",
    "search-more-matches-text": "mais correspondências neste documento",
    "search-clear-button-title": "Limpar",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancelar",
    "search-submit-button-title": "Enviar",
    "search-label": "Procurar"
  }
}</script>
<script src="../../../../site_libs/quarto-diagram/mermaid.min.js"></script>
<script src="../../../../site_libs/quarto-diagram/mermaid-init.js"></script>
<link href="../../../../site_libs/quarto-diagram/mermaid.css" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../../../styles.css">
<link rel="stylesheet" href="../styles/academic.css">
</head>

<body class="nav-fixed quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const darkModeDefault = authorPrefersDark;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../../../index.html" class="navbar-brand navbar-brand-logo">
    </a>
    <a class="navbar-brand" href="../../../../index.html">
    <span class="navbar-title">REAComp</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Procurar"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Alternar de navegação" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../../disciplinas.html"> 
<span class="menu-text">Recursos</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../../contribuicao.html"> 
<span class="menu-text">Participe</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../../blog.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../../about.html"> 
<span class="menu-text">Sobre</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Alternar modo escuro"><i class="bi"></i></a>
  <a href="" class="quarto-reader-toggle quarto-navigation-tool px-1" onclick="window.quartoToggleReader(); return false;" title="Alternar modo de leitor">
  <div class="quarto-reader-toggle-btn">
  <i class="bi"></i>
  </div>
</a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content">


<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Tabela de Dispersão</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>Nesta unidade do curso, iremos estudar as <strong>tabelas de dispersão</strong> (<em>hash table</em>). Pense em uma busca que não demora, que não precisa de caminhadas longas por uma lista ou descidas por uma árvore. Imagine que você pode encontrar qualquer dado em um instante, de forma quase mágica. Essa é a promessa de uma tabela de dispersão.</p>
<p>Vamos explorar o conceito de <strong>função de hash</strong>, que é o coração dessa estrutura, e aprenderemos a lidar com as <strong>colisões</strong>. Ao final, você terá em mãos uma das ferramentas mais rápidas e eficientes para a manipulação de grandes volumes de dados desde dicionários de programação até <em>caches</em> de navegador e bancos de dados.</p>
<section id="problematização" class="level2">
<h2 class="anchored" data-anchor-id="problematização">Problematização</h2>
<p>Você está desenvolvendo um RPG retrô com restrições severas de memória, limitando seu catálogo mestre de itens a um array de apenas 10 slots (índices de 0 a 9).</p>
<p>No entanto, o jogo tem muito mais do que 10 itens no total, e cada um tem um ID inteiro único (a chave).</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Item</th>
<th>ID (chave)</th>
<th>Cor (valor)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Poção de Vida</td>
<td>12</td>
<td>Vermelho</td>
</tr>
<tr class="even">
<td>Amuleto Raro</td>
<td>18</td>
<td>Ouro</td>
</tr>
<tr class="odd">
<td>Espada Longa</td>
<td>21</td>
<td>Aço</td>
</tr>
<tr class="even">
<td>Pão Velho</td>
<td>3</td>
<td>Marrom</td>
</tr>
<tr class="odd">
<td>Armadura de Couro</td>
<td>15</td>
<td>Couro</td>
</tr>
</tbody>
</table>
<p>O desafio é como mapear IDs muito maiores que 9 (12, 22, 13) para um slot que só vai de 0 a 9, e ainda assim conseguir encontrá-los rapidamente?</p>
</section>
<section id="proposta-de-solução" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="proposta-de-solução">Proposta de solução</h2>
<p>A ideia é usar uma função que transforma qualquer ID em um número entre 0 e 9, reaproveitando o mesmo espaço de forma controlada.</p>
<p>Essa função é o módulo (resto da divisão):</p>
<p><span class="math display">\[h(id) = id\bmod 10\]</span></p>
<p>Como o divisor é <span class="math inline">\(10\)</span>, os únicos valores de resto possíveis são os números de 0 a 9, como desejamos.</p>
<p>Aplicando a função aos nossos itens:</p>
<ul>
<li><span class="math inline">\(h(12) = 12 \bmod 10 = 2\)</span></li>
<li><span class="math inline">\(h(18) = 18 \bmod 10 = 8\)</span></li>
<li><span class="math inline">\(h(21) = 21 \bmod 10 = 1\)</span></li>
<li><span class="math inline">\(h(3)\,\,\,= 3\,\,\,\bmod 10 = 3\)</span></li>
<li><span class="math inline">\(h(15) = 15 \bmod 10 = 5\)</span></li>
</ul>
<p>Dessa maneira, nosso vetor resultante seria:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 7%">
<col style="width: 9%">
<col style="width: 10%">
<col style="width: 10%">
<col style="width: 7%">
<col style="width: 7%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 7%">
</colgroup>
<thead>
<tr class="header">
<th>slot</th>
<th style="text-align: center;">0</th>
<th style="text-align: center;">1</th>
<th style="text-align: center;">2</th>
<th style="text-align: center;">3</th>
<th style="text-align: center;">4</th>
<th style="text-align: center;">5</th>
<th style="text-align: center;">6</th>
<th style="text-align: center;">7</th>
<th style="text-align: center;">8</th>
<th style="text-align: center;">9</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>id</td>
<td style="text-align: center;">❌</td>
<td style="text-align: center;">Espada Longa</td>
<td style="text-align: center;">Poção de Vida</td>
<td style="text-align: center;">Pão Velho</td>
<td style="text-align: center;">❌</td>
<td style="text-align: center;">Armadura de Couro</td>
<td style="text-align: center;">❌</td>
<td style="text-align: center;">❌</td>
<td style="text-align: center;">Amuleto Raro</td>
<td style="text-align: center;">❌</td>
</tr>
</tbody>
</table>
<p>Agora, para verificar se o jogador possui o Amuleto Raro, basta aplicar novamente a mesma função: <span class="math inline">\(h(18) = 18 \bmod 10 = 8\)</span>.</p>
<p>Sem precisar percorrer todo o <em>array</em>, o jogo já sabe que o item (se existir) estará na posição <span class="math inline">\(8\)</span>.</p>

<div class="no-row-height column-margin column-container"><div class="">
<p><strong><span class="text-warning">Se liga!</span></strong> Essa técnica permite economizar memória e acessar elementos em tempo constante, O(1).</p>
</div></div><p>Um questionamento comum acontece quando a função retorna o mesmo valor para duas chaves distintas. Por exemplo, com uma chave <span class="math inline">\(25\)</span>, teremos <span class="math inline">\(f(25)=25\bmod 10=5\)</span>, mas a posição <span class="math inline">\(5\)</span> já está ocupada e o vetor não está totalmente preenchido. Hesse caso, dizemos que ocorreu uma colisão.</p>
<p>Colisões são indesejáveis! Precisamos de funções bem definidas para evitar esse tipo de problema.</p>
</section>
<section id="função-hash" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="função-hash">Função Hash</h2>
<p>A função que escolhemos anteriormente é chamada de função de hash. Existem várias versões, mas a que mostramos é uma das mais simples.</p>
<section id="características-da-função-hash" class="level3">
<h3 class="anchored" data-anchor-id="características-da-função-hash">Características da Função Hash</h3>
<ul>
<li>Fácil de ser calculada;</li>
<li>Distribuição uniforme dos dados;</li>
<li>Minimiza as colisões;</li>
<li>Capaz de resolver possíveis colisões.</li>
</ul>
<p>A vantagem da tabela hash é a velocidade de busca, uma função muito complicada para calcular é incoveniente, pois pode demorar mais que uma busca em uma árvore binária, por exemplo. Além disso, se a função não distribui as chaves de maneira uniforme, muitas delas irão se concentrar em um local do vetor, aumentando a probabilidade de colisões.</p>
</section>
<section id="método-da-divisão" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="método-da-divisão">Método da Divisão</h3>
<p>No método da divisão, usamos o resultado do resto da divisão do valor da chave pelo tamanho da tabela. <span class="math display">\[h(k) = k \bmod m\]</span></p>
<p>O ideal é que <span class="math inline">\(m\)</span> seja um número primo e não muito próximo de potências de <span class="math inline">\(2\)</span>.</p>
<p>Por exemplo, se <span class="math inline">\(k=12345\)</span> e <span class="math inline">\(m=101\)</span>, então <span class="math display">\[h(k) = h(12345)= 12345 \bmod 101 = 22\]</span></p>
<p>A chave <span class="math inline">\(12345\)</span> deve ser alocada na posição <span class="math inline">\(22\)</span> do vetor de <span class="math inline">\(101\)</span> posições.</p>

<div class="no-row-height column-margin column-container"><div class="">
<p><strong><span class="text-warning">Se liga!</span></strong> Nem sempre trateremos com chaves inteiras simples como as vistas até aqui. Nesses casos, precisamos de um mecanismo para transformar em um valor inteiro antes de processar a função hash. Veremos isso à frente.</p>
</div></div><p>Este é o método mais simples e fácil de gerar um valor de hash. A função hash divide o valor <span class="math inline">\(k\)</span> (chave) por <span class="math inline">\(m\)</span> (tamanho da tabela) e, em seguida, usa o resto obtido. É mais adequado que <span class="math inline">\(m\)</span> seja um número primo, pois isso pode garantir que as chaves sejam distribuídas de forma mais uniforme.</p>
<p>Embora simples, o método da divisão leva a um desempenho ruim, uma vez que chaves consecutivas mapeiam para valores de hash consecutivos na tabela de hash.</p>
<div class="callout callout-style-default callout-note no-icon callout-titled" title="Exercício">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Nota</span>Exercício
</div>
</div>
<div class="callout-body-container callout-body">
<p>Dada a função hash <span class="math inline">\(h(k) = k^2\bmod 7\)</span>, calcule os valores hash para as chaves <span class="math display">\[4, 17, 13, 35, 25, 11, 2, 10, 32\]</span>.</p>
</div>
</div>
<div class="callout callout-style-default callout-tip callout-titled" title="Solução (clique para ver)">
<div class="callout-header d-flex align-content-center collapsed" data-bs-toggle="collapse" data-bs-target=".callout-2-contents" aria-controls="callout-2" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Dica</span>Solução (clique para ver)
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-2" class="callout-2-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<ul>
<li><span class="math inline">\(h(4)\,\,\,=\,\,\,4^2\bmod 7=16\bmod 7\,\,\,\,\,\,=2\)</span></li>
<li><span class="math inline">\(h(17)=17^2\bmod 7=289\bmod 7\,\,\,=2\)</span></li>
<li><span class="math inline">\(h(13)=13^2\bmod 7=169\bmod 7\,\,\,=1\)</span></li>
<li><span class="math inline">\(h(35)=35^2\bmod 7=1225\bmod 7=0\)</span></li>
<li><span class="math inline">\(h(25)=25^2\bmod 7=625\bmod 7\,\,\,=2\)</span></li>
<li><span class="math inline">\(h(11)=11^2\bmod 7=121\bmod 7\,\,\,=2\)</span></li>
<li><span class="math inline">\(h(2)\,\,\,=\,\,\,2^2\bmod 7=4\bmod 7\,\,\,\,\,\,\,\,\,=4\)</span></li>
<li><span class="math inline">\(h(10)=10^2\bmod 7=100\bmod 7\,\,\,=2\)</span></li>
<li><span class="math inline">\(h(32)=32^2\bmod 7=1024\bmod 7=2\)</span></li>
</ul>
<p>Muitas colisões ocorreram! Era evidente que haveria sobreposição de chaves, pois temos somentes sete espaços.</p>
</div>
</div>
</div>
</section>
<section id="método-da-multiplicação" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="método-da-multiplicação">Método da Multiplicação</h3>
<p>No método da multiplicação, realizamos os seguintes passos:</p>
<ul>
<li>Multiplicamos a chave (<span class="math inline">\(k\)</span>) por uma constate <span class="math inline">\(A\)</span> entre <span class="math inline">\(0\)</span> e <span class="math inline">\(1\)</span>;</li>
<li>Extraímos a parte fracionária de <span class="math inline">\(kA\)</span>;</li>
<li>Multiplicamos esse valor por <span class="math inline">\(m\)</span> (tamanho da tabela);</li>
<li>Arredondamos para baixo;</li>
</ul>
<p>Ou seja,</p>
<p><span class="math display">\[h(k) = \lfloor m (kA \bmod 1) \rfloor, \text{ com } 0 &lt; A &lt; 1\]</span></p>
<p>Por exemplo, considere <span class="math inline">\(k = 123\)</span>, <span class="math inline">\(m = 1000\)</span>, e <span class="math inline">\(A \approx 0,618\)</span>.</p>
<p><span class="math display">\[h(k) = \lfloor 1000 (123 \cdot 0,618 \bmod 1) \rfloor=\lfloor 1000 (76,014 \bmod 1) \rfloor=\lfloor 1000\cdot 0.014 \rfloor=14\]</span></p>
<p>A vantagem do método de multiplicação é que ele pode trabalhar com qualquer valor entre 0 e 1.</p>

<div class="no-row-height column-margin column-container"><div class="">
<p><strong><span class="text-warning">Se liga!</span></strong> O método de multiplicação é geralmente adequado quando o tamanho da tabela é uma potência de dois.</p>
</div></div><div class="callout callout-style-default callout-note no-icon callout-titled" title="Exercício">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Nota</span>Exercício
</div>
</div>
<div class="callout-body-container callout-body">
<p>Seja a chave <span class="math inline">\(k = 12345\)</span>, a constante <span class="math inline">\(A = 0,357840\)</span> e o tamanho da tabela <span class="math inline">\(m = 100\)</span>, calcule o valor hash usando o método da multiplicação.</p>
</div>
</div>
<div class="callout callout-style-default callout-tip callout-titled" title="Solução (clique para ver)">
<div class="callout-header d-flex align-content-center collapsed" data-bs-toggle="collapse" data-bs-target=".callout-4-contents" aria-controls="callout-4" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Dica</span>Solução (clique para ver)
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-4" class="callout-4-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p><span class="math display">\[h(k) = \lfloor m (kA \bmod 1) \rfloor\]</span> <span class="math inline">\(h(12345) = \lfloor 100 (12345\cdot 0,357840 \bmod 1) \rfloor=\lfloor 100 (4417,5348 \bmod 1) \rfloor=\lfloor 100 (0,5348) \rfloor=\lfloor 53,48 \rfloor=53\)</span></p>
</div>
</div>
</div>
</section>
<section id="hashing-universal" class="level3">
<h3 class="anchored" data-anchor-id="hashing-universal">Hashing Universal</h3>
<p>O hash universal tenta resolver o problema das colisões usando uma família de funções de hash, <span class="math inline">\(\mathcal{H}\)</span>, que possui uma propriedade matemática crucial:</p>
<blockquote class="blockquote">
<p>Para quaisquer duas chaves distintas, <span class="math inline">\(k_1\)</span> e <span class="math inline">\(k_2\)</span>, a probabilidade de que a função de hash <span class="math inline">\(h \in \mathcal{H}\)</span> escolhida aleatoriamente cause uma colisão é no máximo igual à probabilidade de colisão aleatória, que é <span class="math inline">\(1/m\)</span>, onde <span class="math inline">\(m\)</span> é o número de posições na tabela hash.</p>
</blockquote>
<p>Uma das famílias universais mais usadas para chaves que são números inteiros e uma tabela de tamanho <span class="math inline">\(m\)</span> é definida da seguinte forma:</p>
<p>Seja <span class="math inline">\(p\)</span> um número primo maior que qualquer chave possível, e <span class="math inline">\(m\)</span> o tamanho da tabela hash. A família <span class="math inline">\(\mathcal{H}\)</span> é o conjunto de funções <span class="math inline">\(h_{a,b}\)</span> dadas pela fórmula: <span class="math display">\[h_{a,b}(k) = ((ak + b) \bmod p) \bmod m\]</span></p>
<p>Onde <span class="math inline">\(a\)</span> e <span class="math inline">\(b\)</span> são parâmetros <strong>inteiros</strong> aleatórios escolhidos no início, com <span class="math inline">\(a\in[1, p-1]\)</span> e <span class="math inline">\(b\in[0, p-1]\)</span>.</p>
<p>Os parâmetros aleatórios ajudam a dispersar o valor da chave. Já a operação de módulo por um primo <span class="math inline">\(p\)</span> ajuda a garantir que a distribuição do resultado seja uniforme no intervalo <span class="math inline">\([0, p-1]\)</span>. Finalmente, o resultado final é mapeado para o índice da tabela hash, no intervalo <span class="math inline">\([0, m-1]\)</span>.</p>
<p>Por exemplo, digamos uma tabela com <span class="math inline">\(m=10\)</span> slots e escolhamos <span class="math inline">\(p=103\)</span>.</p>
<ul>
<li>Sorteamos <span class="math inline">\(a\)</span> entre <span class="math inline">\(1\)</span> e <span class="math inline">\(p-1\)</span>, ou seja, no intervalo <span class="math inline">\([1, 102]\)</span></li>
<li>Sorteamos <span class="math inline">\(b\)</span> entre <span class="math inline">\(0\)</span> e <span class="math inline">\(p-1\)</span>, ou seja, no intervalo <span class="math inline">\([0, 102]\)</span></li>
</ul>
<p>Digamos que <span class="math inline">\(a=5\)</span> e <span class="math inline">\(b=13\)</span>, então nossa função sorteada da família universal será: <span class="math display">\[h_{5,13}(k)=((5k+13)\bmod103)\bmod 10\]</span></p>
<p>Vamos calcular alguns valores de hash para fixação.</p>
<ul>
<li><span class="math inline">\(h(4)\,\,\,=\,\,\,((5\cdot4+13)\bmod103)\bmod 10=\,\,\,(33\bmod103)\bmod 10=33 \bmod 10=3\)</span></li>
<li><span class="math inline">\(h(17)=((5\cdot17+13)\bmod103)\bmod 10=\,\,\,(98\bmod103)\bmod 10= 98\bmod 10=8\)</span></li>
<li><span class="math inline">\(h(25)=((5\cdot25+13)\bmod103)\bmod 10=(138\bmod103)\bmod 10=35\bmod 10=5\)</span></li>
<li><span class="math inline">\(h(32)=((5\cdot32+13)\bmod103)\bmod 10=(173\bmod103)\bmod 10=70\bmod 10=0\)</span></li>
</ul>
<p>Mesmo com os melhores métodos, é impossível evitar colisões. Quando acontece, devemos tratá-la de modo que o desempenho da busca não seja muito afetado. No entanto, antes de estudarmos os tratamentos de colições, iremos abordar as estratégias para mapeamento de chaves em inteiros.</p>
</section>
</section>
<section id="estratégias-para-mapeamento" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="estratégias-para-mapeamento">Estratégias para Mapeamento</h2>
<p>Quando falamos em mapeamento de chaves em inteiros, estamos nos referindo a um pré-processamento que transforma uma chave (como uma string ou um número muito grande) em um inteiro mais adequado para ser usado por uma função de hash.</p>
<p>Embora seja possível criar suas próprias estratégias, apresentamos a seguir alguns métodos clássicos encontrados na literatura.</p>
<section id="chaves-do-tipo-string" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="chaves-do-tipo-string">🔠 Chaves do tipo <em>string</em></h3>
<p>Os métodos clássicos para tratar strings usam o fato de cada letra ter um inteiro correspondente na tabela ASCII.</p>
<section id="soma" class="level4">
<h4 class="anchored" data-anchor-id="soma">Soma</h4>
<p>Muitas vezes, as chaves que estamos trabalhando são <em>strings</em>. Uma forma simples de convertê-las em inteiros é somar os valores ASCII de cada caractere: <span class="math display">\[k=\sum_{i=0}^{n-1}s[i]=s[0]+s[1]+s[2]+\cdots+s[n-1]\]</span></p>
<p>onde <span class="math inline">\(n\)</span> é o tamanho da palavra.</p>
<p>Por exemplo, a palavra “PAI” (P = 80, A = 65 e I = 73): <span class="math display">\[k=\sum_{i=0}^{3-1}s[i]=\sum_{i=0}^{2}s[i]=s[0]+s[1]+s[2]=80+65+73=218\]</span></p>
<p>Esse método é simples, mas apresenta má distribuição, ou seja, palavras com as mesmas letras em ordem diferente geram o mesmo valor.</p>
</section>
<section id="multiplicação-polinomial" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="multiplicação-polinomial">Multiplicação Polinomial</h4>
<p>Um método mais robusto é o da <strong>multiplicação polinomial</strong>. Aqui, tratamos a <em>string</em> como um número em uma base <span class="math inline">\(\beta\)</span> (β (geralmente um número primo pequeno): <span class="math display">\[k=s[0]\cdot\beta^{n-1}+s[1]\cdot\beta^{n-2}+\cdots+s[n-1]\cdot\beta^{0}\]</span></p>
<p>Por exemplo, a palavra “PAI” (P = 80, A = 65 e I = 73) e <span class="math inline">\(\beta=13\)</span>: <span class="math display">\[k=s[0]\cdot 13^{3-1}+s[1]\cdot 13^{3-2}+\cdots+s[2]\cdot 13^{0}=80\cdot13^2+65\cdot13^1+73\cdot13^0=14438\]</span></p>

<div class="no-row-height column-margin column-container"><div class="">
<p><strong><span class="text-warning">Se liga!</span></strong> A multiplicação por um número primo ajuda a espalhar os valores de forma mais uniforme do que se usássemos um número composto.</p>
</div></div><p>Essa técnica é superior à soma simples, pois considera a ordem dos caracteres. Para palavras como “cama” e “maca”, a soma simples irá retornar os mesmos valores, enquanto que a multiplicação polinomial não.</p>
<p>Exemplo simples:</p>
<ul>
<li><span class="math inline">\(BA : 66\cdot13^1 + 65\cdot13^0 = 923\)</span>.</li>
<li><span class="math inline">\(AB : 65\cdot13^1 + 66\cdot13^0 = 911\)</span>.</li>
</ul>
<p>Dessa forma, “BA” e “AB” produzem resultados distintos, evitando colisões triviais.</p>
</section>
</section>
<section id="chaves-do-tipo-int-grandes" class="level3">
<h3 class="anchored" data-anchor-id="chaves-do-tipo-int-grandes">🔢 Chaves do tipo <em>int</em> grandes</h3>
<p>Quando lidamos com inteiros muito grandes, precisamos reduzi-los para evitar estouro de capacidade (overflow) ou para encaixá-los em um intervalo menor. A seguir, apresentamos três métodos comuns: dobramento (folding), XOR e quadrado central (mid-square).</p>
<section id="dobramento-folding" class="level4">
<h4 class="anchored" data-anchor-id="dobramento-folding">Dobramento (Folding)</h4>
<p>Consiste em dividir a chave em partes menores e, em seguida, somá-las ou aplicar XOR entre elas para gerar um número reduzido. Por exemplo, suponha <span class="math inline">\(k = 83.529.170\)</span>, vamos dividir a chave assim:</p>
<ul>
<li><span class="math inline">\(k_1 = 835\)</span></li>
<li><span class="math inline">\(k_2 = 291\)</span></li>
<li><span class="math inline">\(k_3 = 70\)</span></li>
</ul>
<p>O dobramento por soma resulta em <span class="math inline">\(k_1+k_2+k_3=835+291+70=1196\)</span>.</p>
<p>No dobramento por XOR, as partes são combinadas usando a operação lógica OU exclusivo (XOR), muito comum em funções de hash criptográficas. Primeiro, convertemos as partes para binário (aqui, usando 10 bits para simplificar):</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Parte</th>
<th>Decimal</th>
<th>Binário (10 bits)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(k_1\)</span></td>
<td>835</td>
<td>1101000011</td>
</tr>
<tr class="even">
<td><span class="math inline">\(k_2\)</span></td>
<td>291</td>
<td>0100100011</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(k_3\)</span></td>
<td>70</td>
<td>0001000110</td>
</tr>
</tbody>
</table>
<p>Realizamos a operação XOR bit a bit entre as partes. <span class="math display">\[k_1 \oplus k_2 \oplus k_3\]</span><span class="math display">\[\begin{array}{r l l} &amp; 1101000011 &amp; (k_1) \\ \oplus &amp; 0100100011 &amp; (k_2) \\ \hline &amp; 1001100000 &amp; (k_1 \oplus k_2) \\ \oplus &amp; 0001000110 &amp; (k_3) \\ \hline &amp; \mathbf{1000100110} &amp; (\text{Resultado}) \end{array}\]</span></p>
<p>Transformando 1000100110 de volta para decimal: <span class="math display">\[1000100110_2=512+64+8+4+2=590\]</span></p>
<p>O método XOR tende a preservar melhor as características de todas as partes da chave, ainda que seja um pouco mais complexo de implementar do que a soma simples.</p>
</section>
<section id="mid-square" class="level4">
<h4 class="anchored" data-anchor-id="mid-square">Mid-Square</h4>
<p>O método do quadrado central é uma técnica clássica de extração. A chave é elevada ao quadrado, e então o hash é formado pelos dígitos centrais do resultado. A quantidade de dígitos extraídos é indicada por <span class="math inline">\(d\)</span>.</p>
<p>Apesar de ser simples, ele pode gerar um código hash razoavelmente bem distribuído. Como exemplo, considere uma <span class="math inline">\(k=931\)</span> e <span class="math inline">\(d=3\)</span>. <span class="math display">\[k^2=931^2=866761\]</span> Assim, podemos selecionar <span class="math inline">\(676\)</span>, ou até <span class="math inline">\(667\)</span>.</p>
<p>Esses métodos apresentados podem ser combinados ou até mesmo utilizados como substitutos de uma função hash. Em sistemas mais complexos, essas abordagens costumam ser empregadas como etapas auxiliares dentro de funções de hash mais sofisticadas.</p>
</section>
</section>
</section>
<section id="tratamento-de-colisões" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="tratamento-de-colisões">Tratamento de Colisões</h2>
<p>Sabemos que uma colisão ocorre quando a função hash produz o mesmo valor para duas ou mais chaves distintas. <span class="math display">\[h(k1) = h(k2)\]</span></p>
<p>Uma colisão é praticamente inevitável, por isso devemos tratá-la. As principais abordagens são endereçamento aberto e encadeamento separado.</p>
<ul>
<li><strong>Endereçamento aberto</strong>: percorrer a tabela em busca de um local não ocupado.</li>
<li><strong>Encadeamento separado</strong>: uso de listas ligadas para armazenar as colisões.</li>
</ul>

<div class="no-row-height column-margin column-container"><div class="">
<p><strong><span class="text-warning">Se liga!</span></strong> Endereçamento aberto: procura um endereço aberto, um slot vazio. Encadeamento separado: usa listas encadeadas separadas, uma para cada slot.</p>
</div></div><section id="endereçamento-aberto" class="level3">
<h3 class="anchored" data-anchor-id="endereçamento-aberto">Endereçamento aberto</h3>
<p>A técnica de endereçamento aberto tenta resolver o problema de colisão buscando um outro lugar vazio para armazenar a chave que colidiu. As maneiras principais de sondar um espaço vazio são:</p>
<ul>
<li>Sondagem linear;</li>
<li>Sondagem quadrática;</li>
<li>Duplo hash</li>
</ul>
<section id="sondagem-linear" class="level4">
<h4 class="anchored" data-anchor-id="sondagem-linear">Sondagem linear</h4>
<p>A sondagem linear procura pela próxima posição vazia do vetor. A função de hash possui uma nova variável iterativa que permitirá a procura por esse lugar vazio: <span class="math display">\[h(k,i) = (h(k)+i)\bmod n\]</span> onde <span class="math inline">\(i=0,1,2,3,\ldots\)</span></p>
<p>Sempre que ocorre um colisão, esta variável (<span class="math inline">\(i\)</span>) é incrementada em uma unidade.</p>
<p>Por exemplo, considere o vetor abaixo:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 7%">
<col style="width: 9%">
<col style="width: 10%">
<col style="width: 10%">
<col style="width: 7%">
<col style="width: 7%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 7%">
</colgroup>
<thead>
<tr class="header">
<th>slot</th>
<th style="text-align: center;">0</th>
<th style="text-align: center;">1</th>
<th style="text-align: center;">2</th>
<th style="text-align: center;">3</th>
<th style="text-align: center;">4</th>
<th style="text-align: center;">5</th>
<th style="text-align: center;">6</th>
<th style="text-align: center;">7</th>
<th style="text-align: center;">8</th>
<th style="text-align: center;">9</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>chave</td>
<td style="text-align: center;">❌</td>
<td style="text-align: center;">21</td>
<td style="text-align: center;">42</td>
<td style="text-align: center;">63</td>
<td style="text-align: center;">❌</td>
<td style="text-align: center;">❌</td>
<td style="text-align: center;">❌</td>
<td style="text-align: center;">❌</td>
<td style="text-align: center;">❌</td>
<td style="text-align: center;">69</td>
</tr>
</tbody>
</table>
<p>E a função de hash <span class="math inline">\(h(k)=k\bmod 10\)</span>.</p>
<p>Vamos adicionar a chave 81:</p>
<ul>
<li><span class="math inline">\(h(81,0) = (h(81) + 0) \bmod 10 = (1+0) \bmod 10 = 1\)</span>, colisão com 21</li>
<li><span class="math inline">\(h(81,1) = (h(81) + 1) \bmod 10 = (1+1) \bmod 10 = 2\)</span>, colisão com 42</li>
<li><span class="math inline">\(h(81,2) = (h(81) + 2) \bmod 10 = (1+2) \bmod 10 = 3\)</span>, colisão com 63</li>
<li><span class="math inline">\(h(81,3) = (h(81) + 3) \bmod 10 = (1+3) \bmod 10 = 4\)</span></li>
</ul>
<p>Como a posição 4 está vazia, a chave 81 será alocada lá.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 7%">
<col style="width: 9%">
<col style="width: 10%">
<col style="width: 10%">
<col style="width: 7%">
<col style="width: 7%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 7%">
</colgroup>
<thead>
<tr class="header">
<th>slot</th>
<th style="text-align: center;">0</th>
<th style="text-align: center;">1</th>
<th style="text-align: center;">2</th>
<th style="text-align: center;">3</th>
<th style="text-align: center;">4</th>
<th style="text-align: center;">5</th>
<th style="text-align: center;">6</th>
<th style="text-align: center;">7</th>
<th style="text-align: center;">8</th>
<th style="text-align: center;">9</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>chave</td>
<td style="text-align: center;">❌</td>
<td style="text-align: center;">21</td>
<td style="text-align: center;">42</td>
<td style="text-align: center;">63</td>
<td style="text-align: center;">81</td>
<td style="text-align: center;">❌</td>
<td style="text-align: center;">❌</td>
<td style="text-align: center;">❌</td>
<td style="text-align: center;">❌</td>
<td style="text-align: center;">69</td>
</tr>
</tbody>
</table>
</section>
<section id="sondagem-quadrática" class="level4">
<h4 class="anchored" data-anchor-id="sondagem-quadrática">Sondagem quadrática</h4>
<p>A sondagem quadrática procura pela próxima posição vazia usando uma função quadrática. <span class="math display">\[h(k,i) = (h(k)+c_1i+c_2i^2)\bmod n\]</span> onde <span class="math inline">\(c_1,c_2\)</span> são constantes e <span class="math inline">\(i=0,1,2,3,\ldots\)</span></p>
<p>Considere o exemplo anterior com sondagem quadrática (<span class="math inline">\(c_1=0\)</span> e <span class="math inline">\(c_2=1\)</span>).</p>
<ul>
<li><span class="math inline">\(h(81,0) = (h(81) + 0^2) \bmod 10 = (1+0) \bmod 10 = 1\)</span>, colisão com 21</li>
<li><span class="math inline">\(h(81,1) = (h(81) + 1^2) \bmod 10 = (1+1) \bmod 10 = 2\)</span>, colisão com 42</li>
<li><span class="math inline">\(h(81,2) = (h(81) + 2^2) \bmod 10 = (1+4) \bmod 10 = 5\)</span></li>
</ul>
<p>Como a posição 5 está vazia, a chave 81 será alocada lá.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 7%">
<col style="width: 9%">
<col style="width: 10%">
<col style="width: 10%">
<col style="width: 7%">
<col style="width: 7%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 7%">
</colgroup>
<thead>
<tr class="header">
<th>slot</th>
<th style="text-align: center;">0</th>
<th style="text-align: center;">1</th>
<th style="text-align: center;">2</th>
<th style="text-align: center;">3</th>
<th style="text-align: center;">4</th>
<th style="text-align: center;">5</th>
<th style="text-align: center;">6</th>
<th style="text-align: center;">7</th>
<th style="text-align: center;">8</th>
<th style="text-align: center;">9</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>chave</td>
<td style="text-align: center;">❌</td>
<td style="text-align: center;">21</td>
<td style="text-align: center;">42</td>
<td style="text-align: center;">63</td>
<td style="text-align: center;">❌</td>
<td style="text-align: center;">81</td>
<td style="text-align: center;">❌</td>
<td style="text-align: center;">❌</td>
<td style="text-align: center;">❌</td>
<td style="text-align: center;">69</td>
</tr>
</tbody>
</table>
</section>
<section id="duplo-hash" class="level4">
<h4 class="anchored" data-anchor-id="duplo-hash">Duplo hash</h4>
<p>Como o nome sugere, o tratamento de colisão usa duas funções hash (<span class="math inline">\(h_1\)</span> e <span class="math inline">\(h_2\)</span>). <span class="math display">\[h(k,i) = (h_1(k) + i\cdot h_2(k)) \bmod n\]</span> onde <span class="math inline">\(i=0,1,2,3,\ldots\)</span></p>
<p>Por exemplo, suponha <span class="math inline">\(h_1(k) = k \bmod 10\)</span> e <span class="math inline">\(h_2(k) = 5 − (k \bmod 5)\)</span>.</p>
<p>No exemplo anterior teremos:</p>
<ul>
<li><span class="math inline">\(h(81,0) = (h_1(81) + 0 \cdot h_2(81)) \bmod 10 = (1+0) \bmod 10 = 1\)</span>, colisão com 21</li>
<li><span class="math inline">\(h(81,1) = (h_1(81) + 1 \cdot h_2(81)) \bmod 10 = (1 + 4) \bmod 10 = 5\)</span></li>
</ul>
<p>Ou seja,</p>
<table class="caption-top table">
<colgroup>
<col style="width: 7%">
<col style="width: 9%">
<col style="width: 10%">
<col style="width: 10%">
<col style="width: 7%">
<col style="width: 7%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 7%">
</colgroup>
<thead>
<tr class="header">
<th>slot</th>
<th style="text-align: center;">0</th>
<th style="text-align: center;">1</th>
<th style="text-align: center;">2</th>
<th style="text-align: center;">3</th>
<th style="text-align: center;">4</th>
<th style="text-align: center;">5</th>
<th style="text-align: center;">6</th>
<th style="text-align: center;">7</th>
<th style="text-align: center;">8</th>
<th style="text-align: center;">9</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>chave</td>
<td style="text-align: center;">❌</td>
<td style="text-align: center;">21</td>
<td style="text-align: center;">42</td>
<td style="text-align: center;">63</td>
<td style="text-align: center;">❌</td>
<td style="text-align: center;">81</td>
<td style="text-align: center;">❌</td>
<td style="text-align: center;">❌</td>
<td style="text-align: center;">❌</td>
<td style="text-align: center;">69</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="encadeamento-separado" class="level3">
<h3 class="anchored" data-anchor-id="encadeamento-separado">Encadeamento separado</h3>
<p>A técnica de encadeamento separado é bastante simples. Ao invés de tratar a colisão procurando um lugar vazio, iremos colocar as colisões em uma lista encadeada. Logo, não teremos um vetor de chaves, mas sim um vetor de ponteiros que apontam para listas encadeadas separadamente.</p>
<p>No exemplo anterior, quando houve a colisão da chave 81 com 21, a posição 1 iria apontar para uma lista ligada com dois componentes.</p>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">flowchart TD
 subgraph s1["Array"]
        A0["❌"]
        A1["prt_1"]
        A2["prt_2"]
        A3["prt_3"]
        A4["❌"]
        A5["❌"]
        A6["❌"]
        A7["❌"]
        A8["❌"]
        A9["prt_9"]
  end
    A1 -.-&gt; B1["21"]
    B1 --&gt; B2["81"]
    A2 -.-&gt; B3["42"]
    A3 -.-&gt; B4["63"]
    A9 -.-&gt; B5["69"]
    B2 --&gt; n1["Filled Circle"]
    B3 --&gt; n2["Filled Circle"]
    B4 --&gt; n3["Filled Circle"]
    B5 --&gt; n4["Filled Circle"]

    n1@{ shape: f-circ}
    n2@{ shape: f-circ}
    n3@{ shape: f-circ}
    n4@{ shape: f-circ}
    style A1 fill:#fff
    style A2 fill:#fff
    style A3 fill:#fff
    style A9 fill:#fff
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
</section>
</section>
<section id="tabela-de-dispersão-dinâmica" class="level2">
<h2 class="anchored" data-anchor-id="tabela-de-dispersão-dinâmica">Tabela de Dispersão Dinâmica</h2>
<p>Imagine que você possui um pequeno móvel com quatro compartimentos:</p>
<ul>
<li>No compartimento 1, você guarda um relógio <strong>Ferrari</strong>.</li>
<li>No compartimento 2, um relógio <strong>Casio</strong>.</li>
<li>No compartimento 3, um relógio <strong>Xing-ling</strong>.</li>
</ul>
<p>Com o tempo, você percebe que o móvel está ficando cheio e decide comprar um novo móvel com o dobro do tamanho, para ter mais espaço e organização.</p>
<p>No novo móvel, os relógios podem ficar em posições diferentes, por exemplo, o Ferrari agora pode ser guardado no compartimento 6. Além disso, você adquire um novo relógio <strong>Rolex</strong> e o coloca no compartimento 5.</p>
<p>Mais tarde, você decide presentear seu melhor amigo com o relógio <strong>Xing-ling</strong> e vender o <strong>Casio</strong>. Para completar, um dos relógios acaba sendo roubado. Agora, dos oito compartimentos, apenas um está ocupado. Um grande desperdício de espaço.</p>
<p>Diante disso, você decide trocar novamente de móvel, voltando a um modelo menor, com quatro compartimentos, mais adequado à sua nova coleção.</p>
<p>Esse comportamento de aumentar ou diminuir o número de compartimentos conforme a quantidade de itens é exatamente o que ocorre em uma tabela hash dinâmica.</p>
<p>Em resumo, ela funciona como um “guarda-roupa inteligente” que se adapta automaticamente:</p>
<ul>
<li>Expande (aumenta) quando está ficando cheia, evitando que as “gavetas” fiquem apertadas (muitas colisões).</li>
<li>Contrai (diminui) quando está quase vazia, economizando espaço e memória.</li>
</ul>
<p>Essa capacidade de ajustar dinamicamente o tamanho permite que a tabela hash mantenha alto desempenho e uso eficiente de memória, independentemente do número de elementos armazenados.</p>
<section id="fator-de-carga" class="level3">
<h3 class="anchored" data-anchor-id="fator-de-carga">Fator de Carga</h3>
<p>O fator de carga (load factor) determina quando uma tabela hash deve ser expandida ou contraída. Ele é definido como a razão entre o número de elementos armazenados e o número total de buckets (ou posições disponíveis na tabela): <span class="math display">\[\lambda = \frac{n}{m}\]</span> onde <span class="math inline">\(n\)</span> é o número de itens atualmente armazenados e <span class="math inline">\(m\)</span> o tamanho da tabela.</p>
<p>O desempenho ideal de uma tabela hash depende de duas condições principais:</p>
<ul>
<li>uma função hash eficiente, que distribua os elementos de forma uniforme;</li>
<li>um fator de carga baixo, que mantenha o número de colisões sob controle.</li>
</ul>
<p>Se o fator de carga <span class="math inline">\(\lambda\)</span> for muito alto, o número de colisões tende a crescer, e as operações de busca, inserção e remoção podem degradar de O(1) para O(n). Por outro lado, se <span class="math inline">\(\lambda\)</span> for muito baixo, haverá desperdício de espaço, pois a tabela ficará com muitos buckets vazios.</p>
<p>O coração de uma tabela hash dinâmica é justamente o processo de redimensionamento, que ajusta o tamanho da tabela conforme o fator de carga ultrapassa (ou cai abaixo de) determinados limites predefinidos. Por exemplo,</p>
<ul>
<li>expansão: quando <span class="math inline">\(\lambda&gt;0.7\)</span> ou <span class="math inline">\(\lambda&gt;0.75\)</span>;</li>
<li>contração: quando <span class="math inline">\(\lambda&lt;0.25\)</span>.</li>
</ul>
<p>O processo de redimensionamento normalmente envolve três etapas principais:</p>
<ul>
<li><strong>Criação de uma nova tabela</strong>: Uma nova tabela é alocada, geralmente com o dobro (em caso de expansão) ou metade (em caso de contração) do tamanho atual.</li>
<li><strong>Re-hashing dos elementos</strong>: Todos os elementos da tabela antiga são reprocessados por uma nova função hash e inseridos na nova tabela, agora com índices recalculados conforme o novo tamanho.</li>
<li><strong>Substituição</strong>: A tabela antiga é descartada, e a nova tabela passa a ser usada nas próximas operações de inserção, busca e remoção.</li>
</ul>
<p>Finalmente, podemos citar como vantagens e desvantagens da tabela hash dinâmica:</p>
<div class="tabset-margin-container"></div><div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-1-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-1-1" role="tab" aria-controls="tabset-1-1" aria-selected="true" href="">Vantagens</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-1-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-1-2" role="tab" aria-controls="tabset-1-2" aria-selected="false" href="">Desvantagens</a></li></ul>
<div class="tab-content">
<div id="tabset-1-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-1-1-tab">
<ul>
<li><strong>Otimização do espaço</strong>: A tabela se ajusta à quantidade de dados, evitando desperdício de memória quando há poucos itens e garantindo espaço suficiente para muitos itens.</li>
<li><strong>Desempenho consistente</strong>: Ajuda a manter o fator de carga em níveis ótimos, garantindo que as operações de O(1) sejam mantidas na média.</li>
<li><strong>Facilidade de uso</strong>: O desenvolvedor não precisa se preocupar em prever o tamanho da tabela, simplificando o desenvolvimento.</li>
</ul>
</div>
<div id="tabset-1-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-1-2-tab">
<ul>
<li><strong>Custo do redimensionamento</strong>: A operação de redimensionamento pode ser custosa, pois envolve a criação de uma nova tabela e o re-hashing de todos os elementos. Isso pode levar a picos de latência inesperados.</li>
<li><strong>Complexidade de implementação</strong>: É mais complexa de implementar do que uma tabela hash estática.</li>
<li><strong>Cache ineficiente durante redimensionamento</strong>: Durante o re-hashing, os dados podem se espalhar por novas posições de memória, o que pode impactar o desempenho do cache da CPU temporariamente.</li>
</ul>
</div>
</div>
</div>


</section>
</section>

<a onclick="window.scrollTo(0, 0); return false;" role="button" id="quarto-back-to-top"><i class="bi bi-arrow-up"></i> De volta ao topo</a></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copiada");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copiada");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/brunofx-ufersa\.github\.io\/reacomp\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
 Licença
  </li>  
    <li class="nav-item">
    <a class="nav-link" href="http://creativecommons.org/licenses/by-sa/4.0/">
<p>CC BY-SA 4.0</p>
</a>
  </li>  
    <li class="nav-item">
 — Portal construído com
  </li>  
    <li class="nav-item">
    <a class="nav-link" href="https://quarto.org/">
<p>Quarto</p>
</a>
  </li>  
</ul>
    </div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>