---
title: "츼rvores Bin치rias"
lang: pt
toc-title: Conte칰do
toc: false
sidebar: false
format:
  html:
    reference-location: margin
    css: ../styles/academic.css
filters: 
    - quizdown
---

A 치rvore bin치ria 칠 uma 치rvore onde os n칩s possuem no m치ximo dois filhos. Portanto, um n칩 qualquer pode possuir 0, 1 ou 2 filhos.

Exemplos

```{mermaid}
flowchart LR
    subgraph s1[" "]
    A(("A")) 
    B(("B"))
	C(("C"))
	D(("D"))
	E(("E"))
	F(("F"))
	G(("G"))
    end

    subgraph s2[" "]
	A1(("1"))
    B1(("2"))
	C1(("3"))
	D1(("4"))
	E1(("5"))
	F1(("6"))
	I1((" "))
    end

    subgraph s3[" "]
	A2((游뗻)) 
    B2((游뗷))
	C2((游))
	D2((游뱎))
	I2((" "))
    end

	A --- B
	A --- C
	B --- D
	B --- E
	C --- F
	C --- G
	A1 --- B1
	A1 --- C1
	B1 --- D1
	B1 --- E1
	C1 --- F1
	C1 --- I1

	A2 --- B2   
	A2 --- C2
	B2 --- D2
	B2 --- I2

    s1 -.- s2
    s2 -.- s3
A:::WT
B:::WT
C:::WT
D:::WT
E:::WT
F:::WT
G:::WT
A1:::WT
B1:::WT
C1:::WT
D1:::WT
E1:::WT
F1:::WT
A2:::WT
B2:::WT
C2:::WT
D2:::WT
style s1 stroke:none,fill:transparent
style s2 stroke:none,fill:transparent
style s3 stroke:none,fill:transparent
style I1 stroke:none,fill:transparent
style I2 stroke:none,fill:transparent
linkStyle 11 stroke:none,fill:none    
linkStyle 15 stroke:none,fill:none    

classDef WT fill:#FFFFFF
```	


## Propriedades

- Um 치rvore bin치ria de altura $h$ tem no m치ximo $2^{h+1}-1$ n칩s
- Um 치rvore bin치ria com $n$ n칩s tem uma altura m칤nima de $\lceil \log_2(n+1)\rceil-1$
- Um 치rvore bin치ria com $n$ n칩s tem no m치ximo $\lceil n/2\rceil$ n칩s terminais

Exemplo

1. Uma 치rvore de altura $4$ possuir치, no m치ximo, $2^{4+1}-1=2^{5}-1=32-1=31$ n칩s.
2. Se uma 치rvore bin치ria possui $7$ n칩s, ent칚o sua altura m칤nima ser치 de
 $$\lceil \log_2(7+1)\rceil-1=\lceil \log_28\rceil-1=\lceil 3\rceil-1=2$$

> Al칠m disso, tal 치rvore possuir치 no m치ximo $\lceil 7/2\rceil$  n칩s terminais, ou seja, $4$ folhas.

## Classifica칞칚o

Uma 치rvore bin치ria pode ser classificada em

- Cheia,
- Completa,
- Perfeita ou
- Degenerada,

dependendo do arranjo de seus n칩s.

### 츼rvore Bin치ria Cheia

Cada n칩 possui zero ou dois filhos (nunca exatamente um). Na 치rvore abaixo, nenhum n칩 possui somente um filho. Portanto, ela 칠 cheia.

```{mermaid}
flowchart TB
	A(("A")) --- B(("B"))
	A --- C(("C"))
	C --- D(("D"))
	C --- E(("E"))
	D --- F(("F"))
	D --- G(("G"))


A:::WT
B:::WT
C:::WT
D:::WT
E:::WT
F:::WT
G:::WT

classDef WT fill:#FFFFFF
```	

- nenhum filho: B, E, F e G
- um filho: -
- dois filhos: A, C e D 

### 츼rvore Bin치ria Completa

Neste caso, todos os n칤veis, acima das folhas do 칰ltimo n칤vel, est칚o preenchidos integralmente.

```{mermaid}
flowchart TB
	A(("A")) --- B(("B"))
	A --- C(("C"))
	B --- D(("D"))
	B --- E(("E"))
	C --- F(("F"))
	C --- G(("G"))
	D --- H(("H"))
	D --- I(("I"))
    E --- J(("J"))
	E --- I1((" "))
    G --- K(("K"))
	G --- L(("L"))


A:::WT
B:::WT
C:::WT
D:::WT
E:::WT
F:::WT
G:::WT
H:::WT
I:::WT
J:::WT
K:::WT
L:::WT

classDef WT fill:#FFFFFF
style I1 stroke:none,fill:transparent
linkStyle 9 stroke:none,fill:none
```	


A 치rvore acima possui 4 n칤veis, onde os n칤veis 0, 1 e 2 est칚o completos.


- n칤vel 0: A
- n칤vel 1: B e C
- n칤vel 2: D, E, F e G

::: {.column-margin}
**[Se liga!]{.text-warning}**
Em uma 치rvore bin치ria, para um n칤vel $n$ estar completo 칠 necess치rio que ele possua $2^n$ n칩s
:::


### 츼rvore Bin치ria Perfeita

칄 uma 치rvore bin치ria em todos os n칤veis est칚o completamente preenchidos.

```{mermaid}
flowchart TB
	A(("A")) --- B(("B"))
	A --- C(("C"))
	B --- D(("D"))
	B --- E(("E"))
	C --- F(("F"))
	C --- G(("G"))
	D --- H(("H"))
	D --- I(("I"))
    E --- J(("J"))
	E --- K(("K"))
    F --- L(("L"))
	F --- M(("M"))
    G --- N(("N"))
	G --- O(("O"))


A:::WT
B:::WT
C:::WT
D:::WT
E:::WT
F:::WT
G:::WT
H:::WT
I:::WT
J:::WT
K:::WT
L:::WT
M:::WT
N:::WT
O:::WT

classDef WT fill:#FFFFFF
```	


Todos os n칩s internos t칡m dois filhos e todas as folhas est칚o no mesmo n칤vel.

### 츼rvore Degenerada


Uma 치rvore degenerada que 칠 aquela em que cada n칩 tem no m치ximo um filho. Isso faz com que a 치rvore se assemelhe a uma lista encadeada.

```{mermaid}
flowchart LR
 subgraph s1[" "]
	A(("A"))
    I1((" "))
    B(("B"))
	I2((" "))
    C(("C"))
	I3((" "))
    D(("D"))
	I4((" "))
    E(("E"))
end

 subgraph s2[" "]
	A2(("A"))
    I9((" "))
    B2(("B"))
	I10((" "))
    C2(("C"))
	I11((" "))
    D2(("D"))
	I12((" "))
    E2(("E"))
end

 subgraph s3[" "]
	A1(("A"))
    I5((" "))
    B1(("B"))
	I6((" "))
    C1(("C"))
	I7((" "))
    D1(("D"))
	I8((" "))
    E1(("E"))
end
	A ~~~ I1
    A --- B
	B ~~~ I2
    B --- C
	C ~~~ I3
    C --- D
	D ~~~ I4
    D --- E

	A1 --- B1
	A1 ~~~ I5
    B1 --- C1
	B1 ~~~ I6
    C1 --- D1
	C1 ~~~ I7
    D1 --- E1
    D1 ~~~ I8
    
	A2 --- B2
    A2 ~~~ I9
	B2 ~~~ I10
    B2 --- C2
	C2 --- D2
	C2 ~~~ I11
    D2 ~~~ I12
    D2 --- E2

    s1 ~~~ s2
    s2 ~~~ s3

A:::WT
B:::WT
C:::WT
D:::WT
E:::WT
A2:::WT
B2:::WT
C2:::WT
D2:::WT
E2:::WT

A1:::WT
B1:::WT
C1:::WT
D1:::WT
E1:::WT

classDef WT fill:#FFFFFF
style I1 stroke:none,fill:transparent
style I2 stroke:none,fill:transparent
style I3 stroke:none,fill:transparent
style I4 stroke:none,fill:transparent
style I5 stroke:none,fill:transparent
style I6 stroke:none,fill:transparent
style I7 stroke:none,fill:transparent
style I8 stroke:none,fill:transparent
style I9 stroke:none,fill:transparent
style I10 stroke:none,fill:transparent
style I11 stroke:none,fill:transparent
style I12 stroke:none,fill:transparent
style s1 stroke:none,fill:transparent
style s2 stroke:none,fill:transparent
style s3 stroke:none,fill:transparent
```	

## Percursos

Como podemos visitar todos os n칩s de uma 치rvore, sem exce칞칚o, somente uma vez? Isso pode ser realizado de v치rias maneiras.

Um percurso, ou travessia, diz respeito ao modo de como percorremos uma 치rvore. Percorrer uma 치rvore bin치ria envolve visitar todos os seus n칩s em uma ordem espec칤fica para realizar v치rias opera칞칫es, como pesquisar, classificar ou modificar a 치rvore.

As estrat칠gias de travessia s칚o amplamente classificadas em:

- Percurso em Largura
- Percurso em Profundidade

### Percurso em Largura

O percurso em largura visita os n칩s em cada n칤vel, da esquerda para a direita, antes de prosseguir para o pr칩ximo. Essa abordagem 칠 ideal quando todos os n칩s em um n칤vel precisam ser processados antes de passar para o pr칩ximo.

Exemplo
```{mermaid}
flowchart TB
	A(("A")) --- B(("B"))
	A --- C(("C"))
	B --- D(("D"))
	B --- E(("E"))

A:::WT
B:::WT
C:::WT
D:::WT
E:::WT

classDef WT fill:#FFFFFF
```	

Um percurso em largura resultar치 na sequ칡ncia A, B, C, D e E.

- No n칤vel 0, passamos por A;
- No n칤vel 1, passamos por B e C;
- No n칤vel 2, passamos por D e E;


### Percurso em Profundidade

O percurso em profundidade explora o mais profundamente poss칤vel em cada ramo antes de retroceder. Esta categoria inclui os subtipos pr칠-ordem, ordeme p칩s-ordem.

Vamos usar a seguinte 치rvore para exemplificar tais percursos.

```{mermaid}
flowchart TB
	A(("A")) --- B(("B"))
	A --- C(("C"))

A:::WT
B:::WT
C:::WT

classDef WT fill:#FFFFFF
```	

#### Pr칠-ordem

Cada n칩 칠 processado antes de seus filhos. Segue a seguinte ordem de visita:

- raiz 
- sub치rvore esquerda
- sub치rvore direita

Processamos a raiz (A) e vamos para a sub치rvore esquerda. Processamos a nova raiz (B). N칚o temos sub치rvores de B, ent칚o voltamos e analisamos a sub치rvore direita de A. Processamos a nova raiz (C). N칚o temos sub치rvores de C, logo finalizamos.

Resultado: A, B, C

> O percurso em pr칠-ordem 칠 ideal para
>
> - C칩pia de Estrutura de Diret칩rios: Quando o sistema operacional precisa copiar uma pasta e seus subdiret칩rios, ele usa a l칩gica de pr칠-ordem. Ele primeiro cria a pasta principal (raiz) e depois entra nela para criar os arquivos e pastas internos.
> - Express칫es Matem치ticas (Nota칞칚o Polonesa): 칄 usado para converter express칫es em uma forma que computadores leiam facilmente sem precisar de par칡nteses. Por exemplo, a express칚o + 3 4 (onde o operador vem antes dos n칰meros).

#### Ordem

Processa a sub치rvore esquerda, o n칩 atual e, em seguida, a sub치rvore direita.

No nosso exemplo, vamos para a sub치rvore esquerda. Processamos a nova raiz (B). Voltamos para a raiz e processamos (A). Vamos para a sub치rvore direita. Processamos a nova raiz (C).

Resultado: B, A, C

> Este percurso 칠 amplamente utilizado em estruturas de dados que precisam manter alguma ordem.

#### P칩s-ordem

Acessa o n칩 atual ap칩s suas sub치rvores. Segue a seguinte ordem de visita: 

- sub치rvore esquerda
- sub치rvore direita
- raiz

No nosso exemplo, vamos para a sub치rvore esquerda. Processamos a nova raiz (B). Vamos para a sub치rvore direita. Processamos a nova raiz (C). Voltamos para a raiz e processamos (A).

Resultado: B, C, A

> A p칩s-ordem 칠 usada quando voc칡 precisa processar as folhas antes de chegar ao topo.
>
> - C치lculo de Tamanho de Pastas: Para saber o tamanho total de uma pasta no seu computador, o sistema primeiro soma o tamanho de todos os arquivos individuais (folhas) e subpastas para, por 칰ltimo, dar o resultado da pasta raiz.
> - Exclus칚o de 츼rvores: Para deletar uma 치rvore de forma segura na mem칩ria, voc칡 deve deletar os filhos primeiro. Se voc칡 deletar a raiz primeiro, perder치 o acesso (ponteiro) para os filhos, causando vazamento de mem칩ria.
> - Avalia칞칚o de Express칫es Matem치ticas: Compiladores usam isso para resolver contas. Para calcular (3 + 4) * 5, o computador primeiro resolve o 3 e o 4, depois o +, e s칩 ent칚o multiplica pelo 5.

Para fixa칞칚o, vamos considerar uma nova nova 치rvore: 

```{mermaid}
flowchart TB
	A(("A")) --- B(("B"))
	A --- C(("C"))
	B --- D(("D"))
	B --- E(("E"))
	C --- I1((" "))
	C --- F(("F"))

A:::WT
B:::WT
C:::WT
D:::WT
E:::WT
F:::WT

classDef WT fill:#FFFFFF
linkStyle 4 stroke:none,fill:none
style I1 stroke:none,fill:transparent
```	


- Largura: A, B, C, D, E, F
- Pr칠-ordem (N칩, Esquerda, Direta): A, B, D, E, C, F
- Ordem (Esquerda, N칩, Direta): D, B, E, A, C, F
- P칩s-ordem (Esquerda, Direta, N칩): D, E, B, F, C, A

::: {.column-margin}
**[Se liga!]{.text-warning}**
Os percursos em 치rvore podem ser usados para a serializa칞칚o, isto 칠, salvar uma 치rvore em um arquivo para carreg치-la exatamente igual depois.
:::


## Implementa칞칚o

Como se trata de uma estrutura din칙mica, usaremos ponteiros. 

Para criarmos uma 치rvore bin치ria em C, devemos criar uma nova estrutura. Tal estrutura deve conter o valor da chave e dois ponteiros para indicar os filhos do lado esquerdo e direito.

```c
typedef struct node {
    int data;
    struct node *left;
    struct node *right;
} Node;
```

Fun칞칚o para criar um n칩

```c
Node* create_node(int key) {
    Node* new_node = malloc(sizeof(Node));
    new_node->key = key;
    new_node->left = new_node->right = NULL;
     
    return new_node;
}
```

A fun칞칚o `create_node` recebe uma chave inteira e retorna um ponteiro para um objeto do tipo `Node`. Na segunda linha, estamos alocando mem칩ria para o novo n칩. Para isso, `sizeof(Node)` calcula o tamanho em _bytes_ necess치rio. Em seguida, preenchemos os campos do n칩 `new_node`: a chave e os filhos. No caso, o novo n칩 n칚o possui filhos, ent칚o recebem o valor `NULL`.

Na fun칞칚o principal (`main`), podemos fazer a inser칞칚o da seguinte forma:

```c
Node* root = create_node(10);

root->left = create_node(15);
root->right = create_node(5);
root->right->left = create_node(12);
root->right->right = create_node(18);
```

Esse c칩digo representa a seguinte 치rvore:

```{mermaid}
flowchart TB
	A(("10")) --- B(("15"))
	A --- C(("05"))
	C --- D(("12"))
	C --- E(("18"))

A:::WT
B:::WT
C:::WT
D:::WT
E:::WT

classDef WT fill:#FFFFFF
```	

Os percusos s칚o implementados recursivamente da seguinte forma:

```c
void pre_order(Node *root) {
    if (root != NULL) {
        printf("%d ", root->key);
        pre_order(root->left);
        pre_order(root->right);
    }
}

void in_order(Node *root) {
    if (root != NULL) {
        in_order(root->left);
        printf("%d ", root->key);
        in_order(root->right);
    }
}

void pos_order(Node *root) {
    if (root != NULL) {
        pos_order(root->left);
        pos_order(root->right);
        printf("%d ", root->key);
    }
}
```

Na pasta code, voc칡 pode encontrar a implementa칞칚o no arquivo arvorebinaria.c. Desse modo, voc칡 pode criar 치rvores diversas e verificar as travessias implementadas.

No nosso exemplo anterior, o programa deve gerar a sa칤da:

- Pre-Ordem:  10 15 5 12 18
- Ordem:      15 10 12 5 18
- Pos-Ordem:  15 12 18 5 10

## Revis칚o e Considera칞칫es

Nesta se칞칚o, estudamos a estrutura de dados 치rvore bin치ria.

- Definimos essa estrutura;
- Classificamos as 치rvores bin치rias (cheia, completa, perfeita e degenerada);
- Realizamos percursos em largura e profundidade;
- Abordamos as travessias em pr칠-ordem, ordem e p칩s-ordem.

Agora que estamos familiarizados com os conceitos fundamentais da estrutura de dados 치rvore, iremos estudar um tipo especial de 치rvore bin치ria chamada 치rvore bin치ria de busca.

Procure dominar os percursos realizando os exerc칤cios propostos deste cap칤tulo.


{{< include /_includes/progress-bar.qmd >}}
