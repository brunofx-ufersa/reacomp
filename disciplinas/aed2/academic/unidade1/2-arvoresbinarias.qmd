---
title: "√Årvores Bin√°rias"
lang: pt
toc-title: Conte√∫do
toc: false
sidebar: false
format:
  html:
    reference-location: margin
    css: ../styles/academic.css
filters: 
    - quizdown
---

A √°rvore bin√°ria √© uma √°rvore onde os n√≥s possuem no m√°ximo dois filhos. Portanto, um n√≥ qualquer pode possuir 0, 1 ou 2 filhos.

Exemplos

```{mermaid}
flowchart LR
    subgraph s1[" "]
    A(("A")) 
    B(("B"))
	C(("C"))
	D(("D"))
	E(("E"))
	F(("F"))
	G(("G"))
    end

    subgraph s2[" "]
	A1(("1"))
    B1(("2"))
	C1(("3"))
	D1(("4"))
	E1(("5"))
	F1(("6"))
	I1((" "))
    end

    subgraph s3[" "]
	A2((üôà)) 
    B2((üôÑ))
	C2((üëÄ))
	D2((ü§£))
	I2((" "))
    end

	A --- B
	A --- C
	B --- D
	B --- E
	C --- F
	C --- G
	A1 --- B1
	A1 --- C1
	B1 --- D1
	B1 --- E1
	C1 --- F1
	C1 --- I1

	A2 --- B2   
	A2 --- C2
	B2 --- D2
	B2 --- I2

    s1 -.- s2
    s2 -.- s3
A:::WT
B:::WT
C:::WT
D:::WT
E:::WT
F:::WT
G:::WT
A1:::WT
B1:::WT
C1:::WT
D1:::WT
E1:::WT
F1:::WT
A2:::WT
B2:::WT
C2:::WT
D2:::WT
style s1 stroke:none,fill:transparent
style s2 stroke:none,fill:transparent
style s3 stroke:none,fill:transparent
style I1 stroke:none,fill:transparent
style I2 stroke:none,fill:transparent
linkStyle 11 stroke:none,fill:none    
linkStyle 15 stroke:none,fill:none    

classDef WT fill:#FFFFFF
```	


## Propriedades

- Um √°rvore bin√°ria de altura $h$ tem no m√°ximo $2^{h+1}-1$ n√≥s
- Um √°rvore bin√°ria com $n$ n√≥s tem uma altura m√≠nima de $\lceil \log_2(n+1)\rceil-1$
- Um √°rvore bin√°ria com $n$ n√≥s tem no m√°ximo $\lceil n/2\rceil$ n√≥s terminais

Exemplo

1. Uma √°rvore de altura $4$ possuir√°, no m√°ximo, $2^{4+1}-1=2^{5}-1=32-1=31$ n√≥s.
2. Se uma √°rvore bin√°ria possui $7$ n√≥s, ent√£o sua altura m√≠nima ser√° de
 $$\lceil \log_2(7+1)\rceil-1=\lceil \log_28\rceil-1=\lceil 3\rceil-1=2$$

> Al√©m disso, tal √°rvore possuir√° no m√°ximo $\lceil 7/2\rceil$  n√≥s terminais, ou seja, $4$ folhas.

## Classifica√ß√£o

Uma √°rvore bin√°ria pode ser classificada em

- Cheia,
- Completa,
- Perfeita ou
- Degenerada,

dependendo do arranjo de seus n√≥s.

### √Årvore Bin√°ria Cheia

Cada n√≥ possui zero ou dois filhos (nunca exatamente um). Na √°rvore abaixo, nenhum n√≥ possui somente um filho. Portanto, ela √© cheia.

```{mermaid}
flowchart TB
	A(("A")) --- B(("B"))
	A --- C(("C"))
	C --- D(("D"))
	C --- E(("E"))
	D --- F(("F"))
	D --- G(("G"))


A:::WT
B:::WT
C:::WT
D:::WT
E:::WT
F:::WT
G:::WT

classDef WT fill:#FFFFFF
```	

- nenhum filho: B, E, F e G
- um filho: -
- dois filhos: A, C e D 

### √Årvore Bin√°ria Completa

Neste caso, todos os n√≠veis, acima das folhas do √∫ltimo n√≠vel, est√£o preenchidos integralmente.

```{mermaid}
flowchart TB
	A(("A")) --- B(("B"))
	A --- C(("C"))
	B --- D(("D"))
	B --- E(("E"))
	C --- F(("F"))
	C --- G(("G"))
	D --- H(("H"))
	D --- I(("I"))
    E --- J(("J"))
	E --- I1((" "))
    G --- K(("K"))
	G --- L(("L"))


A:::WT
B:::WT
C:::WT
D:::WT
E:::WT
F:::WT
G:::WT
H:::WT
I:::WT
J:::WT
K:::WT
L:::WT

classDef WT fill:#FFFFFF
style I1 stroke:none,fill:transparent
linkStyle 9 stroke:none,fill:none
```	


A √°rvore acima possui 4 n√≠veis, onde os n√≠veis 0, 1 e 2 est√£o completos.


- n√≠vel 0: A
- n√≠vel 1: B e C
- n√≠vel 2: D, E, F e G

::: {.column-margin}
**[Se liga!]{.text-warning}**
Em uma √°rvore bin√°ria, para um n√≠vel $n$ estar completo √© necess√°rio que ele possua $2^n$ n√≥s
:::


### √Årvore Bin√°ria Perfeita

√â uma √°rvore bin√°ria em todos os n√≠veis est√£o completamente preenchidos.

```{mermaid}
flowchart TB
	A(("A")) --- B(("B"))
	A --- C(("C"))
	B --- D(("D"))
	B --- E(("E"))
	C --- F(("F"))
	C --- G(("G"))
	D --- H(("H"))
	D --- I(("I"))
    E --- J(("J"))
	E --- K(("K"))
    F --- L(("L"))
	F --- M(("M"))
    G --- N(("N"))
	G --- O(("O"))


A:::WT
B:::WT
C:::WT
D:::WT
E:::WT
F:::WT
G:::WT
H:::WT
I:::WT
J:::WT
K:::WT
L:::WT
M:::WT
N:::WT
O:::WT

classDef WT fill:#FFFFFF
```	


Todos os n√≥s internos t√™m dois filhos e todas as folhas est√£o no mesmo n√≠vel.

### √Årvore Degenerada


Uma √°rvore degenerada que √© aquela em que cada n√≥ tem no m√°ximo um filho. Isso faz com que a √°rvore se assemelhe a uma lista encadeada.

```{mermaid}
flowchart LR
 subgraph s1[" "]
	A(("A"))
    I1((" "))
    B(("B"))
	I2((" "))
    C(("C"))
	I3((" "))
    D(("D"))
	I4((" "))
    E(("E"))
end

 subgraph s2[" "]
	A2(("A"))
    I9((" "))
    B2(("B"))
	I10((" "))
    C2(("C"))
	I11((" "))
    D2(("D"))
	I12((" "))
    E2(("E"))
end

 subgraph s3[" "]
	A1(("A"))
    I5((" "))
    B1(("B"))
	I6((" "))
    C1(("C"))
	I7((" "))
    D1(("D"))
	I8((" "))
    E1(("E"))
end
	A ~~~ I1
    A --- B
	B ~~~ I2
    B --- C
	C ~~~ I3
    C --- D
	D ~~~ I4
    D --- E

	A1 --- B1
	A1 ~~~ I5
    B1 --- C1
	B1 ~~~ I6
    C1 --- D1
	C1 ~~~ I7
    D1 --- E1
    D1 ~~~ I8
    
	A2 --- B2
    A2 ~~~ I9
	B2 ~~~ I10
    B2 --- C2
	C2 --- D2
	C2 ~~~ I11
    D2 ~~~ I12
    D2 --- E2

    s1 ~~~ s2
    s2 ~~~ s3

A:::WT
B:::WT
C:::WT
D:::WT
E:::WT
A2:::WT
B2:::WT
C2:::WT
D2:::WT
E2:::WT

A1:::WT
B1:::WT
C1:::WT
D1:::WT
E1:::WT

classDef WT fill:#FFFFFF
style I1 stroke:none,fill:transparent
style I2 stroke:none,fill:transparent
style I3 stroke:none,fill:transparent
style I4 stroke:none,fill:transparent
style I5 stroke:none,fill:transparent
style I6 stroke:none,fill:transparent
style I7 stroke:none,fill:transparent
style I8 stroke:none,fill:transparent
style I9 stroke:none,fill:transparent
style I10 stroke:none,fill:transparent
style I11 stroke:none,fill:transparent
style I12 stroke:none,fill:transparent
style s1 stroke:none,fill:transparent
style s2 stroke:none,fill:transparent
style s3 stroke:none,fill:transparent
```	

## Percursos

Como podemos visitar todos os n√≥s de uma √°rvore, sem exce√ß√£o, somente uma vez? Isso pode ser realizado de v√°rias maneiras.

Um percurso, ou travessia, diz respeito ao modo de como percorremos uma √°rvore. Percorrer uma √°rvore bin√°ria envolve visitar todos os seus n√≥s em uma ordem espec√≠fica para realizar v√°rias opera√ß√µes, como pesquisar, classificar ou modificar a √°rvore.

As estrat√©gias de travessia s√£o amplamente classificadas em:

- Percurso em Largura
- Percurso em Profundidade

### Percurso em Largura

O percurso em largura visita os n√≥s em cada n√≠vel, da esquerda para a direita, antes de prosseguir para o pr√≥ximo. Essa abordagem √© ideal quando todos os n√≥s em um n√≠vel precisam ser processados antes de passar para o pr√≥ximo.

Exemplo
```{mermaid}
flowchart TB
	A(("A")) --- B(("B"))
	A --- C(("C"))
	B --- D(("D"))
	B --- E(("E"))

A:::WT
B:::WT
C:::WT
D:::WT
E:::WT

classDef WT fill:#FFFFFF
```	

Um percurso em largura resultar√° na sequ√™ncia A, B, C, D e E.

- No n√≠vel 0, passamos por A;
- No n√≠vel 1, passamos por B e C;
- No n√≠vel 2, passamos por D e E;


### Percurso em Profundidade

O percurso em profundidade explora o mais profundamente poss√≠vel em cada ramo antes de retroceder. Esta categoria inclui os subtipos pr√©-ordem, ordeme p√≥s-ordem.

Vamos usar a seguinte √°rvore para exemplificar tais percursos.

```{mermaid}
flowchart TB
	A(("A")) --- B(("B"))
	A --- C(("C"))

A:::WT
B:::WT
C:::WT

classDef WT fill:#FFFFFF
```	

#### Pr√©-ordem

Cada n√≥ √© processado antes de seus filhos. Segue a seguinte ordem de visita:

- raiz 
- sub√°rvore esquerda
- sub√°rvore direita

Processamos a raiz (A) e vamos para a sub√°rvore esquerda. Processamos a nova raiz (B). N√£o temos sub√°rvores de B, ent√£o voltamos e analisamos a sub√°rvore direita de A. Processamos a nova raiz (C). N√£o temos sub√°rvores de C, logo finalizamos.

Resultado: A, B, C

> O percurso em pr√©-ordem √© ideal para
>
> - C√≥pia de Estrutura de Diret√≥rios: Quando o sistema operacional precisa copiar uma pasta e seus subdiret√≥rios, ele usa a l√≥gica de pr√©-ordem. Ele primeiro cria a pasta principal (raiz) e depois entra nela para criar os arquivos e pastas internos.
> - Express√µes Matem√°ticas (Nota√ß√£o Polonesa): √â usado para converter express√µes em uma forma que computadores leiam facilmente sem precisar de par√™nteses. Por exemplo, a express√£o + 3 4 (onde o operador vem antes dos n√∫meros).


::: {.callout-tip title="Exerc√≠cio"}
Nesse exerc√≠cio, voc√™ deve reproduzir o comportamento de uma travessia em pr√©-ordem. Clique nos n√≥s para indicar a ordem na qual o algoritmo de travessia deve percorre-los. O bot√£o reset cria um novo exerc√≠cio.

```{=html}
<iframe src="https://opendsa-server.cs.vt.edu/embed/btTravPreorderPRO" style="border:none;" height="430" width="900" scrolling="no"></iframe>
```
:::



#### Ordem

Processa a sub√°rvore esquerda, o n√≥ atual e, em seguida, a sub√°rvore direita.

No nosso exemplo, vamos para a sub√°rvore esquerda. Processamos a nova raiz (B). Voltamos para a raiz e processamos (A). Vamos para a sub√°rvore direita. Processamos a nova raiz (C).

Resultado: B, A, C

> Este percurso √© amplamente utilizado em estruturas de dados que precisam manter alguma ordem.

::: {.callout-tip title="Exerc√≠cio"}
Nesse exerc√≠cio, voc√™ deve reproduzir o comportamento de uma travessia em ordem. Clique nos n√≥s para indicar a ordem na qual o algoritmo de travessia deve percorre-los. O bot√£o reset cria um novo exerc√≠cio.

```{=html}
<iframe src="https://opendsa-server.cs.vt.edu/embed/btTravInorderPRO" style="border:none;" height="430" width="100%" scrolling="no"></iframe>
```
:::


#### P√≥s-ordem

Acessa o n√≥ atual ap√≥s suas sub√°rvores. Segue a seguinte ordem de visita: 

- sub√°rvore esquerda
- sub√°rvore direita
- raiz

No nosso exemplo, vamos para a sub√°rvore esquerda. Processamos a nova raiz (B). Vamos para a sub√°rvore direita. Processamos a nova raiz (C). Voltamos para a raiz e processamos (A).

Resultado: B, C, A

> A p√≥s-ordem √© usada quando voc√™ precisa processar as folhas antes de chegar ao topo.
>
> - C√°lculo de Tamanho de Pastas: Para saber o tamanho total de uma pasta no seu computador, o sistema primeiro soma o tamanho de todos os arquivos individuais (folhas) e subpastas para, por √∫ltimo, dar o resultado da pasta raiz.
> - Exclus√£o de √Årvores: Para deletar uma √°rvore de forma segura na mem√≥ria, voc√™ deve deletar os filhos primeiro. Se voc√™ deletar a raiz primeiro, perder√° o acesso (ponteiro) para os filhos, causando vazamento de mem√≥ria.
> - Avalia√ß√£o de Express√µes Matem√°ticas: Compiladores usam isso para resolver contas. Para calcular (3 + 4) * 5, o computador primeiro resolve o 3 e o 4, depois o +, e s√≥ ent√£o multiplica pelo 5.

::: {.callout-tip title="Exerc√≠cio"}
Nesse exerc√≠cio, voc√™ deve reproduzir o comportamento de uma travessia em p√≥s-ordem. Clique nos n√≥s para indicar a ordem na qual o algoritmo de travessia deve percorre-los. O bot√£o reset cria um novo exerc√≠cio.
```{=html}
<iframe src="https://opendsa-server.cs.vt.edu/embed/btTravPostorderPRO" style="border:none;" height="430" width="100%" scrolling="no"></iframe>
```
:::


Para fixa√ß√£o, vamos considerar uma nova nova √°rvore: 

```{mermaid}
flowchart TB
	A(("A")) --- B(("B"))
	A --- C(("C"))
	B --- D(("D"))
	B --- E(("E"))
	C --- I1((" "))
	C --- F(("F"))

A:::WT
B:::WT
C:::WT
D:::WT
E:::WT
F:::WT

classDef WT fill:#FFFFFF
linkStyle 4 stroke:none,fill:none
style I1 stroke:none,fill:transparent
```	


- Largura: A, B, C, D, E, F
- Pr√©-ordem (N√≥, Esquerda, Direta): A, B, D, E, C, F
- Ordem (Esquerda, N√≥, Direta): D, B, E, A, C, F
- P√≥s-ordem (Esquerda, Direta, N√≥): D, E, B, F, C, A

::: {.column-margin}
**[Se liga!]{.text-warning}**
Os percursos em √°rvore podem ser usados para a serializa√ß√£o, isto √©, salvar uma √°rvore em um arquivo para carreg√°-la exatamente igual depois.
:::


## Implementa√ß√£o

Como se trata de uma estrutura din√¢mica, usaremos ponteiros. 

Para criarmos uma √°rvore bin√°ria em C, devemos criar uma nova estrutura. Tal estrutura deve conter o valor da chave e dois ponteiros para indicar os filhos do lado esquerdo e direito.

```c
typedef struct node {
    int data;
    struct node *left;
    struct node *right;
} Node;
```

Fun√ß√£o para criar um n√≥

```c
Node* create_node(int key) {
    Node* new_node = malloc(sizeof(Node));
    new_node->key = key;
    new_node->left = new_node->right = NULL;
     
    return new_node;
}
```

A fun√ß√£o `create_node` recebe uma chave inteira e retorna um ponteiro para um objeto do tipo `Node`. Na segunda linha, estamos alocando mem√≥ria para o novo n√≥. Para isso, `sizeof(Node)` calcula o tamanho em _bytes_ necess√°rio. Em seguida, preenchemos os campos do n√≥ `new_node`: a chave e os filhos. No caso, o novo n√≥ n√£o possui filhos, ent√£o recebem o valor `NULL`.

Na fun√ß√£o principal (`main`), podemos fazer a inser√ß√£o da seguinte forma:

```c
Node* root = create_node(10);

root->left = create_node(15);
root->right = create_node(5);
root->right->left = create_node(12);
root->right->right = create_node(18);
```

Esse c√≥digo representa a seguinte √°rvore:

```{mermaid}
flowchart TB
	A(("10")) --- B(("15"))
	A --- C(("05"))
	C --- D(("12"))
	C --- E(("18"))

A:::WT
B:::WT
C:::WT
D:::WT
E:::WT

classDef WT fill:#FFFFFF
```	

Os percusos s√£o implementados recursivamente da seguinte forma:

```c
void pre_order(Node *root) {
    if (root != NULL) {
        printf("%d ", root->key);
        pre_order(root->left);
        pre_order(root->right);
    }
}

void in_order(Node *root) {
    if (root != NULL) {
        in_order(root->left);
        printf("%d ", root->key);
        in_order(root->right);
    }
}

void pos_order(Node *root) {
    if (root != NULL) {
        pos_order(root->left);
        pos_order(root->right);
        printf("%d ", root->key);
    }
}
```

Na pasta code, voc√™ pode encontrar a implementa√ß√£o no arquivo arvorebinaria.c. Desse modo, voc√™ pode criar √°rvores diversas e verificar as travessias implementadas.

No nosso exemplo anterior, o programa deve gerar a sa√≠da:

- Pre-Ordem:  10 15 5 12 18
- Ordem:      15 10 12 5 18
- Pos-Ordem:  15 12 18 5 10

---

Nesta se√ß√£o, estudamos a estrutura de dados √°rvore bin√°ria. Em particular,

‚úÖ definimos essa estrutura;

‚úÖ classificamos as √°rvores bin√°rias (cheia, completa, perfeita e degenerada);

‚úÖ realizamos percursos em largura e profundidade;

‚úÖ abordamos as travessias em pr√©-ordem, ordem e p√≥s-ordem.

```quizdown

# O que caracteriza uma √°rvore bin√°ria ?

> Considere a defini√ß√£o formal apresentada no texto.

1. [ ] Todo n√≥ possui exatamente dois filhos  
1. [ ] Todo n√≥ possui pelo menos um filho  
1. [x] Todo n√≥ possui no m√°ximo dois filhos  
1. [ ] Apenas a raiz pode ter dois filhos  


# Sobre as propriedades de √°rvores bin√°rias

> Considere uma √°rvore bin√°ria com altura h e n n√≥s.

- [x] Uma √°rvore bin√°ria de altura h tem no m√°ximo \(2^{h+1}-1\) n√≥s  
- [x] Uma √°rvore bin√°ria com n n√≥s tem altura m√≠nima \(\lceil \log_2(n+1)\rceil - 1\)  
- [ ] Uma √°rvore bin√°ria sempre tem exatamente \(n/2\) folhas  
- [x] Uma √°rvore bin√°ria com n n√≥s tem no m√°ximo \(\lceil n/2\rceil\) folhas  


# Classifique a √°rvore onde cada n√≥ possui zero ou dois filhos, nunca exatamente um.

1. [ ] √Årvore completa  
1. [ ] √Årvore perfeita  
1. [x] √Årvore cheia  
1. [ ] √Årvore degenerada  


# Em uma √°rvore bin√°ria completa 

> Considere o preenchimento dos n√≠veis da √°rvore.

1. [ ] Todos os n√≠veis est√£o completamente preenchidos  
1. [x] Todos os n√≠veis acima do √∫ltimo est√£o completamente preenchidos  
1. [ ] Apenas o n√≠vel das folhas √© completo  
1. [ ] Apenas a raiz est√° completa  


# Em uma √°rvore bin√°ria perfeita

> Considere a estrutura global da √°rvore.

1. [ ] Apenas os n√≥s internos t√™m dois filhos  
1. [ ] Apenas as folhas est√£o no mesmo n√≠vel  
1. [x] Todos os n√≠veis est√£o completamente preenchidos  
1. [ ] Apenas os dois primeiros n√≠veis est√£o completos  


# Uma √°rvore degenerada

> Compare a estrutura da √°rvore com outras estruturas conhecidas.

1. [ ] Se comporta como uma pilha  
1. [ ] Se comporta como uma fila  
1. [x] Se comporta como uma lista encadeada  
1. [ ] Se comporta como um grafo completo  


# O percurso em largura 

> Considere a ordem de visita dos n√≥s.

1. [ ] Visita primeiro os ramos mais profundos  
1. [x] Visita os n√≥s n√≠vel a n√≠vel, da esquerda para a direita  
1. [ ] Visita primeiro a sub√°rvore esquerda  
1. [ ] Visita primeiro as folhas  


# Quais percursos pertencem √† categoria de percurso em profundidade?

- [x] Pr√©-ordem  
- [x] Ordem  
- [x] P√≥s-ordem  
- [ ] Percurso em largura  


# Sobre a implementa√ß√£o em C

> Considere a estrutura `Node` apresentada no texto.

- [x] Cada n√≥ armazena uma chave  
- [x] Cada n√≥ possui um ponteiro para o filho esquerdo  
- [x] Cada n√≥ possui um ponteiro para o filho direito  
- [ ] Cada n√≥ armazena obrigatoriamente o ponteiro para o pai  


# Sobre a implementa√ß√£o dos percursos

> Considere os c√≥digos apresentados.

1. [ ] S√£o implementados iterativamente  
1. [x] S√£o implementados de forma recursiva  
1. [ ] Apenas o percurso em largura √© recursivo  
1. [ ] Apenas o percurso em profundidade √© iterativo  
```

Agora que estamos familiarizados com os conceitos fundamentais da estrutura de dados √°rvore, iremos estudar um tipo especial de √°rvore bin√°ria chamada √°rvore bin√°ria de busca.

Procure dominar os percursos realizando os exerc√≠cios propostos deste cap√≠tulo.


{{< include /_includes/progress-bar.qmd >}}
